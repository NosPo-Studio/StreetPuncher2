local licenseNotice = [[This installation script is createt by MisterNoNameLPs OC project exporter v1.0.5
<https://github.com/MisterNoNameLP/ocCraft/blob/master/src/debug/export.lua>.

This installer DO NOT give ANY WARRANTY for stored/installed data.
All stored/installed data are third party content i am not responsible for. 

  export Copyright (C) 2019 MisterNoNameLP.
  
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]
local data = {["./tools/export.lua"] = "local licenseNotice = [[\n  export Copyright (C) 2019 MisterNoNameLP.\n  \n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\n--[[A very simple project exporter.\n  Written by:\n    MisterNoNameLP.\n]]\nlocal version = \"v1.0.5\"\n\nlocal installScript = [[\n--===== local functions =====--\nfunction seperatePath(path) --Ripped from UT_v0.6.1\n--seperates a data path [\"./DIR/FILE.ENDING\"] into the dir path [\"./DIR/\"], the file name [\"FILE\"], and the file ending [\".ENDING\" or nil]\n  if string.sub(path, #path) == \"/\" then\n    return path\n  end\n  \n  local dir, fileName, fileEnd = \"\", \"\", nil\n  local tmpLatest = \"\"\n  for s in string.gmatch(tostring(path), \"[^/]+\") do\n    tmpLatest = s\n  end\n  dir = string.sub(path, 0, #path -#tmpLatest)\n  for s in string.gmatch(tostring(tmpLatest), \"[^.]+\") do\n    fileName = fileName .. s\n    tmpLatest = s\n  end\n  if fileName == tmpLatest then\n    fileName = tmpLatest\n  else\n    fileEnd = \".\" .. tmpLatest\n    fileName = string.sub(fileName, 0, #fileName - #fileEnd +1)\n  end\n  \n  return dir, fileName, fileEnd\nend\n\n--===== prog start =====--\nlocal fs = require(\"filesystem\")\nlocal shell = require(\"shell\")\nlocal serialization = require(\"serialization\")\n\nlocal args, opts = shell.parse(...)\nlocal emptyBufferSpace = 10\n\nif opts.h or #args == 0 then\n  \n  print(\"Usage: SETUP [OPTIONS]... [TARGET_DIR]...\")\n  print(\"  -h     Shows this text.\")\n  print(\"  -o       Overwrite the EXPORT_DIR.\")\n  \n  return true\nend\n\nprint(licenseNotice)\n\nif not opts.o then\n  if string.sub(args[1], 0, 1) == \"/\" and fs.exists(args[1]) then\n    return false, \"Folder exists already.\"\n  elseif fs.exists(shell.getWorkingDirectory() .. args[1]) then\n    return false, \"Folder exists already.\"\n  end\nend\n\nfor i, s in pairs(data) do\n  local path, file, ending = seperatePath(i)\n  file = (file or \"\") .. (ending or \"\")\n  if string.sub(args[1], 0, 1) == \"/\" then\n    path = \"/\" .. args[1] .. \"/\" .. (path or \"\")\n  else\n    path = shell.getWorkingDirectory() .. \"/\" .. args[1] .. \"/\" .. (path or \"\")\n  end\n  \n  print(\"Create file: \" .. path .. file)\n  \n  fs.makeDirectory(path)\n  if s ~= 0 then\n    local f = io.open(path .. file, \"w\")\n    for c = 1, #s, (f.bufferSize - emptyBufferSpace) +1 do\n      f:write(string.sub(s, c, c + f.bufferSize - emptyBufferSpace))\n      f:flush()\n    end\n    f:close()\n  end\nend\n]]\n\nlocal fs = require(\"filesystem\")\nlocal shell = require(\"shell\")\nlocal serialization = require(\"serialization\")\n\nlocal args, opts = shell.parse(...)\n\nlocal dirs = 0\nlocal files = 0\nlocal linesOfCode = 0\nlocal exportFile = nil\nlocal relativePath = \"\"\n\nlocal function write(file, s, emptyBufferSpace)\n  emptyBufferSpace = emptyBufferSpace or 10\n  for c = 1, #s, (file.bufferSize - emptyBufferSpace) +1 do\n    file:write(string.sub(s, c, c + file.bufferSize - emptyBufferSpace))\n    file:flush()\n  end\nend\n\nlocal function parseFiles(path, countLines, export)\n  if string.sub(path, 0, 1) ~= \"/\"  then\n    path = path or \"\"\n    path = shell.getWorkingDirectory() .. \"/\" .. path .. \"/\"\n    relativePath = shell.getWorkingDirectory()\n  end\n  print(path)\n  for file in fs.list(path) do\n    if string.sub(file, #file) == \"/\" then\n      parseFiles(path .. file, countLines, export)\n      dirs = dirs +1\n      if export then\n        write(exportFile, \"[\\\"\" .. string.sub(path .. file, #relativePath + #args[1] +1) .. \"\\\"] = 0,\")\n      end\n    else\n      local tmpPath = \"/\" .. path .. file\n      \n      if export then\n        \n        local emptyBufferSpace = #tmpPath +20\n        local f = io.open(tmpPath, \"r\")\n        local ss = serialization.serialize(f:read(\"*all\"))\n        f:close()\n        \n        write(exportFile, \"[\\\"\" .. string.sub(path .. file, #relativePath + #args[1] +1) .. \"\\\"] = \", emptyBufferSpace)\n        write(exportFile, ss, emptyBufferSpace)\n        exportFile:write(\",\")\n      end\n      \n      if countLines then\n        files = files +1\n        for l in io.lines(tmpPath) do\n          linesOfCode = linesOfCode +1\n        end\n      end\n    end\n  end\nend\n\nif opts.v then\n  print(\"exporter \" .. version)\n  if not opts.h then\n    return true\n  end\nend\n\nif opts.h or #args == 0 then\n  print([[\nUsage: export [OPTIONS]... [DIR]... [EXPORT_FILE]...\n  -e      Exports the DIR with all sub dirs/files as installer script to EXPORT_FILE.\n  -h      Shows this text.\n  -i      Collects some infos (dirs, files, lines of text) about DIR with all sub dirs/files (can take a while on big projects).\n  -o      Overwrite the EXPORT_FILE.\n  ]])\n  return true\nend\n\nif opts.e then\n  if args[2] == nil then\n    return false, \"No export file name given.\"\n  end\n  \n  if io.open(args[2], \"r\") == nil or opts.o then\n    exportFile = io.open(args[2], \"w\")\n    write(exportFile, \"local licenseNotice = [[This installation script is createt by MisterNoNameLPs OC project exporter \" .. version .. \"\\n<https://github.com/MisterNoNameLP/ocCraft/blob/master/src/debug/export.lua>.\\n\")\n    \n    write(exportFile, \"\\nThis installer DO NOT give ANY WARRANTY for stored/installed data.\\n\")\n    write(exportFile, \"All stored/installed data are third party content i am not responsible for. \\n\")\n    \n    write(exportFile, \"\\n\" .. licenseNotice .. \"]]\\n\")\n    \n    write(exportFile, \"local data = {\")\n  else\n    return false, \"File are existing already.\"\n  end\nend\n\nparseFiles(args[1], opts.i, opts.e)\n\nif opts.e then\n  exportFile:write(\"} \\n\")\n  \n  write(exportFile, installScript, 10)\n  \n  exportFile:close()\nend\n\nif opts.i then\n  print(\"--===== Project infos =====--\")\n  print(\"folders: \" .. tostring(dirs) .. \" | files: \" .. tostring(files) .. \" | lines: \" .. tostring(linesOfCode))\nend\n",["./tools/extractEngineFiles.lua"] = "local version = \"v0.1d\"\n\nlocal extractionList = [[\nnosGa.lua\nlibs\ndata/core\ndata/gameObjects/nge\ndata/global/nge\ndata/parents/nge\n\ntexturePacks/example\ndata/states/example.lua\nmods/example.lua\n\ntools\n]]\n\nlocal fs = require(\"filesystem\")\nlocal ut = require(\"libs/UT\")\nlocal shell = require(\"shell\")\n\nlocal args, opts = shell.parse(...)\nlocal targetDir = args[1]\nlocal wd = shell.getWorkingDirectory() .. \"/\"\n\nif targetDir == nil then\n    print(\"No output dir given\")\n    os.exit(1)\nend\n\nif fs.exists(wd .. targetDir) and opts.O ~= true then\n    print(\"Target dir already exists\")\n    os.exit(2)\nend\n\nif not fs.exists(wd .. targetDir) then\n    if os.execute(\"mkdir \" .. targetDir) ~= true then\n        print(\"Cant create dir\")\n        os.exit(3)\n    end\nend\n\nfor s in extractionList:gmatch(\"[^\\r\\n]+\") do\n    local target = targetDir .. \"/\" .. ut.seperatePath(s)\n\n    if fs.exists(wd .. target) ~= true then\n        print(\"Create dir: '\" .. target .. \"'\")\n        os.execute(\"mkdir \" .. target)\n    end\n\n    print(\"Copy: '\" .. s .. \"' to: '\" .. target .. \"'\")\n    os.execute(\"cp -r \" .. s .. \" \" .. target)\nend\n\nprint(\"Done\")",["./tools/"] = 0,["./data/states/example.lua"] = "",["./data/states/test.lua"] = "--[[\n    This file is part of the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ...\n\n--===== shared vars =====--\nlocal test = {\n}\n\n--===== local vars =====--\n\n--===== local functions =====--\nlocal function print(...)\n\9global.log(...)\nend\n\n--===== shared functions =====--\nfunction test.init()\n\9print(\"[test]: Start init.\")\n\9\n\9--===== debug =====--\n\9\n\9--===== debug end =====--\n\9\n\9global.load({\n\9\9toLoad = {\n\9\9\9parents = true,\n\9\9\9testObjects = true,\n\9\9\9textures = true,\n\9\9\9animations = true,\n\9\9\9globalStructured = true,\n\9\9\9gameObjects = true,\n\9\9},\n\9})\n\n\n\9--=== mirror plyaer textures ===--\n\9if not global.texture.player.head1_flipped then\n\9\9local image = require(\"libs/thirdParty/image\")\n\9\9local flippedTextures = {}\n\n\9\9for i, t in pairs(global.texture.player) do\n\9\9\9if type(t) == \"table\" and t.format == \"pic\" and not t.flippedHorizontaly then\n\9\9\9\9local flippedTexture = image.flipHorizontally(t)\n\9\9\9\9flippedTexture.format = \"pic\"\n\9\9\9\9flippedTexture.flippedHorizontaly = true\n\9\9\9\9\n\9\9\9\9flippedTextures[i .. \"_flipped\"] = flippedTexture\n\9\9\9end\n\9\9end\n\9\9for i, t in pairs(flippedTextures) do \n\9\9\9global.texture.player[i] = t\n\9\9end\n\9end\n\n\9\n\9--=== init test ===--\n\9global.clear()\n\n\9--global.texture.background = global.splitTexture(\"v\", global.texture.background, 50)\n\9test.texture1, test.texture2 = global.splitTexture(\"v\", global.texture.player.head1, 4)\n\9\n\9test.raMain = global.addRA({\n\9\9posX = 1, \n\9\9posY = 1, \n\9\9sizeX = global.resX, \n\9\9sizeY = global.resY, \n\9\9name = \"TRA1\", \n\9\9drawBorders = true,\n\9})\n\n\9test.raMain:addGO(\"BackgroundTile\", {\n\9\9posX = 10,\n\9\9posY = 10,\n\9\9texture = test.texture1,\n\9})\n\9test.raMain:addGO(\"BackgroundTile\", {\n\9\9posX = 20,\n\9\9posY = 10,\n\9\9texture = test.texture2,\n\9})\n\9\n\9\n    test.test = test.raMain:addGO(\"Test\", {\n        posX = 10,\n        posY = 25,\n        layer = 5,\n        name = \"test1\",\n\9\9id = 1,\n    })\n\9\n\9--[[\n\9test.test2 = test.raMain:addGO(\"Test2\", {\n        posX = 10,\n        posY = 25,\n        layer = 3,\n        name = \"test2\",\n\9\9id = 1,\n    })\n\9test.test2 = test.raMain:addGO(\"Test3\", {\n        posX = 10,\n        posY = 25,\n        layer = 4,\n        name = \"test3\",\n\9\9id = 1,\n    })\n\n\9\n\9test.background = test.raMain:addGO(\"Background\", {\n        posX = 0,\n        posY = 0,\n        layer = 1,\n        name = \"background\",\n    })\n\9]]\n\9\n\nend\n\nfunction test.start()\n\9\n\9--===== debug =====--\n\9\n\n\n\9\n\9--===== debug end =====--\n\9\nend\n\nfunction test.update()\n\9\nend\n\nfunction test.draw()\n\9--global.db.drawImage(50, 10, global.texture.player.head1)\n\9--global.db.drawImage(45, 10, global.texture.player.body)\n\n\9--global.db.drawImage(50, 10, test.texture1)\n\9--global.db.drawImage(60, 10, test.texture2)\nend\n\nfunction test.ctrl_reset_key_down()\n\9\nend\n\nfunction test.stop()\n\9\nend\n\nreturn test\n\n\n\n\n\n",["./data/states/game.lua"] = "--[[\n    This file is part of the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ...\n\nglobal.gameName = \"StreetPuncher2\"\nglobal.gameVersion = \"v1.0.1\"\n\n--===== shared vars =====--\nlocal game = {\n\9gameIsRunning = true,\n\9winner = \"\",\n\9framesSinceDeath = 0,\n}\n\n--===== local vars =====--\nlocal unicode = require(\"unicode\")\n\n--===== local functions =====--\nlocal function print(...)\n\9global.log(...)\nend\n\n--===== shared functions =====--\nfunction game.init()\n\9print(\"[game]: Start init.\")\n\9\n\9--===== debug =====--\n\9\n\9--===== debug end =====--\n\9\n\9global.load({\n\9\9toLoad = {\n\9\9\9parents = true,\n\9\9\9gameObjects = true,\n\9\9\9textures = true,\n\9\9\9animations = true,\n\9\9\9globalStructured = true,\n\9\9},\n\9})\n\n\9--=== make textures transparent ===--\n\n\9--=== mirror plyaer textures ===--\n\9if not global.texture.player.head1_flipped then\n\9\9local image = require(\"libs/thirdParty/image\")\n\9\9local flippedTextures = {}\n\n\9\9for i, t in pairs(global.texture.player) do\n\9\9\9if type(t) == \"table\" and t.format == \"pic\" and not t.flippedHorizontaly then\n\9\9\9\9local flippedTexture = image.flipHorizontally(t)\n\9\9\9\9flippedTexture.format = \"pic\"\n\9\9\9\9flippedTexture.flippedHorizontaly = true\n\9\9\9\9\n\9\9\9\9flippedTextures[i .. \"_flipped\"] = flippedTexture\n\9\9\9end\n\9\9end\n\9\9for i, t in pairs(flippedTextures) do \n\9\9\9global.texture.player[i] = t\n\9\9end\n\9end\n\n\9\n\9--=== init game ===--\n\9global.clear()\n\n\n\9game.raMain = global.addRA({\n\9\9posX = 1, \n\9\9posY = 1, \n\9\9sizeX = global.resX, \n\9\9sizeY = global.resY, \n\9\9name = \"TRA1\", \n\9\9drawBorders = true,\n\9})\n\9\n    game.player1 = game.raMain:addGO(\"Player\", {\n        posX = 10,\n        posY = 25,\n        layer = 3,\n        name = \"Player1\",\n\9\9id = 1,\n    })\n\n\9game.player2 = game.raMain:addGO(\"Player\", {\n        posX = 52,\n        posY = 25,\n        layer = 3,\n        name = \"Player2\",\n\9\9id = 2,\n    })\n\9\n\9\n\9--=== generate background ===--\n\n\9if true then\n\9\9local width = 50\n\9\9local upperTextureHeight = 25\n\9\9local bottomTextureHeight = 5\n\9\9local upperTexture, bottomTexture = nil, nil\n\9\9local middleTextures = {}\n\9\9local tmpTexture = nil\n\n\9\9upperTexture, tmpTexture = global.splitTexture(\"h\", global.texture.background, upperTextureHeight)\n\9\9tmpTexture, bottomTexture = global.splitTexture(\"h\", tmpTexture, tmpTexture.resY - bottomTextureHeight)\n\9\9\n\9\9\n\n\9\9for c = 0, math.floor(global.resX / width) do\n\9\9\9local middleTextureSplit\n\9\9\9\n\9\9\9if tmpTexture.resX > width then\n\9\9\9\9middleTextureSplit, tmpTexture = global.splitTexture(\"v\", tmpTexture, width)\n\9\9\9else\n\9\9\9\9middleTextureSplit = tmpTexture\n\9\9\9end\n\9\9\9\n\9\9\9game.raMain:addGO(\"BackgroundTile\", {\n\9\9\9\9layer = 1, \n\9\9\9\9posX = width * c,\n\9\9\9\9posY = upperTextureHeight,\n\9\9\9\9texture = middleTextureSplit,\n\9\9\9\9name = \"BGMiddle\" .. tostring(c + 1),\n\9\9\9})\n\9\9end\n\n\9\9game.raMain:addGO(\"BackgroundTile\", {\n\9\9\9layer = 1, \n\9\9\9posX = 0,\n\9\9\9posY = 0,\n\9\9\9texture = upperTexture,\n\9\9\9name = \"BGUpper\",\n\9\9})\n\9\9game.raMain:addGO(\"BackgroundTile\", {\n\9\9\9layer = 1, \n\9\9\9posX = 0,\n\9\9\9posY = global.resY - bottomTextureHeight,\n\9\9\9texture = bottomTexture,\n\9\9\9name = \"BGBottom\",\n\9\9})\n\n\9else\n\9\9game.background = game.raMain:addGO(\"Background\", {\n\9\9\9posX = 0,\n\9\9\9posY = 0,\n\9\9\9layer = 1,\n\9\9\9name = \"background\",\n\9\9})\n\9end\n\n\n\n\9--=== GUI ===--\n\9game.overlay = game.raMain:addGO(\"GameOverOverlay\", {\n        posX = 64,\n        posY = 8,\n        layer = 5,\n        name = \"overlay\",\n    })\n\9\n\9do --add GUI\n\9\9local gui = global.gui\n\9\9game.gui = gui.application()\n\9\9local container = game.gui:addChild(gui.container(1, 1, 160, 30))\n\9\9\n\9\9game.lifeBar1 = container:addChild(gui.progressBar(13, 3, 64, 0x990000, 0x666666, 0xffffff, 50))\n\9\9game.lifeBar2 = container:addChild(gui.progressBar(85, 3, 64, 0x990000, 0x666666, 0xffffff, 50))\n\9\9\n\9\9game.chargeBar1 = container:addChild(gui.progressBar(13, 5, 64, 0x0055bb, 0x666666, 0xffffff, 50))\n\9\9game.chargeBar2 = container:addChild(gui.progressBar(85, 5, 64, 0x0000bb, 0x666666, 0xffffff, 50))\n\n\9\9game.gui:draw(true)\n\9\9game.gui:start()\n\9end\n\n\9game.bloodContainer = game.raMain:addGO(\"BloodContainer\", {\n\9\9layer = 5,\n\9})\n\n\n\9\n\nend\n\nfunction game.start()\n\9--game.bloodContainer:bloodExplosion(50, 10)\n\n\9game.player1:reset()\n\9game.player2:reset()\n\9\n\9--===== debug =====--\n\9\n\n\n\9\n\9--===== debug end =====--\n\9\nend\n\nfunction game.update()\n\9\n\9game.lifeBar1.value = game.player1.life\n\9game.lifeBar2.value = game.player2.life\n\9game.chargeBar1.value = game.player1.charge\n\9game.chargeBar2.value = game.player2.charge\n\n\9if game.gameIsRunning and game.framesSinceDeath <= 3 then\n\9\9if \n\9\9\9(game.player1.life <= 0 and global.computer.uptime() - game.player1.bloodJetStartTime > game.player1.bloodJetTime) or \n\9\9\9(game.player2.life <= 0 and global.computer.uptime() - game.player2.bloodJetStartTime > game.player2.bloodJetTime)\n\9\9then\n\9\9\9if game.framesSinceDeath < 3 then\n\9\9\9\9game.framesSinceDeath = game.framesSinceDeath + 1\n\9\9\9else\n\9\9\9\9game.gameIsRunning = false\n\9\9\9\9\n\9\9\9\9if game.player1.life <= 0 and game.player2.life <= 0 then\n\9\9\9\9\9game.winner = \"No one\"\n\9\9\9\9elseif game.player1.life <= 0 then\n\9\9\9\9\9game.winner = game.player2.name\n\9\9\9\9elseif game.player2.life <= 0 then\n\9\9\9\9\9game.winner = game.player1.name\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\nend\n\nfunction game.draw()\n\9local backgroundColor = global.db.get(math.floor(global.resX / 2 - unicode.len(global.gameVersion) / 2 + 1), 1)\n\9global.gpu.setBackground(backgroundColor)\n\9global.gpu.setForeground(0xaaaaaa)\n\9global.gpu.set(global.resX / 2 - unicode.len(global.gameVersion) / 2 + 1, 1, global.gameVersion)\nend\n\nfunction game.ctrl_test2_key_down()\n\9global.log(\"TEST2\")\n\9\n\n\9local function resolve(action)\n\9\9local key\n\9\9for i, k in pairs(global.controls.k) do\n\9\9\9if k[1] == action then\n\9\9\9\9key = i\n\9\9\9\9break\n\9\9\9end\n\9\9end\n\9\9return key\n\9end\n\n\n\9global.log(resolve(\"player1_left\"))\n\n\9--global.realGPU.setBackground(0x0)\n\9--global.realGPU.fill(0, 0, 160, 50, \" \")\nend\n\nfunction game.ctrl_reset_key_down()\n\9game.gameIsRunning = true\n\9game.framesSinceDeath = 0\n\9\n\9--quick and dirty bug fix\n\9game.player1.life = 100\n\9game.player2.life = 100\n\n\9game.raMain:rerenderAll()\nend\n\nfunction game.stop()\n\9--game.gui:stop()\nend\n\nreturn game\n\n\n\n\n\n",["./data/states/"] = 0,["./data/core/eventHandler.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\nlocal eh = {}\13\n\13\n--===== local variables =====--\13\nlocal pressedKeys = {}\13\nlocal specialPressedKeys = {}\13\nlocal keyboard = require(\"keyboard\")\13\n\13\n--===== local functions =====--\13\nlocal function print(...)\13\n\9if global.conf.debug.ehDebug then\13\n\9\9global.debug.log(...)\13\n\9end\13\nend\13\n\13\nlocal function exportCtrlSignal(s, sname)\13\n\9local generalFunctionName = \"\"\13\n\9local specificFunctionName = \"\"\13\n\9\13\n\9local function callFunctions(f, sname)\13\n\9\9if f == nil then return false end\13\n\9\9\13\n\9\9for _, f in pairs(f) do\13\n\9\9\9generalFunctionName = \"ctrl_\" .. f\13\n\9\9\9specificFunctionName = generalFunctionName .. \"_\" .. sname\13\n\9\9\9\13\n\9\9\9if generalFunctionName ~= \"\" then\13\n\9\9\9\9global.run(global.state[global.currentState][generalFunctionName], s, sname)\13\n\9\9\9\9global.core.updateHandler.insertSignal(s, generalFunctionName)\13\n\9\9\9\9\13\n\9\9\9\9global.run(global.state[global.currentState][specificFunctionName], s, sname)\13\n\9\9\9\9global.core.updateHandler.insertSignal(s, specificFunctionName)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9if sname == \"key_down\" or sname == \"key_pressed\" or sname == \"key_up\" or sname == \"key_held\" then\13\n\9\9if global.controls.c[s[3]] then\13\n\9\9\9callFunctions(global.controls.c[s[3]], sname)\13\n\9\9elseif global.controls.k[s[4]] then\13\n\9\9\9callFunctions(global.controls.k[s[4]], sname)\13\n\9\9end\13\n\9elseif sname == \"touch\" or sname == \"drag\" or sname == \"drop\" then\13\n\9\9if global.controls.m[s[5]] then\13\n\9\9\9callFunctions(global.controls.m[s[5]], sname)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function exportSignal(s, sname)\13\n\9sname = sname or s[1]\13\n\9\13\n\9if global.state[global.currentState] ~= nil then\13\n\9\9global.run(global.state[global.currentState][sname], s)\13\n\9end\13\n\9global.core.updateHandler.insertSignal(s, sname)\13\n\9\13\n\9exportCtrlSignal(s, sname)\13\nend\13\n\13\nlocal function parseSignal(signal)\13\n\9if #signal == 0 then \13\n\9\9global.core.uiHandler.update({}) --needed for GUI to update.\13\n\9\9return false \13\n\9end\13\n\13\n\9if global.tiConsole.status == true --[[or global.conf.fastKeyCheck]] then\13\n\9\9if signal[1] == \"key_down\" or signal[1] == \"key_up\" then\13\n\9\9\9return true\13\n\9\9end\13\n\9end\13\n\9\13\n\9if global.conf.showConsole and signal[1] == \"touch\" then\13\n\9\9global.mConsole:update(signal[3], signal[4])\13\n\9end\13\n\9\13\n\9global.run(global.core.eventHandler[signal[1]], signal)\13\n\9\13\n\9if signal[1] ~= \"key_down\" then\13\n\9\9exportSignal(signal)\13\n\9end\13\n\13\n\9global.core.uiHandler.update(signal)\13\n\9\13\n\9return true\13\nend\13\n\13\n--===== global functions =====--\13\nfunction eh.init()\13\n\9\13\nend\13\n\13\nfunction eh.update(sleepTime)\9\13\n\9local signal = {true}\13\n\9\13\n\9if global.conf.queueSignals then\13\n\9\9parseSignal({global.computer.pullSignal(0)})\13\n\9else\13\n\9\9while parseSignal({global.computer.pullSignal(0)}) do end\13\n\9end\13\n\9\13\n\9local maxDT = 1 / global.conf.targetFramerate\13\n\9local dt = global.computer.uptime() - global.lastUptime\13\n\13\n\9while global.conf.targetFramerate ~= -1 and dt < maxDT do\13\n\9\9parseSignal({global.computer.pullSignal((1 / global.conf.targetFramerate) - math.max(global.dt - (1 / global.conf.targetFramerate), 0))})\13\n\9\9dt = global.computer.uptime() - global.lastUptime\13\n\9end\13\n\9\13\n\9global.dt = global.computer.uptime() - global.lastUptime\13\n\9if global.dt > global.conf.maxTickTime then\13\n\9\9if global.isDev then\13\n\9\9\9global.warn(\"Tick take too long: F: \" .. tostring(global.currentFrame) .. \", T: \" .. tostring(global.dt))\13\n\9\9end\13\n\9\9global.dt = global.conf.maxTickTime\13\n\9end\13\n\9global.lastUptime = global.computer.uptime()\13\n\9\13\n\9if global.tiConsole.status == false then\13\n\9\9for i, s in pairs(pressedKeys) do\13\n\9\9\9exportSignal(s, \"key_pressed\")\13\n\9\9end\13\n\9\9for i, s in pairs(specialPressedKeys) do\13\n\9\9\9exportSignal(s, \"key_pressed\")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction eh.touch(s)\13\n\9global.ocui:update(s[3], s[4])\13\n\9--run(global.state[global.currentState].touch, x, y, b, p)\13\nend\13\n\13\nfunction eh.key_down(s)\13\n\9local c, k, p = s[3], s[4], s[5] \13\n\9\13\n\9--===== Engine internal functionalities =====--\13\n\9if c == 3 then --ctrl + c\13\n\9\9print(\"[EH]: Program stopped by user.\")\13\n\9\9global.isRunning = false\13\n\9end\13\n\9\13\n\9if k == global.conf.debug.debugKeys.showConsole then --f1\13\n\9\9global.conf.showConsole = not global.conf.showConsole\13\n\9\9if not global.conf.showConsole then\13\n\9\9\9global.clear()\13\n\9\9end\13\n\9end\13\n\9\13\n\9if k == global.conf.debug.debugKeys.writeInConsole then --f2\13\n\9\9global.tiConsole:activate()\13\n\9end\13\n\9\13\n\9if k == global.conf.debug.debugKeys.showDebug then --f3\13\n\9\9global.conf.showDebug = not global.conf.showDebug\13\n\9\9if not global.conf.showDebug then\13\n\9\9\9global.clear()\13\n\9\9end\13\n\9end\13\n\9if k == global.conf.debug.debugKeys.reloadState and global.isDev then --f5\13\n\9\9global.log(\"--========== RELOAD STAGE ==========--\")\13\n\9\9global.run(global.state[global.currentState].stop)\13\n\9\9global.state[global.currentState] = nil\13\n\9\9\13\n\9\9global.gameObjects = {}\13\n\9\9global.renderAreas = {}\13\n\9\9\13\n\9\9if global.conf.debug.onReload.conf then\13\n\9\9\9global.load({\13\n\9\9\9\9toLoad = {conf = true},\13\n\9\9\9\9reload = true, \13\n\9\9\9})\13\n\9\9end\13\n\9\9global.conf.debug.onReload.reload = true\13\n\9\9if global.keyboard.isControlDown() then\13\n\9\9\9local reloadList = {}\13\n\9\9\9\13\n\9\9\9for i, c in pairs(global.conf.debug.onReload) do\13\n\9\9\9\9reloadList[i] = true\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9global.load({\13\n\9\9\9\9toLoad = reloadList,\13\n\9\9\9\9reload = true,\13\n\9\9\9})\13\n\9\9else\13\n\9\9\9global.load({\13\n\9\9\9\9toLoad = global.conf.debug.onReload,\13\n\9\9\9\9reload = true,\13\n\9\9\9})\13\n\9\9end\13\n\9\9\13\n\9\9global.conf.debug.onReload.reload = nil\13\n\9\9\13\n\9\9global.state[global.currentState] = loadfile(\"data/states/\" .. global.currentState .. \".lua\")(global)\13\n\9\9global.run(global.state[global.currentState].init)\13\n\9\9global.run(global.state[global.currentState].start)\13\n\9\9\13\n\9\9global.clear()\13\n\9\9global.lastUptime = global.computer.uptime()\13\n\9end\13\n\9if k == global.conf.debug.debugKeys.rerenderScreen then --f6\13\n\9\9global.clear()\13\n\9end\13\n\9\13\n\9--===== General key press handling =====--\13\n\9if pressedKeys[0] == nil and pressedKeys[c] == nil then\13\n\9\9exportSignal(s)\13\n\9\9pressedKeys[c] = s\13\n\9elseif pressedKeys[0] ~= nil and specialPressedKeys[c] == nil then\13\n\9\9exportSignal(s)\13\n\9\9specialPressedKeys[c] = s\13\n\9end\13\nend\13\n\13\nfunction eh.key_up(s)\13\n\9if s[3] == 0 then\13\n\9\9for i, c in pairs(specialPressedKeys) do\13\n\9\9\9exportSignal(c, s[1])\13\n\9\9\9specialPressedKeys[i] = nil\13\n\9\9end\13\n\9end\13\n\9\13\n\9pressedKeys[s[3]] = nil\13\n\9specialPressedKeys[s[3]] = nil\13\nend\13\n\13\nfunction eh.resetPressedKeys()\13\n\9pressedKeys = {}\13\n\9specialPressedKeys = {}\13\nend\13\n\13\nfunction eh.stop()\13\n\9pressedKeys = {}\13\n\9specialPressedKeys = {}\13\nend\13\n\13\neh.parseSignal = parseSignal\13\n\13\nreturn eh",["./data/core/global.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal args = {...}\13\nlocal conf = args[1]\13\n\13\nlocal xpcall = xpcall\13\nlocal freeMemory, totalMemory = require(\"computer\").freeMemory, require(\"computer\").totalMemory\13\nlocal gpuFreeMemory, gpuTotalMemory\13\n\13\ndo \13\n\9local gpu = require(\"component\").gpu\13\n\9if gpu.freeMemory then\13\n\9\9gpuFreeMemory, gpuTotalMemory = gpu.freeMemory, gpu.totalMemory\13\n\9else\13\n\9\9gpuFreeMemory, gpuTotalMemory = freeMemory, totalMemory\13\n\9end\13\nend\13\n\13\n--===== global vars =====--\13\nlocal global = {\13\n\9--=== vars ===--\13\n\9isRunning = true,\13\n\9isDev = conf.debug.isDev,\13\n\9\13\n\9conf = conf,\13\n\9controls = {c = {}, k = {}, m = {}},\13\n\9\13\n\9currentState = \"\",\13\n\9dt = 0, --deltaTime\13\n\9lastUptime = 0,\13\n\9fps = -1,\13\n\9currentFrame = 0,\13\n\9\13\n\9backgroundColor = 0x00409f,\13\n\9\13\n\9resX = 0,\13\n\9resY = 0,\13\n\9currentVBuffer,\13\n\9screenBufferID = 0,\13\n\9\13\n\9debugDisplayPosY = 1,\13\n\9\13\n\9--=== content ===--\13\n\9state = {}, \13\n\9texture = {}, --textures.\13\n\9texturePack = nil, --texture back informations.\13\n\9animation = {},\13\n\9parent = {\13\n\9\9name = {}, \13\n\9\9id = {}, \13\n\9\9info = {amout = 0},\13\n\9},\13\n\9gameObject = { --gameObject parents.\13\n\9\9name = {}, \13\n\9\9id = {}, \13\n\9\9info = {amout = 0},\13\n\9},\13\n\9\13\n\9--=== core ===--\13\n\9orgPrint = print,\13\n\9\13\n\9core = {}, --All core parents.\13\n\9gameObjects = {}, --actual generated/calculated/rendered gameObjects.\13\n\9renderAreas = {},\13\n\9alreadyLoaded = {},\13\n\9loadedMods = {},\13\n\9\13\n\9--=== debug ===--\13\n\9debug = {},\13\n\9debugString = \"\",\13\n}\13\n\13\n--===== global functions =====--\13\nfunction nge_getGlobal()\13\n\9return global\13\nend\13\n\13\nfunction global.print(...)\13\n\9local t = {...}\13\n\9local s = \"\"\13\n\9local lastIndex = 1\13\n\9\13\n\9for i, c in pairs(t) do\9\9\13\n\9\9if lastIndex +1 < i then\13\n\9\9\9for count = lastIndex +1, i -1 do\13\n\9\9\9\9s = s .. \"nil \"\13\n\9\9\9end\13\n\9\9end\13\n\9\9s = s .. tostring(c) .. \" \"\13\n\9\9lastIndex = i\13\n\9end\13\n\9\13\n\9global.tbConsole:add(s)\13\n\9global.ocl.add(s)\13\n\9\13\n\9if global.conf.showConsole and global.conf.debug.isDev and global.conf.directConsoleDraw and global.conf.useDoubleBuffering then\13\n\9\9global.ocui.oclrl.gpu = global.realGPU\13\n\9\9global.tbConsole:draw()\13\n\9\9global.ocui.oclrl.gpu = global.gpu\13\n\9end\9\13\nend\13\n\13\nfunction cprint(...)\13\n\9global.print(\"[CPRINT] \", ...)\13\nend\13\n\13\nfunction global.log(...)\13\n\9global.print(\"[INFO] \", ...)\13\nend\13\n\13\nfunction global.warn(...)\13\n\9global.print(\"[WARN] \", ...)\13\nend\13\n\13\nfunction global.error(...)\13\n\9global.print(\"[ERROR] \", ...)\13\nend\13\n\13\nfunction global.fatal(...)\13\n\9global.print(\"[FATAL] \", ...)\13\n\9global.isRunning = false\13\n\9global.orgPrint(..., debug.traceback())\13\nend\13\n\13\nfunction global.debug.log(...)\13\n\9if global.isDev then\13\n\9\9global.print(\"[DEBUG] \", ...)\13\n\9end\13\nend\13\n\13\nfunction global.slog(...)\13\n\9local t = {...}\13\n\9global.print(\"[SINFO]: Start: \", ...)\13\n\9for i, s in ipairs(...) do\13\n\9\9local ss = global.serialization.serialize(t[i]) .. \";\"\13\n\9\9global.print(ss)\13\n\9end\13\n\9global.print(\"[SINFO]: End.\")\13\nend\13\n\13\nfunction global.debug.renderDebugInformations()\13\n\9if global.conf.showDebug then\13\n\9\9global.gpu.setForeground(0xaaaaaa)\13\n\9\9global.gpu.setBackground(0x333333)\13\n\9\9global.gpu.set(1, global.debugDisplayPosY, \13\n\9\9\9\"NosGa Engine: \" .. global.version .. \13\n\9\9\9\" | \" .. (global.gameName or \"Game\") .. \": \" .. (global.gameVersion or \"?\") ..\13\n\9\9\9\" | RAM: \" .. tostring(math.floor(100 - (freeMemory() / totalMemory() * 100) +.5)) .. \"%\" ..\13\n\9\9\9\" | VRAM: \" .. tostring(math.floor(100 - (gpuFreeMemory() / gpuTotalMemory() * 100) +.5)) .. \"%\" ..\13\n\9\9\9\" | FPS: \" .. tostring(math.floor((global.fps) +.5) .. \13\n\9\9\9\" | Frame: \" .. tostring(global.currentFrame)\13\n\9\9) .. global.debugString .. string.rep(\" \", global.resX))\13\n\9\9\13\n\9\9global.debugString = \"\"\13\n\9end\13\nend\13\n\13\nfunction global.setConsoleSize(size) --obsolete\13\n\9size = size or global.conf.consoleSizeY\13\n\9global.tbConsole.sizeX = global.resX\13\n\9global.tbConsole.sizeY = global.resY - (global.resY - size)\13\n\9global.tbConsole.posY = global.resY - size\13\nend\13\n\13\nfunction global.run(func, ...)\13\n\9local suc, err\13\n\9if func ~= nil then\13\n\9\9if conf.debug.isDev then\13\n\9\9\9suc, err = xpcall(func, debug.traceback, ...)\13\n\9\9else\13\n\9\9\9suc, err = pcall(func, ...)\13\n\9\9end\13\n\9\9if suc == false then\13\n\9\9\9global.error(\"[GE]: Failerd to run \" .. tostring(func) .. \"\\n\", err, debug.traceback())\13\n\9\9\9return suc, tostring(err) .. debug.traceback()\13\n\9\9end\13\n\9end\13\n\9return suc, err\13\nend\13\n\13\nfunction global.load(args)\13\n\9args.global = global\13\n\9return loadfile(\"data/core/dataLoading.lua\")(args)\13\nend\13\n\13\nfunction global.loadData(target, dir, func, logFuncs, overwrite, subDirs, structured, loadFunc, initFile)\13\n\9local id = 1\13\n\9if target.info ~= nil and target.info.amout ~= nil then\13\n\9\9id = target.info.amout +1\13\n\9end\13\n\9local path = global.shell.getWorkingDirectory() .. \"/\" .. dir .. \"/\"\13\n\9logFuncs = logFuncs or {}\13\n\9local print = logFuncs.log or global.log\13\n\9local warn = logFuncs.warn or global.warn\13\n\9local error = logFuncs.error or global.error\13\n\9\13\n\9subDirs = global.ut.parseArgs(subDirs, true)\13\n\9\13\n\9for file in global.fs.list(path) do\13\n\9\9local p, name, ending = global.ut.seperatePath(file)\13\n\9\9\13\n\9\9if name ~= \"gitignore\" and name ~= \"gitkeep\" then\13\n\9\9\9if string.sub(file, #file) == \"/\" and subDirs then\13\n\9\9\9\9if structured then\13\n\9\9\9\9\9if target[string.sub(p, 0, #p -1)] == nil or target[string.sub(p, 0, #p -1)].structured == true or overwrite and not structured then\13\n\9\9\9\9\9\9target[string.sub(p, 0, #p -1)] = {structured = true}\13\n\9\9\9\9\9\9global.loadData(target[string.sub(p, 0, #p -1)], dir .. \"/\" .. p, func, logFuncs, overwrite, subDirs, structured)\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9error(\"[DLF]: Target already existing!: \" .. p .. \" :\" .. tostring(target))\13\n\9\9\9\9\9end\13\n\9\9\9\9else\13\n\9\9\9\9\9global.loadData(target, dir .. \"/\" .. p, func, logFuncs, overwrite, subDirs, structured)\13\n\9\9\9\9end\13\n\9\9\9elseif target[name] == nil or overwrite then\13\n\9\9\9\9local debugString = \"\"\13\n\9\9\9\9if target[name] == nil then\13\n\9\9\9\9\9debugString = \"[DLF]: Loading file: \" .. dir .. \"/\" .. file .. \": \"\13\n\9\9\9\9else\13\n\9\9\9\9\9debugString = \"[DLF]: Reloading file: \" .. dir .. \"/\" .. file .. \": \"\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9local suc, err \13\n\9\9\9\9if loadFunc ~= nil then\13\n\9\9\9\9\9suc, err = loadFunc(path .. file, {transparencyColor = global.conf.transparencyColor, transparencyFunction = global.makeImageTransparent})\13\n\9\9\9\9elseif ending == \".pic\" then\13\n\9\9\9\9\9suc, err = global.image.load(path .. file)\13\n\9\9\9\9\9if suc ~= false then\13\n\9\9\9\9\9\9suc.format = \"pic\"\13\n\9\9\9\9\9\9suc.resX, suc.resY = suc[1], suc[2]\13\n\9\9\9\9\9\9if global.conf.transparencyColor ~= false then\13\n\9\9\9\9\9\9\9global.makeImageTransparent(suc, global.conf.transparencyColor)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9else\13\n\9\9\9\9\9suc, err = loadfile(path .. file)\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9if global.isDev then\13\n\9\9\9\9\9if suc == nil then\13\n\9\9\9\9\9\9print(error, print)\13\n\9\9\9\9\9\9error(\"[DLF] Failed to load file: \" .. dir .. \"/\" .. file .. \": \" .. tostring(err))\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9print(debugString .. tostring(suc))\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9if type(suc) == \"function\" then\13\n\9\9\9\9\9target[name or string.sub(p, 0, #p -1)] = suc(global)\13\n\9\9\9\9elseif type(suc) == \"table\" then\13\n\9\9\9\9\9target[name or string.sub(p, 0, #p -1)] = suc\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9local obj = target[name or string.sub(p, 0, #p -1)]\13\n\9\9\9\9if type(obj) == \"table\" and initFile == true then\13\n\9\9\9\9\9global.run(obj.init, obj)\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9if func ~= nil then\13\n\9\9\9\9\9func(name, id)\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9id = id +1\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9return id\13\nend\13\n\13\nreturn global",["./data/core/GameObject.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\n\13\nlocal GameObject = {}\13\nGameObject.__index = GameObject\13\n\13\nfunction GameObject.init()\13\n\9\13\nend\13\n\13\nlocal pa = global.ut.parseArgs\13\n\13\nlocal function addAreaEntry(a, e)\13\n\9local toInsert = {}\13\n\9toInsert.posX = pa(e.x, e.posX, 0)\13\n\9toInsert.posY = pa(e.y, e.posY, 0)\13\n\9toInsert.sizeX = pa(e.sx, e.sizeX, 0)\13\n\9toInsert.sizeY = pa(e.sy, e.sizeY, 0)\13\n\9toInsert.solid = pa(e.solid, false)\13\n\9table.insert(a, toInsert)\13\nend\13\n\13\nfunction GameObject.new(args)\13\n\9args = args or {}\13\n\9local this = setmetatable({}, GameObject)\13\n\13\n\9this.ngeAttributes = {\13\n\9\9sizeX = pa(args.sx, args.sizeX, 0),\13\n\9\9sizeY = pa(args.sy, args.sizeY, 0),\13\n\9\9layer = pa(args.layer, global.conf.renderLayerAmount),\13\n\9\9name = pa(args.name, \"\"),\13\n\9\9drawSize = pa(args.ds, args.drawSize, global.conf.debug.drawGameObjectBorders),\13\n\9\9isParent = args.isParent,\13\n\9\9updateAlways = pa(args.updateAlways, false),\13\n\9\9isLoaded = false,\13\n\13\n\9\9updateOCGFGameObject = pa(args.calcInternalGameObject, args.internalGameObject, args.updateInternalGameObject, not args.deco --[[is true if deco is nil]], false), --if set to true this gameobject will not calulate own physics.\13\n\9\9updatePhysics = pa(args.calcPhysics, args.physics, args.updatePhysics, not args.deco --[[is true if deco is nil]], false), --if set to true this gameobject will not the own internal gameobject. thi smean sthat triggers an co will not work.\13\n\13\n\9\9ignoreOCGFGameObject = pa(args.ignoreGameObject, args.deco, false), --if set to true other objects will not interact with this. so triggers and vco will not get trigered.\13\n\9\9\13\n\9\9--=== Auto generated ===--\13\n\9\9id, \13\n\9\9lastFramePosX = 0,\13\n\9\9lastFramePosY = 0,\13\n\9\9responsibleRenderAreas = {},\13\n\9\9hasMoved = false,\13\n\9\9isVisibleIn = {},\13\n\9\9lastCalculatedFrame = 0,\13\n\9\9clearAreas = {},\13\n\9\9copyAreas = {},\13\n\9\9usesAnimation = pa(args.ua, args.animation, args.usesAnimation, args.useAnimation),\13\n\9\9clearedAlready,\13\n\9\9alive = true,\13\n\9}\13\n\9\13\n\9args.gameObject = global.ut.parseArgs(args.components, args.gameObject) --ToDo: Completly remove args.gameObject from the code.\13\n\9\13\n\9this.gameObject = global.ocgf.GameObject.new(global.ocgf, {\13\n\9\9dc = global.conf.debug.drawCollider,\13\n\9\9dt = global.conf.debug.drawTrigger,\13\n\9\9logFunc = global.log,\13\n\9\9posX = pa(args.x, args.posX),\13\n\9\9posY = pa(args.y, args.posY),\13\n\9\9parent = this,\13\n\9})\13\n\9this.internalGameObject = this.gameObject --just an more intuitive alias for the dev to work with. \13\n\9\13\n\9for _, c in pairs(args.gameObject or {}) do\13\n\9\9if c[1] == \"BoxCollider\" then\13\n\9\9\9this.gameObject:addBoxCollider(c)\13\n\9\9elseif c[1] == \"BoxTrigger\" then\13\n\9\9\9this.gameObject:addBoxTrigger(c)\13\n\9\9elseif c[1] == \"RigidBody\" then\13\n\9\9\9this.gameObject:addRigidBody(c)\13\n\9\9elseif c[1] == \"Sprite\" or c[1] == \"Animation\" then\13\n\9\9\9if type(c.texture) == \"string\" then\13\n\9\9\9\9if c[1] == \"Sprite\" then\13\n\9\9\9\9\9c.texture = global.texture[c.texture]\13\n\9\9\9\9elseif c[1] == \"Animation\" then\13\n\9\9\9\9\9c.texture = global.animation[c.texture]\13\n\9\9\9\9end\13\n\9\9\9end\13\n\13\n\9\9\9assert(c.texture, \"Cant add GameObject. No valid texture/animation given.\")\13\n\9\9\9\13\n\9\9\9if c.texture.format == \"OCGLA\" or c.texture.format == \"pan\" then\13\n\9\9\9\9this.ngeAttributes.usesAnimation = true\13\n\9\9\9elseif c.texture.format == \"pic\" then\13\n\9\9\9\9\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9this.gameObject:addSprite(c)\13\n\9\9elseif c[1] == \"CopyArea\" or c[1] == \"ClearArea\" then\13\n\9\9\9addAreaEntry(this.ngeAttributes.clearAreas, c)\13\n\9\9\9if global.conf.forceSmartMove or global.conf.useSmartMove and global.conf.useDoubleBuffering then\13\n\9\9\9\9addAreaEntry(this.ngeAttributes.copyAreas, c)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9if args.noSizeArea ~= true and this.ngeAttributes.sizeX > 0 and this.ngeAttributes.sizeY > 0 then\13\n\9\9addAreaEntry(this.ngeAttributes.clearAreas, {posX = 0, posY = 0, sizeX = this.ngeAttributes.sizeX, sizeY = this.ngeAttributes.sizeY, solid = args.solid})\13\n\9\9addAreaEntry(this.ngeAttributes.copyAreas, {posX = 0, posY = 0, sizeX = this.ngeAttributes.sizeX, sizeY = this.ngeAttributes.sizeY, solid = args.solid})\13\n\9end\13\n\9\13\n\9--===== default functions =====--\13\n\9this.move = function(this, x, y)\13\n\9\9--x = math.floor(x)\13\n\9\9--y = math.floor(y)\13\n\9\9this.gameObject:move(x, -y)\13\n\9\9--this.ngeAttributes.hasMoved = true\13\n\9end\13\n\9this.moveTo = function(this, x, y)\13\n\9\9--x = math.floor(x)\13\n\9\9--y = math.floor(y)\13\n\9\9this.gameObject:moveTo(x, y)\13\n\9\9--this.ngeAttributes.hasMoved = true\13\n\9end\13\n\9this.addForce = function(this, x, y, maxSpeed)\13\n\9\9this.gameObject:addForce(x, y, maxSpeed)\13\n\9end\13\n\9this.addSpeed = function(this, x, y, maxSpeed) --ToDo / WIP: buggy. Outsource to ocgf.\13\n\9\9local x2, y2 = this:getSpeed()\13\n\9\9maxSpeed = maxSpeed or math.huge\13\n\9\9if x > 0 then\13\n\9\9\9x = math.min(x + x2, maxSpeed)\13\n\9\9else\13\n\9\9\9x = math.max(x + x2, -maxSpeed)\13\n\9\9end\13\n\9\9if y > 0 then\13\n\9\9\9y = math.min(y + y2, maxSpeed)\13\n\9\9else\13\n\9\9\9y = math.max(y + y2, -maxSpeed)\13\n\9\9end\13\n\9\9this.gameObject:setSpeed(x, -y)\13\n\9end\13\n\9this.setSpeed = function(this, x, y)\13\n\9\9this.gameObject:setSpeed(x, -y)\13\n\9end\13\n\9this.getPos = function(this)\13\n\9\9return math.floor(this.gameObject.posX +.5), math.floor(this.gameObject.posY +.5)\13\n\9end\13\n\9this.getSpeed = function(this)\13\n\9\9return this.gameObject:getSpeed()\13\n\9end\13\n\9this.getScreenPos = function(this)--ToDo: untested.\13\n\9\9return this:getRA():getGOPos(this)\13\n\9end\13\n\9this.getRealLastPos = function(this)\13\n\9\9return math.floor(this.gameObject.lastPosX +.5), math.floor(this.gameObject.lastPosY +.5)\13\n\9end\13\n\9this.getLastPos = function(this)\13\n\9\9return math.floor(this.ngeAttributes.lastFramePosX +.5), math.floor(this.ngeAttributes.lastFramePosY +.5)\13\n\9end\13\n\9this.getSize = function(this) --ToDo: generate real size dependent on the ClearAreas.\13\n\9\9return this.ngeAttributes.sizeX, this.ngeAttributes.sizeY\13\n\9end\13\n\9this.getRA = function(this)\13\n\9\9for ra in pairs(this.ngeAttributes.responsibleRenderAreas) do\13\n\9\9\9if ra.parent == nil then\13\n\9\9\9\9return ra\13\n\9\9\9else\13\n\9\9\9\9return ra.parent\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9this.getName = function(this)\13\n\9\9return this.ngeAttributes.name\13\n\9end\13\n\9this.getOffset = function(this, ra)\13\n\9\9return math.floor(ra.posX + ra.cameraPosX +.5), math.floor(ra.posY + ra.cameraPosY +.5)\13\n\9end\13\n\9this.destroy = function(this)\13\n\9\9for ra in pairs(this.ngeAttributes.responsibleRenderAreas) do\13\n\9\9\9this.ngeAttributes.alive = false\13\n\9\9\9ra:remGO(this)\13\n\9\9\9return\13\n\9\9end\13\n\9end\13\n\9this.attach = function(this, gameObject)\13\n\9\9this.gameObject:attach(gameObject.gameObject)\13\n\9end\13\n\9this.detach = function(this)\13\n\9\9this.gameObject:detach()\13\n\9end\13\n\9this.rerender = function(this)\13\n\9\9for ra in pairs(this.ngeAttributes.responsibleRenderAreas) do\13\n\9\9\9if ra.gameObjectAttributes[this] ~= nil then\13\n\9\9\9\9ra.gameObjectAttributes[this].mustBeRendered = true\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9this.ngeAttributes.hasMoved = true\13\n\9end\13\n\9\13\n\9--===== engine functions =====--\13\n\9this.ngeStart = function(this) --parent func \13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pStart, this)\13\n\9\9else\13\n\9\9\9global.run(this.start, this)\13\n\9\9end\13\n\9end\13\n\9this.ngeUpdate = function(this, ocgfGameObjects, dt, ra) --parent func\13\n\9\9local insert = table.insert\13\n\9\9local ngeAttributes = this.ngeAttributes\13\n\9\9\13\n\9\9if this.test then\13\n\9\9\9--global.log(#ocgfGameObjects)\13\n\9\9end\13\n\9\9\13\n\9\9ngeAttributes.clearedAlready = nil\13\n\13\n\9\9if ngeAttributes.updatePhysics then\13\n\9\9\9this.gameObject:updatePhx(ocgfGameObjects, dt)\13\n\9\9end\13\n\9\9if ngeAttributes.updateOCGFGameObject then\13\n\9\9\9this.gameObject:update(ocgfGameObjects)\13\n\9\9end\13\n\9\9\13\n\9\9if ngeAttributes.isParent then\13\n\9\9\9global.run(this.pUpdate, this, dt, ra, ocgfGameObjects, ocgfGameObjects)\13\n\9\9else\13\n\9\9\9global.run(this.update, this, dt, ra, ocgfGameObjects, ocgfGameObjects)\13\n\9\9end\13\n\9\9\13\n\9\9local x, y = this:getPos()\13\n\9\9local lx, ly = this:getLastPos()\13\n\9\9\13\n\9\9if x ~= lx or y ~= ly or ngeAttributes.usesAnimation == true then\13\n\9\9\9ngeAttributes.hasMoved = true\13\n\9\9\9if global.conf.forceSmartMove or global.conf.useSmartMove and global.conf.useDoubleBuffering then\13\n\9\9\9\9for ra in pairs(ngeAttributes.responsibleRenderAreas) do\13\n\9\9\9\9\9local offsetX, offsetY = this:getOffset(ra)\13\n\9\9\9\9\9for i, ca in pairs(ngeAttributes.copyAreas) do\13\n\9\9\9\9\9\9insert(ra.copyInstructions, {ca.posX +lx +offsetX, ca.posY +ly +offsetY, ca.sizeX, ca.sizeY, -(lx - x), -(ly - y)})\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9ngeAttributes.isUpdated = true\13\n\9end\13\n\9this.ngeActivate = function(this) --parent func\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pActivate, this)\13\n\9\9else\13\n\9\9\9global.run(this.activate, this)\13\n\9\9end\13\n\9end\13\n\9this.ngeDraw = function(this, renderArea) --parent func\13\n\9\9local realArea = renderArea.realArea or renderArea\13\n\9\9local offsetX, offsetY = this:getOffset(realArea)\13\n\9\9\13\n\9\9for _, s in pairs(this.gameObject:getSprites()) do\13\n\9\9\9s.background = global.backgroundColor\13\n\9\9end\13\n\13\n\9\9--print(this:getName(), this.ngeAttributes.hasMoved)\13\n\13\n\9\9if \13\n\9\9\9#realArea.gameObjectAttributes[this].overlappingAreas == 0 and realArea.gameObjectAttributes[this].mustBeRendered or \13\n\9\9\9not realArea.gameObjectAttributes[this].hasBeenRenderedOnce or\13\n\9\9\9this.ngeAttributes.hasMoved\13\n\9\9then\13\n\9\9\9realArea.gameObjectAttributes[this].overlappingAreas = {{-math.huge, math.huge, -math.huge, math.huge}}\13\n\9\9end\13\n\13\n\9\9if renderArea.realArea ~= nil and this.ngeAttributes.hasMoved ~= true then --draw areas needed cause camera movement.\13\n\9\9\9for i, ra in pairs(renderArea) do\13\n\9\9\9\9if i ~= \"realArea\" then\13\n\9\9\9\9\9this.gameObject:draw(offsetX, offsetY, {ra.posX, ra.posX + ra.sizeX -1, ra.posY, ra.posY + ra.sizeY -1}, global.dt, global.backgroundColor)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9for _, overlappingArea in pairs(realArea.gameObjectAttributes[this].overlappingAreas) do\13\n\9\9\9do\13\n\9\9\9\9local rx, _, ry, _ = realArea:getRealFOV()\13\n\9\9\9\9local x, _, y, _ = realArea:getFOV()\13\n\13\n\9\9\9\9this.gameObject:draw(offsetX, offsetY, {\13\n\9\9\9\9\9math.max(realArea.posX, overlappingArea[1] + rx - x), \13\n\9\9\9\9\9math.min(realArea.posX + realArea.sizeX -1, overlappingArea[2] + rx - x), \13\n\9\9\9\9\9math.max(realArea.posY, overlappingArea[3] + ry - y), \13\n\9\9\9\9\9math.min(realArea.posY + realArea.sizeY -1, overlappingArea[4] + ry - y)}, \13\n\9\9\9\9global.dt, global.backgroundColor)\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9realArea.gameObjectAttributes[this].overlappingAreas = {}\13\n\13\n\9\9\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pDraw, this, realArea, offsetX, offsetY)\13\n\9\9else\13\n\9\9\9global.run(this.draw, this, realArea, offsetX, offsetY)\13\n\9\9end\13\n\9\9\13\n\9\9if realArea.gameObjectAttributes[this] == nil then --WIP: ToDo: Deeper problem?\13\n\9\9\9realArea.gameObjectAttributes[this] = {}\13\n\9\9end\13\n\9\9realArea.gameObjectAttributes[this].mustBeRendered = false\13\n\9\9realArea.gameObjectAttributes[this].wasVisible = true\13\n\9\9\13\n\9\9if this.ngeAttributes.drawSize then\13\n\9\9\9local posX, posY = this:getPos()\13\n\9\9\9\13\n\9\9\9global.oclrl:draw(posX + offsetX, posY + offsetY, global.oclrl.generateTexture({\13\n\9\9\9\9{\"b\", 0xFF69B4},\13\n\9\9\9\9{0, 0, this.ngeAttributes.sizeX, 1, \" \"},\13\n\9\9\9\9{0, this.ngeAttributes.sizeY -1, this.ngeAttributes.sizeX, 1, \" \"},\13\n\9\9\9\9{0, 0, 1, this.ngeAttributes.sizeY, \" \"},\13\n\9\9\9\9{this.ngeAttributes.sizeX -1, 0, 1, this.ngeAttributes.sizeY, \" \"},\13\n\9\9\9}), true, {realArea:getRealFOV()})\13\n\9\9end\13\n\9\9realArea.gameObjectAttributes[this].hasBeenRenderedOnce = true\13\n\9end\13\n\9this.ngeClear = function(this, renderArea) --parent func\13\n\9\9local offsetX, offsetY = renderArea.posX + renderArea.cameraPosX, renderArea.posY + renderArea.cameraPosY\13\n\9\9local lastPosX, lastPosY = this:getLastPos()\13\n\9\9local posX, posY = this:getPos()\13\n\9\9\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pClear, this, renderArea)\13\n\9\9else\13\n\9\9\9global.run(this.clear, this, renderArea)\13\n\9\9end\13\n\9\9\13\n\9\9global.gpu.setBackground(global.backgroundColor)\13\n\9\9\13\n\9\9for i, ca in pairs(this.ngeAttributes.clearAreas) do\13\n\9\9\9global.oclrl:draw(0, 0, global.oclrl.generateTexture(lastPosX + offsetX + ca.posX, lastPosY + offsetY + ca.posY, ca.sizeX, ca.sizeY, \" \"), nil, renderArea.sizeArray)\13\n\9\9end\13\n\9\9for i, ca in pairs(this.ngeAttributes.copyAreas) do\13\n\9\9\9if ca.solid ~= true then\13\n\9\9\9\9global.oclrl:draw(0, 0, global.oclrl.generateTexture(posX + offsetX + ca.posX, posY + offsetY + ca.posY, ca.sizeX, ca.sizeY, \" \"), nil, renderArea.sizeArray)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9this.ngeSUpdate = function(this, gameObjects, dt, ra) --parent func\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pSUpdate, this, dt, ra)\13\n\9\9else\13\n\9\9\9global.run(this.sUpdate, this, dt, ra)\13\n\9\9end\13\n\9end\13\n\9this.ngeSetLastPos = function(this)\13\n\9\9this.ngeAttributes.lastFramePosX = math.floor(this.gameObject.posX +.5)\13\n\9\9this.ngeAttributes.lastFramePosY = math.floor(this.gameObject.posY +.5)\13\n\9\9\13\n\9\9this.ngeAttributes.hasMoved = false\13\n\9end\13\n\9this.ngeStop = function(this)\13\n\9\9this.gameObject:stop()\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pStop, this)\13\n\9\9else\13\n\9\9\9global.run(this.stop, this)\13\n\9\9end\13\n\9\9this.gameObject:stop()\13\n\9end\13\n\9this.ngeLoad = function(this, renderArea) --parent func\13\n\9\9this.ngeAttributes.isLoaded = true\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pSpawn, this)\13\n\9\9else\13\n\9\9\9global.run(this.spawn, this)\13\n\9\9end\13\n\9end\13\n\9this.ngeUnload = function(this, renderArea) --parent func\9\9\13\n\9\9this.ngeAttributes.isLoaded = false\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pDespawn, this)\13\n\9\9else\13\n\9\9\9global.run(this.despawn, this)\13\n\9\9end\13\n\9end\13\n\9\13\n\9return this\13\nend\13\n\13\nreturn GameObject",["./data/core/RenderArea_experimental.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\n\13\n--====== local functions =====--\13\nlocal function print(...)\13\n\9if global.conf.debug.raDebug then\13\n\9\9global.debug.log(...)\13\n\9end\13\nend\13\n\13\n--===== class =====--\13\nlocal RenderArea = {}\13\nRenderArea.__index = RenderArea\13\n\13\nfunction RenderArea.init()\13\n\13\nend\13\n\13\nfunction RenderArea.new(args)\13\n\9args = args or {}\13\n\9local this = setmetatable({}, RenderArea)\13\n\9\13\n\9local pa = global.ut.parseArgs\13\n\9this.posX = pa(args.x, args.posX, 1)\13\n\9this.posY = pa(args.y, args.posY, 1)\13\n\9this.sizeX = pa(args.sx, args.sizeX, 0)\13\n\9this.sizeY = pa(args.sy, args.sizeY, 0)\13\n\9this.layer = pa(args.layer, global.conf.renderLayerAmount)\13\n\9this.silent = pa(args.silent, false) --if true the RA is not updating gameObjects.\13\n\9this.name = tostring(args.name)\13\n\9this.cameraPosX = pa(args.cx, args.cameraPosX, 0)\13\n\9this.cameraPosY = pa(args.cy, args.cameraPosY, 0)\13\n\9this.lastCameraPosX = this.cameraPosX\13\n\9this.lastCameraPosY = this.cameraPosY\13\n\9this.id = args.id\13\n\9this.layerBlacklist = pa(args.lbl, args.layerBlacklist, {})\13\n\9this.drawBorders = pa(args.drawBorders, false)\13\n\9this.borderColor = pa(args.borderColor, 0xFF69B4)\13\n\9this.narrowUpdateExpansion = pa(args.nue, args.narrowUpdateExpansion, global.conf.narrowUpdateExpansion)\13\n\9this.debugLog = pa(args.debugLog, true)\13\n\9\13\n\9this.parent = args.parent\13\n\9this.gameObjects = {}\13\n\9this.gameObjectAttributes = {}\13\n\9this.toRender = {}\13\n\9this.toClear = {}\13\n\9this.toUpdate = {}\13\n\9--this.cameraMoveInstructions = {copy = {}, clear = {}, raw = {x = 0, y = 0}}\13\n\9this.cameraMoveInstructions = {copy = {}, clear = {}, raw = {x = 0, y = 0}}\13\n\9this.copyInstructions = {}\13\n\9this.firstRender = true\13\n\9this.backBufferID = global.screenBufferID\13\n\9this.useOwnBackBuffer = pa(args.ownBuffer, args.ownBackBuffer, args.useOwnBuffer, args.useOwnBackBuffer, true)\13\n\9\13\n\9this.childs = {}\13\n\9\13\n\9this.isVisible = pa(args.visible, args.isVisible, true)\13\n\9\13\n\9if this.useOwnBackBuffer then\13\n\9\9this.backBufferID = global.gpu.allocateBuffer(this.sizeX, this.sizeY)\13\n\9\9\13\n\9\9global.gpu.setActiveBuffer(this.backBufferID)\13\n\9\9global.gpu.setBackground(global.backgroundColor)\13\n\9\9global.gpu.fill(1, 1, this.sizeX, this.sizeY, \" \")\13\n\9\9if global.conf.useDoubleBuffering then \13\n\9\9\9global.gpu.drawChanges() \13\n\9\9end\13\n\9\9global.gpu.setActiveBuffer(global.screenBufferID)\13\n\9end\13\n\9\13\n\9if this.parent ~= nil then\13\n\9\9if this.parent.parent ~= nil then\13\n\9\9\9this.parent = this.parent.parent\13\n\9\9end\13\n\9\9\13\n\9\9this.gameObjects = this.parent.gameObjects\13\n\9\9this.parent.childs[this] = true\13\n\9\9for i, c in pairs(this.parent.gameObjectAttributes) do\13\n\9\9\9this.gameObjectAttributes[i] = c\13\n\9\9end\13\n\9\9\13\n\9\9this.narrowUpdateExpansion = this.parent.narrowUpdateExpansion\13\n\9end\13\n\9\13\n\9for i = 0, global.conf.renderLayerAmount do \13\n\9\9this.toRender[i] = {}\13\n\9\9this.toClear[i] = {}\13\n\9end\13\n\9\13\n\9--===== default functions =====--\13\n\9this.addGO = function(this, go, args)\13\n\9\9local path, goClass = global.ut.seperatePath(go)\13\n\9\9--local gameObject = global.gameObject\13\n\9\9\13\n\9\9for s in string.gmatch(tostring(path), \"[^/]+\") do\13\n\9\9\9global.gameObject = global.gameObject[s]\13\n\9\9end\13\n\9\9\13\n\9\9if global.gameObject[goClass] == nil then\13\n\9\9\9print(\"[RA/\" .. tostring(this.name) .. \"]: Failed to add gameObject: \\\"\" .. go .. \"\\\" (not found).\")\13\n\9\9else\13\n\9\9\9if this.parent ~= nil then\13\n\9\9\9\9return this.parent:addGO(go, args)\13\n\9\9\9else\13\n\9\9\9\9local id = #this.gameObjects +1\13\n\9\9\9\9local gameObject = nil\13\n\9\9\9\9\13\n\9\9\9\9print(\"[RA/\" .. tostring(this.name) .. \"]: Adding gameObject: \\\"\" .. go .. \"\\\" (#\" .. tostring(id) .. \").\")\13\n\9\9\9\9\13\n\9\9\9\9gameObject = global.gameObject[goClass].new(args)\13\n\9\9\9\9\13\n\9\9\9\9this.gameObjects[gameObject] = true\13\n\9\9\9\9\13\n\9\9\9\9gameObject.ngeAttributes.responsibleRenderAreas[this] = true\13\n\9\9\9\9this.gameObjectAttributes[gameObject] = {\13\n\9\9\9\9\9mustBeRendered = true,\13\n\9\9\9\9\9lastCalculatedFrame = 0,\13\n\9\9\9\9\9wasVisible,\13\n\9\9\9\9\9nonDrawAreas = {},\13\n\9\9\9\9\9drawAreas = {},\13\n\9\9\9\9}\13\n\9\9\9\9\13\n\9\9\9\9for c in pairs(this.childs) do\13\n\9\9\9\9\9gameObject.ngeAttributes.responsibleRenderAreas[c] = true\13\n\9\9\9\9\9c.gameObjectAttributes[gameObject] = {\13\n\9\9\9\9\9\9mustBeRendered = true,\13\n\9\9\9\9\9\9lastCalculatedFrame = 0,\13\n\9\9\9\9\9\9wasVisible,\13\n\9\9\9\9\9\9nonDrawAreas = {},\13\n\9\9\9\9\9\9drawAreas = {},\13\n\9\9\9\9\9}\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9--global.run(this.gameObjects[id].spawn)\13\n\9\9\9\9global.run(gameObject.ngeStart, gameObject)\13\n\9\9\9\9return gameObject\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9this.remGO = function(this, go, t)\13\n\9\9if go == nil then return false end\13\n\9\9\13\n\9\9if this.parent ~= nil then\13\n\9\9\9return this.parent:remGO(go, args)\13\n\9\9else\13\n\9\9\9print(\"[RA/\" .. tostring(this.name) .. \"]: Removing gameObject: \\\"\" .. go.ngeAttributes.name .. \"\\\" (#\" .. tostring(id) .. \").\")\13\n\9\9\9\13\n\9\9\9go:ngeClear(this)\13\n\9\9\9\13\n\9\9\9global.run(go.ngeStop, go)\13\n\9\9\9this.toRender[go.ngeAttributes.layer][go] = nil\9\9\9\13\n\9\9\9this.gameObjectAttributes[go] = nil\13\n\9\9\9\13\n\9\9\9global.core.re.checkOverlapping(this, go, go.ngeAttributes.layer)\13\n\9\9\9for c in pairs(this.childs) do\13\n\9\9\9\9c.gameObjectAttributes[go] = nil\13\n\9\9\9\9go:ngeClear(c)\13\n\9\9\9\9global.core.re.checkOverlapping(c, go, go.ngeAttributes.layer)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9this.gameObjects[go] = nil\13\n\9\9end\13\n\9end\13\n\9this.move = function(this, x, y)\13\n\9\9\13\n\9end\13\n\9this.moveTo = function(this, x, y)\13\n\9\9\13\n\9end\13\n\9this.moveCamera = function(this, x, y)\13\n\9\9local cmir = this.cameraMoveInstructions.raw\13\n\9\9this.cameraMoveInstructions.raw.x = cmir.x +x\13\n\9\9this.cameraMoveInstructions.raw.y = cmir.y -y\13\n\9end\13\n\9this.moveCameraTo = function(this, x, y)\13\n\9\9local cmir = this.cameraMoveInstructions.raw\13\n\9\9this.cameraMoveInstructions.raw.x = this.cameraPosX +x\13\n\9\9this.cameraMoveInstructions.raw.y = this.cameraPosY -y\13\n\9end\13\n\9\13\n\9this.rerenderAll = function(this)\13\n\9\9global.gpu.setBackground(global.backgroundColor)\13\n\9\9if this.useOwnBackBuffer then\13\n\9\9\9global.gpu.setActiveBuffer(this.backBufferID)\13\n\9\9\9global.gpu.fill(1, 1, this.sizeX, this.sizeY, \" \")\13\n\9\9else\13\n\9\9\9global.gpu.fill(this.posX, this.posY, this.sizeX, this.sizeY, \" \")\13\n\9\9end\13\n\9\9\13\n\9\9for i, a in pairs(this.gameObjectAttributes) do\13\n\9\9\9a.mustBeRendered = true\13\n\9\9end\13\n\9\9this.firstRender = true\13\n\9end\13\n\9this.getFOV = function(this) --ToDo: has to give prositive x and y values.\13\n\9\9local cmir = this.cameraMoveInstructions.raw\13\n\9\9return this.cameraPosX + cmir.x, this.sizeX + this.cameraPosX + cmir.x, this.cameraPosY + cmir.y, this.sizeY + this.cameraPosY + cmir.y\13\n\9end\13\n\9this.getFOVLegacy = function(this)\13\n\9\9return - this.cameraPosX, this.sizeX - this.cameraPosX, - this.cameraPosY, this.sizeY - this.cameraPosY\13\n\9end\13\n\9this.getLastFOV = function(this)\13\n\9\9return - this.lastCameraPosX, this.sizeX - this.lastCameraPosX, - this.lastCameraPosY, this.sizeY - this.lastCameraPosY\13\n\9end\13\n\9this.getRealFOV = function(this, bufferIntern)\13\n\9\9if bufferIntern and this.useOwnBackBuffer then\13\n\9\9\9return 1, this.sizeX, 1, this.sizeY\13\n\9\9else\13\n\9\9\9return this.posX, this.posX + this.sizeX, this.posY, this.posY + this.sizeY\13\n\9\9end\13\n\9end\13\n\9this.getPixelPos = function(this, x, y) --returns the renderArea pos from the screen pixel pos.\13\n\9\9return x - this.posX - this.cameraPosX, y - this.posY - this.cameraPosY\13\n\9end\13\n\9this.getGOPos = function(this, go) --returns the pos on the screen.\13\n\9\9return go.gameObject.posX + this.posX + this.cameraPosX, go.gameObject.posY + this.posY + this.cameraPosY\13\n\9end\13\n\9this.getPos = function(this)\13\n\9\9return this.posX, this.posY\13\n\9end\13\n\9this.getSize = function(this)\13\n\9\9return this.sizeX, this.sizeY\13\n\9end\13\n\9\13\n\9this.resetCMI = function(this)\13\n\9\9local cmi = this.cameraMoveInstructions\13\n\9\9local subPixelX = cmi.raw.x - math.floor(cmi.raw.x)\13\n\9\9local subPixelY = cmi.raw.y - math.floor(cmi.raw.y)\13\n\9\9\13\n\9\9this.cameraMoveInstructions = {copy = {}, clear = {}, raw = {x = subPixelX, y = subPixelY}}\13\n\9\9this.copyInstructions = {}\13\n\9end\13\n\9this.getBufferID = function(this)\13\n\9\9return this.backBufferID\13\n\9end\13\n\9this.getOffset = function(this)\13\n\9\9local x, _, y = this:getFOV()\13\n\9\9if not this.useOwnBackBuffer then\13\n\9\9\9local rx, _, ry = this:getRealFOV(true)\13\n\9\9\9x, y = x - rx +1, y - ry +1\13\n\9\9end\13\n\9\9\13\n\9\9return math.floor(x), math.floor(y)\13\n\9\9\13\n\9\9--[[\13\n\9\9if this.directDraw then\13\n\9\9\9return math.floor(this.posX + this.cameraPosX +.5), math.floor(this.posY + this.cameraPosY +.5)\13\n\9\9else\13\n\9\9\9return math.floor(this.cameraPosX +.5), math.floor(this.cameraPosY +.5)\13\n\9\9end\13\n\9\9]]\13\n\9end\13\n\9\13\n\9--===== engine functions =====--\13\n\9this.ngeStart = function(this) --parent func \13\n\9\9\13\n\9end\13\n\9this.ngeUpdate = function(this, RenderAreas, dt) --parent func\13\n\9\9\13\n\9end\13\n\9\13\n\9this.ngeAddToRenderQueue = function(this, go, area, draw, clear)\13\n\9\9if draw then\13\n\9\9\9if this.toRender[go:getLayer()][go] == nil then\13\n\9\9\9\9this.toRender[go:getLayer()][go] = {}\13\n\9\9\9end\13\n\9\9\9table.insert(this.toRender[go:getLayer()][go], area)\13\n\9\9end\13\n\9\9if clear then\13\n\9\9\9if this.toClear[go:getLayer()][go] == nil then\13\n\9\9\9\9this.toClear[go:getLayer()][go] = {}\13\n\9\9\9end\13\n\9\9\9table.insert(this.toClear[go:getLayer()][go], area)\13\n\9\9end\13\n\9end\13\n\9\13\n\9this.ngeCalculateNewRender = function(this) --parent func\13\n\9\9if not this.isVisible then\13\n\9\9\9return false, \"Not visible\"\13\n\9\9end\13\n\9\9\13\n\9\9local rx, _, ry = this:getRealFOV(true)\13\n\9\9local sx, sy = this:getSize()\13\n\9\9local screenArea = {posX = rx, posY = ry, sizeX = sx, sizeY = sy}\13\n\9\9local cmi = this.cameraMoveInstructions\13\n\9\9local cmir = {x = math.floor(cmi.raw.x), y = math.floor(cmi.raw.y)}\13\n\9\9local x, tx, y, ty = this:getFOV()\13\n\9\9local fov = {posX = x, posY = y, sizeX = sx, sizeY = sy}\13\n\9\9local toRender\13\n\9\9\13\n\9\9if this.firstRender then\13\n\9\9\9toRender = this.gameObjects\13\n\9\9else\13\n\9\9\9toRender = global.core.re.toRender\13\n\9\9end\13\n\9\9\13\n\9\9if this.useOwnBackBuffer then\13\n\9\9\9screenArea = {posX = 1, posY = 1, sizeX = sx, sizeY = sy}\13\n\9\9end\13\n\9\9\13\n\9\9--===== calculate cam move copy instructions =====--\13\n\9\9if cmir.x ~= 0 or cmir.y ~= 0 then\13\n\9\9\9local fx, fy, sx, sy, tx, ty = 0, 0, 0, 0, -cmir.x, -cmir.y\13\n\9\9\9local posX, _, posY = this:getRealFOV(true)\13\n\9\9\9local newClearArea1, newClearArea2 = {0, posY, 0, this.sizeY}, {posX, 0, this.sizeX, 0}\13\n\9\9\9\13\n\9\9\9if cmir.x >= 0 then\13\n\9\9\9\9fx = posX +cmir.x\13\n\9\9\9\9sx = this.sizeX -cmir.x\13\n\9\9\9\9newClearArea1[1] = posX + this.sizeX - cmir.x\13\n\9\9\9\9newClearArea1[3] = cmir.x\13\n\9\9\9else\13\n\9\9\9\9fx = posX\13\n\9\9\9\9sx = this.sizeX +cmir.x\13\n\9\9\9\9newClearArea1[1] = posX\13\n\9\9\9\9newClearArea1[3] = -cmir.x\13\n\9\9\9end\13\n\9\9\9if cmir.y >= 0 then\13\n\9\9\9\9fy = posY +cmir.y\13\n\9\9\9\9sy = this.sizeY -cmir.y\13\n\9\9\9\9newClearArea2[2] = posY + this.sizeY -cmir.y\13\n\9\9\9\9newClearArea2[4] = cmir.y\13\n\9\9\9else\13\n\9\9\9\9fy = posY\13\n\9\9\9\9sy = this.sizeY +cmir.y\13\n\9\9\9\9newClearArea2[2] = posY\13\n\9\9\9\9newClearArea2[4] = -cmir.y\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9cmi.copy = {fx, fy, sx, sy, tx, ty}\13\n\9\9\9\13\n\9\9\9if cmir.x ~= 0 then\13\n\9\9\9\9cmi.clear[1] = {newClearArea1[1], newClearArea1[2], newClearArea1[3], newClearArea1[4], \" \"}\13\n\9\9\9end\13\n\9\9\9if cmir.y ~= 0 then\13\n\9\9\9\9cmi.clear[2] = {newClearArea2[1], newClearArea2[2], newClearArea2[3], newClearArea2[4], \" \"}\13\n\9\9\9end\13\n\9\9end\13\n\9\9this.lastCameraPosX = this.cameraPosX\13\n\9\9this.lastCameraPosY = this.cameraPosY\13\n\9\9this.cameraPosX = this.cameraPosX + cmir.x\13\n\9\9this.cameraPosY = this.cameraPosY + cmir.y\13\n\9\9cmi.raw.x = cmi.raw.x - cmir.x\13\n\9\9cmi.raw.y = cmi.raw.y - cmir.y\13\n\9\9\13\n\9\9--[[\13\n\9\9this.cameraPosX, this.cameraPosY = this.cameraPosX + this.cameraMoveInstructions.raw.x, this.cameraPosY + this.cameraMoveInstructions.raw.y\13\n\9\9this.cameraMoveInstructions.raw.x, this.cameraMoveInstructions.raw.y = 0, 0\13\n\9\9]]\13\n\9\9--for go, _ in pairs(this.gameObjects) do\13\n\9\9\13\n\9\9--===== calculate cam move clear instructions =====--\13\n\9\9if cmi.clear[1] ~= nil or cmi.clear[2] ~= nil then\13\n\9\9\9for go, _ in pairs(this.gameObjects) do\13\n\9\9\9\9local x, _, y = this:getFOV()\13\n\9\9\9\9local rx, _, ry = this:getRealFOV(true)\13\n\9\9\9\9\13\n\9\9\9\9if toRender[go] ~= true and \13\n\9\9\9\9\9cmi.clear[1] ~= nil and \13\n\9\9\9\9\9go:ngeIsInsideRenderArea({posX = cmi.clear[1][1] + x - rx, posY = cmi.clear[1][2] + y - ry, sizeX = cmi.clear[1][3], sizeY = cmi.clear[1][4]}) or\13\n\9\9\9\9\9cmi.clear[2] ~= nil and \13\n\9\9\9\9\9go:ngeIsInsideRenderArea({posX = cmi.clear[2][1] + x - rx, posY = cmi.clear[2][2] + y - ry, sizeX = cmi.clear[2][3], sizeY = cmi.clear[2][4]})\13\n\9\9\9\9then\9\13\n\9\9\9\9\9--this.toRender[go:getLayer()][go] = {posX = cmi.clear[1][1], posY = cmi.clear[1][2], sizeX = cmi.clear[1][3], sizeY = cmi.clear[1][4]} --maybe usefull?\13\n\9\9\9\9\9\13\n\9\9\9\9\9this:ngeAddToRenderQueue(go, screenArea, true, false)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9\13\n\9\9\13\n\9\9local function checkOverlapping()\13\n\9\9\9\13\n\9\9end\13\n\9\9\13\n\9\9\13\n\9\9--===== calculate gameObject render areas =====--\13\n\9\9for go, _ in pairs(toRender) do\13\n\9\9\9if go:ngeIsInsideRenderArea(fov) then\13\n\9\9\9\9\13\n\9\9\9\9if this.name == \"RA2\" then --debug\13\n\9\9\9\9\9this:ngeAddToRenderQueue(go, screenArea, true, true)\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9this:ngeAddToRenderQueue(go, screenArea, true, true)\13\n\9\9\9\9--this:ngeAddToRenderQueue(go, {posX = 3, posY = 3, sizeX = 3, sizeY = 3}, true, true)\13\n\9\9\9end\13\n\9\9end\13\n\9\9--this:ngeAddToRenderQueue(global.state.reTest.goBigRETest, {posX = 3, posY = 3, sizeX = 3, sizeY = 3}, true, true)\13\n\9end\13\n\9\13\n\9this.ngeClear = function(this) --parent func\13\n\9\9if not this.isVisible then\13\n\9\9\9return false, \"Not visible\"\13\n\9\9end\13\n\9\9\13\n\9\9global.gpu.setActiveBuffer(this:getBufferID())\13\n\9\9\13\n\9\9\13\n\9\9if this.name == \"RA1\" then --debug\13\n\9\9\9global.gpu.setBackground(0x005500)\13\n\9\9\9global.gpu.fill(1, 1, this.sizeX, this.sizeY, \" \")\13\n\9\9\13\n\9\9end\13\n\9\9\13\n\9\9\13\n\9\9--===== execute cam move =====--\13\n\9\9if #this.cameraMoveInstructions.copy > 0 then\13\n\9\9\9local cmi = this.cameraMoveInstructions\13\n\9\9\9global.gpu.copy(cmi.copy[1], cmi.copy[2], cmi.copy[3], cmi.copy[4], cmi.copy[5], cmi.copy[6])\13\n\9\9\9\13\n\9\9\9global.oclrl:draw(0, 0, global.oclrl.generateTexture({\13\n\9\9\9\9{\"b\", global.backgroundColor},\13\n\9\9\9\9cmi.clear[1],\13\n\9\9\9\9cmi.clear[2],\13\n\9\9\9})--[[, nil, {renderArea.posX, renderArea.posX + renderArea.sizeX -1, renderArea.posY, renderArea.posY + renderArea.sizeY -1}]])\13\n\9\9\9\13\n\9\9end\13\n\9\9\13\n\9\9this:resetCMI()\13\n\9\9\13\n\9\9--===== execute GameObject clear instructions =====--\13\n\9\9--global.gpu.setBackground(global.backgroundColor)\13\n\9\9global.gpu.setBackground(0x0)\13\n\9\9\13\n\9\9for l, gos in pairs(this.toClear) do\13\n\9\9\9for go, areas in pairs(gos) do\13\n\9\9\9\9local x, y = this:getOffset()\13\n\9\9\9\9\13\n\9\9\9\9print(\"[RA]: \" .. tostring(this.name) .. \": Clear: \" .. tostring(go.ngeAttributes.name) .. \": \" .. tostring(go) .. \", frame: \" .. tostring(global.currentFrame) .. \".\")\13\n\9\9\9\9\13\n\9\9\9\9go:ngeClear(areas, x -1, y -1)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9this.ngeDraw = function(this) --parent func\13\n\9\9if not this.isVisible then\13\n\9\9\9return false, \"Not visible\"\13\n\9\9end\13\n\9\9\13\n\9\9for l, gos in pairs(this.toRender) do\13\n\9\9\9for go, areas in pairs(gos) do\13\n\9\9\9\9local x, y = this:getOffset()\13\n\9\9\9\9\13\n\9\9\9\9print(\"[RA]: \" .. tostring(this.name) .. \": Draw: \" .. tostring(go.ngeAttributes.name) .. \": \" .. tostring(go) .. \", frame: \" .. tostring(global.currentFrame) .. \".\")\13\n\9\9\9\9\13\n\9\9\9\9go:ngeDraw(this, areas, x -1, y -1)\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9if this.drawBorders then\13\n\9\9\9global.gpu.setActiveBuffer(global.screenBufferID)\13\n\9\9\9global.gpu.setBackground(this.borderColor)\13\n\9\9\9global.gpu.set(this.posX, this.posY -1, global.ut.fillString(\"\", this.sizeX, \" \"))\13\n\9\9\9global.gpu.set(this.posX, this.posY + (this.sizeY), global.ut.fillString(\"\", this.sizeX, \" \"))\13\n\9\9\9global.gpu.set(this.posX -1, this.posY, global.ut.fillString(\"\", this.sizeY, \" \"), true)\13\n\9\9\9global.gpu.set(this.posX + (this.sizeX), this.posY, global.ut.fillString(\"\", this.sizeY, \" \"), true)\13\n\9\9\9global.gpu.setActiveBuffer(this.backBufferID)\13\n\9\9end\13\n\9\9\13\n\9\9if this:getBufferID() ~= global.screenBufferID then\13\n\9\9\9local posX, posY = this:getPos()\13\n\9\9\9\13\n\9\9\9if global.conf.useDoubleBuffering then \13\n\9\9\9\9global.gpu.drawChanges()\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9global.gpu.bitblt(global.screenBufferID, posX, posY, this.sizeX, this.sizeY, this:getBufferID())\13\n\9\9end\13\n\9\9\13\n\9\9this.firstRender = false\13\n\9end\13\n\9this.ngeClearRenderQueue = function(this)\13\n\9\9if not this.isVisible then\13\n\9\9\9return false, \"Not visible\"\13\n\9\9end\13\n\9\9\13\n\9\9for l in pairs(this.toRender) do\13\n\9\9\9this.toRender[l] = {}\13\n\9\9\9this.toClear[l] = {}\13\n\9\9end\13\n\9end\13\n\9\13\n\9return this\13\nend\13\n\13\nreturn RenderArea",["./data/core/GameObject_experimental.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\n\13\nlocal GameObject = {}\13\nGameObject.__index = GameObject\13\n\13\nfunction GameObject.init()\13\n\9\13\nend\13\n\13\nlocal pa = global.ut.parseArgs\13\n\13\nlocal function addAreaEntry(a, e)\13\n\9local toInsert = {}\13\n\9toInsert.posX = pa(e.x, e.posX, 0)\13\n\9toInsert.posY = pa(e.y, e.posY, 0)\13\n\9toInsert.sizeX = pa(e.sx, e.sizeX, 0)\13\n\9toInsert.sizeY = pa(e.sy, e.sizeY, 0)\13\n\9toInsert.transparent = pa(e.transparent, false)\13\n\9table.insert(a, toInsert)\13\nend\13\n\13\nfunction GameObject.new(args)\13\n\9args = args or {}\13\n\9local this = setmetatable({}, GameObject)\13\n\9\13\n\9local noSizeArea = pa(args.noSizeArea, false)\13\n\9local noAutoSize = pa(args.noAutoSize, false)\13\n\9local noAutoClearAreas = pa(args.noAutoClearAreas, true)\13\n\9\13\n\9this.ngeAttributes = {\13\n\9\9sizeX = pa(args.sx, args.sizeX, 0),\13\n\9\9sizeY = pa(args.sy, args.sizeY, 0),\13\n\9\9layer = pa(args.layer, global.conf.renderLayerAmount),\13\n\9\9name = pa(args.name, \"\"),\13\n\9\9drawSize = pa(args.ds, args.drawSize, global.conf.debug.drawGameObjectBorders),\13\n\9\9isParent = args.isParent,\13\n\9\9updateAlways = pa(args.updateAlways, false),\13\n\9\9useIWL = pa(args.useIWL, false),\13\n\9\9interactionWhiteList = pa(args.iw, args.iwl, args.interactionWhiteList, {}),\13\n\9\9\13\n\9\9--=== Auto generated ===--\13\n\9\9id, \13\n\9\9sprites = {},\13\n\9\9lastFramePosX = 0,\13\n\9\9lastFramePosY = 0,\13\n\9\9responsibleRenderAreas = {},\13\n\9\9hasMoved = false,\13\n\9\9isVisibleIn = {},\13\n\9\9lastCalculatedFrame = 0,\13\n\9\9clearAreas = {},\13\n\9\9usesAnimation = pa(args.ua, args.usesAnimation, args.useAnimation),\13\n\9\9alive = true,\13\n\9}\13\n\9\13\n\9args.gameObject = global.ut.parseArgs(args.components, args.gameObject) --ToDo: Completly remove args.gameObject from the code.\13\n\9\13\n\9this.gameObject = global.ocgf.GameObject.new(global.ocgf, {\13\n\9\9dc = global.conf.debug.drawCollider,\13\n\9\9dt = global.conf.debug.drawTrigger,\13\n\9\9logFunc = global.log,\13\n\9\9posX = pa(args.x, args.posX),\13\n\9\9posY = pa(args.y, args.posY),\13\n\9\9parent = this,\13\n\9})\13\n\9\13\n\9for _, c in pairs(args.gameObject or {}) do\13\n\9\9if c[1] == \"BoxCollider\" then\13\n\9\9\9this.gameObject:addBoxCollider(c)\13\n\9\9elseif c[1] == \"BoxTrigger\" then\13\n\9\9\9this.gameObject:addBoxTrigger(c)\13\n\9\9elseif c[1] == \"RigidBody\" then\13\n\9\9\9this.gameObject:addRigidBody(c)\13\n\9\9elseif c[1] == \"Sprite\" then\13\n\9\9\9local sprite, texture, posX, posY = global.core.Sprite.new(c)\13\n\9\9\9\13\n\9\9\9if c.texture.format == \"OCGLA\" or c.texture.format == \"pan\" then\13\n\9\9\9\9this.ngeAttributes.usesAnimation = true\13\n\9\9\9elseif c.texture.format == \"pic\" then\13\n\9\9\9\9\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9if not noAutoSize then\13\n\9\9\9\9this.sizeX = math.max(this.ngeAttributes.sizeX, posX + texture.resX)\13\n\9\9\9\9this.sizeY = math.max(this.ngeAttributes.sizeY, posY + texture.resY)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9this.ngeAttributes.sprites[sprite] = true\13\n\9\9\9--this.gameObject:addSprite(c)\13\n\9\9elseif c[1] == \"CopyArea\" or c[1] == \"ClearArea\" then --CopyArea still there for legacy reasons.\13\n\9\9\9addAreaEntry(this.ngeAttributes.clearAreas, c)\13\n\9\9end\13\n\9end\13\n\9\13\n\9if not noSizeArea and this.ngeAttributes.sizeX > 0 and this.ngeAttributes.sizeY > 0 then\13\n\9\9addAreaEntry(this.ngeAttributes.clearAreas, {posX = 0, posY = 0, sizeX = this.ngeAttributes.sizeX, sizeY = this.ngeAttributes.sizeY, transparent = args.transparent})\13\n\9end\13\n\9\13\n\9\13\n\9\13\n\9--===== default functions =====--\13\n\9this.move = function(this, x, y)\13\n\9\9--x = math.floor(x)\13\n\9\9--y = math.floor(y)\13\n\9\9this.gameObject:move(x, -y)\13\n\9\9this.ngeAttributes.hasMoved = true\13\n\9end\13\n\9this.moveTo = function(this, x, y)\13\n\9\9--x = math.floor(x)\13\n\9\9--y = math.floor(y)\13\n\9\9this.gameObject:moveTo(x, y)\13\n\9\9this.ngeAttributes.hasMoved = true\13\n\9end\13\n\9this.addForce = function(this, x, y, maxSpeed)\13\n\9\9this.gameObject:addForce(x, y, maxSpeed)\13\n\9end\13\n\9this.addSpeed = function(this, x, y, maxSpeed) --ToDo / WIP: buggy. Outsource to ocgf.\13\n\9\9local x2, y2 = this:getSpeed()\13\n\9\9maxSpeed = maxSpeed or math.huge\13\n\9\9if x > 0 then\13\n\9\9\9x = math.min(x + x2, maxSpeed)\13\n\9\9else\13\n\9\9\9x = math.max(x + x2, -maxSpeed)\13\n\9\9end\13\n\9\9if y > 0 then\13\n\9\9\9y = math.min(y + y2, maxSpeed)\13\n\9\9else\13\n\9\9\9y = math.max(y + y2, -maxSpeed)\13\n\9\9end\13\n\9\9this.gameObject:setSpeed(x, -y)\13\n\9end\13\n\9this.setSpeed = function(this, x, y)\13\n\9\9this.gameObject:setSpeed(x, -y)\13\n\9end\13\n\9this.getPos = function(this)\13\n\9\9return math.floor(this.gameObject.posX +.5), math.floor(this.gameObject.posY +.5)\13\n\9end\13\n\9this.getSpeed = function(this)\13\n\9\9return this.gameObject:getSpeed()\13\n\9end\13\n\9this.getScreenPos = function(this)--ToDo: untested.\13\n\9\9return this:getRA():getGOPos(this)\13\n\9end\13\n\9this.getRealLastPos = function(this)\13\n\9\9return math.floor(this.gameObject.lastPosX +.5), math.floor(this.gameObject.lastPosY +.5)\13\n\9end\13\n\9this.getLastPos = function(this)\13\n\9\9return math.floor(this.ngeAttributes.lastFramePosX +.5), math.floor(this.ngeAttributes.lastFramePosY +.5)\13\n\9end\13\n\9this.getSize = function(this) --ToDo: generate real size dependent on the ClearAreas.\13\n\9\9return this.ngeAttributes.sizeX, this.ngeAttributes.sizeY\13\n\9end\13\n\9this.getRA = function(this)\13\n\9\9for ra in pairs(this.ngeAttributes.responsibleRenderAreas) do\13\n\9\9\9if ra.parent == nil then\13\n\9\9\9\9return ra\13\n\9\9\9else\13\n\9\9\9\9return ra.parent\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9this.getName = function(this)\13\n\9\9return this.ngeAttributes.name\13\n\9end\13\n\9this.getOffset = function(this, ra) --legacy support.\13\n\9\9return ra:getOffset()\13\n\9end\13\n\9this.destroy = function(this)\13\n\9\9for ra in pairs(this.ngeAttributes.responsibleRenderAreas) do\13\n\9\9\9this.ngeAttributes.alive = false\13\n\9\9\9ra:remGO(this)\13\n\9\9\9return\13\n\9\9end\13\n\9end\13\n\9this.attach = function(this, gameObject)\13\n\9\9this.gameObject:attach(gameObject.gameObject)\13\n\9end\13\n\9this.detach = function(this)\13\n\9\9this.gameObject:detach()\13\n\9end\13\n\9this.rerender = function(this)\13\n\9\9for ra in pairs(this.ngeAttributes.responsibleRenderAreas) do\13\n\9\9\9if ra.gameObjectAttributes[this] ~= nil then\13\n\9\9\9\9ra.gameObjectAttributes[this].mustBeRendered = true\13\n\9\9\9\9this.ngeAttributes.isRerendered = true\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9this.ngeAttributes.hasMoved = true\13\n\9\9\13\n\9\9this:ngeAddToRenderQueue()\13\n\9end\13\n\9this.addIWL = function(this, go)\13\n\9\9this.ngeAttributes.interactionWhiteList[go] = true\13\n\9end\13\n\9this.remIWL = function(this, go)\13\n\9\9this.ngeAttributes.interactionWhiteList[go] = nil\13\n\9end\13\n\9this.activateIWL = function(this, IWL)\13\n\9\9this.ngeAttributes.useIWL = true\13\n\9\9this:setIWL(IWL)\13\n\9end\13\n\9this.setIWL = function(this, IWL)\13\n\9\9if IWL ~= nil then\13\n\9\9\9this.ngeAttributes.interactionWhiteList = IWL\13\n\9\9end\13\n\9end\13\n\9this.getIWL = function(this)\13\n\9\9return this.ngeAttributes.interactionWhiteList\13\n\9end\13\n\9this.deactivateIWL = function(this)\13\n\9\9this.ngeAttributes.useIWL = false\13\n\9end\13\n\9this.getLayer = function(this)\13\n\9\9return this.ngeAttributes.layer\13\n\9end\13\n\9\13\n\9--===== engine functions =====--\13\n\9this.ngeStart = function(this) --parent func \13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pStart, this)\13\n\9\9else\13\n\9\9\9global.run(this.start, this)\13\n\9\9end\13\n\9end\13\n\9this.ngeUpdate = function(this, gameObjects, dt, ra) --parent func\13\n\9\9local ocgfGameObjects = {}\13\n\9\9local posX, posY = this:getPos()\13\n\9\9local lastPosX, lastPosY = this:getLastPos()\13\n\9\9\13\n\9\9if this.ngeAttributes.useIWL then\13\n\9\9\9gameObjects = this.ngeAttributes.interactionWhiteList\13\n\9\9end\13\n\9\9\13\n\9\9for go in pairs(gameObjects) do\13\n\9\9\9table.insert(ocgfGameObjects, go.gameObject)\13\n\9\9end\13\n\9\9\13\n\9\9\13\n\9\9this.gameObject:updatePhx(ocgfGameObjects, dt)\13\n\9\9this.gameObject:update(ocgfGameObjects)\13\n\9\9\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pUpdate, this, dt, ra, gameObjects, ocgfGameObjects)\13\n\9\9else\13\n\9\9\9global.run(this.update, this, dt, ra, gameObjects, ocgfGameObjects)\13\n\9\9end\13\n\9\9\13\n\9\9\13\n\9\9\13\n\9\9if posX ~= lastPosX or posY ~= lastPosY then\13\n\9\9\9this:ngeAddToRenderQueue()\13\n\9\9\9this.ngeAttributes.hasMoved = true\13\n\9\9end\13\n\9\9\13\n\9\9this.ngeAttributes.isUpdated = true\13\n\9end\13\n\9this.ngeActivate = function(this) --parent func\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pActivate, this)\13\n\9\9else\13\n\9\9\9global.run(this.activate, this)\13\n\9\9end\13\n\9end\13\n\9\13\n\9this.ngeIsInsideRenderArea = function(this, area, screenPos) --ToDo: fix.\13\n\9\9local posX, posY = this:getPos()\13\n\9\9local sizeX, sizeY = this:getSize()\13\n\9\9\13\n\9\9\13\n\9\9--[[\13\n\9\9global.log(posX, posY)\13\n\9\9\13\n\9\9global.log(global.ut.tostring(area))\13\n\9\9global.log(posX , sizeX , area.posX , posX , area.posX , area.sizeX ,\13\n\9\9\9posY , sizeY , area.posY , posY , area.posY , area.sizeY)\13\n\9\9\9\13\n\9\9global.log(posX + sizeX > area.posX , posX < area.posX + area.sizeX ,\13\n\9\9\9posY + sizeY > area.posY , posY < area.posY + area.sizeY)\13\n\9\9]]\13\n\9\9if  \13\n\9\9\9posX + sizeX > area.posX and posX < area.posX + area.sizeX and\13\n\9\9\9posY + sizeY > area.posY and posY < area.posY + area.sizeY\13\n\9\9then\13\n\9\9\9return true\13\n\9\9end\13\n\9\9\13\n\9\9return false\13\n\9end\13\n\9\13\n\9\13\n\9\13\n\9this.ngeClear = function(this, areas, offsetX, offsetY) --parent func\13\n\9\9local posX, posY = this:getLastPos()\13\n\9\9\13\n\9\9for _, area in pairs(areas) do\13\n\9\9\9area = {area.posX, area.posX + area.sizeX -1, area.posY, area.posY + area.sizeY -1}\13\n\9\9\9\13\n\9\9\9for _, ca in pairs(this.ngeAttributes.clearAreas) do\13\n\9\9\9\9global.oclrl:draw(posX + ca.posX - offsetX, posY + ca.posY - offsetY, global.oclrl.generateTexture(0, 0, ca.sizeX, ca.sizeY, \" \"), nil, area)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9this.ngeDraw = function(this, renderArea, areas, offsetX, offsetY) --parent func\13\n\9\9local posX, posY = this:getPos()\13\n\9\9for _, area in pairs(areas) do\13\n\9\9\9for s in pairs(this.ngeAttributes.sprites) do\13\n\9\9\9\9s:draw(renderArea, area, posX - offsetX, posY - offsetY)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9\13\n\9\13\n\9this.ngeSUpdate = function(this, gameObjects, dt, ra) --parent func\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pSUpdate, this, dt, ra)\13\n\9\9else\13\n\9\9\9global.run(this.sUpdate, this, dt, ra)\13\n\9\9end\13\n\9\9this.ngeAttributes.isRerendered = false\13\n\9\9this:ngeSetLastPos()\13\n\9end\13\n\9this.ngeSetLastPos = function(this)\13\n\9\9this.ngeAttributes.lastFramePosX = math.floor(this.gameObject.posX +.5)\13\n\9\9this.ngeAttributes.lastFramePosY = math.floor(this.gameObject.posY +.5)\13\n\9\9\13\n\9\9this.ngeAttributes.hasMoved = false\13\n\9end\13\n\9this.ngeStop = function(this)\13\n\9\9this.gameObject:stop()\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pStop, this)\13\n\9\9else\13\n\9\9\9global.run(this.stop, this)\13\n\9\9end\13\n\9\9this.gameObject:stop()\13\n\9end\13\n\9this.ngeSpawn = function(this) --parent func\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pSpawn, this)\13\n\9\9else\13\n\9\9\9global.run(this.spawn, this)\13\n\9\9end\13\n\9end\13\n\9this.ngeDespawn = function(this) --parent func\13\n\9\9if this.ngeAttributes.isParent then\13\n\9\9\9global.run(this.pDespawn, this)\13\n\9\9else\13\n\9\9\9global.run(this.despawn, this)\13\n\9\9end\13\n\9end\13\n\9this.ngeAddToRenderQueue = function(this)\13\n\9\9global.core.re.toRender[this] = true\13\n\9end\13\n\9\13\n\9return this\13\nend\13\n\13\nreturn GameObject",["./data/core/updateHandler.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--GameEngine\13\nlocal global = ...\13\nlocal uh = {\13\n\9isUpdated = {},\13\n\9signalQueue = {},\13\n\9sUpdateQueue = {},\13\n\9ocgfUpdateQueue = {},\13\n\9newOcgfUpdateQueue = {},\13\n}\13\n\13\n--===== local vars =====--\13\nlocal narrowUpdateExpansion = global.conf.narrowUpdateExpansion\13\nlocal tableInsert = table.insert\13\nlocal calcSUpdate = global.conf.calcSUpdate\13\n\13\n--===== local functions =====--\13\nlocal function print(...)\13\n\9if global.conf.debug.geDebug then\13\n\9\9global.debug.log(...)\13\n\9end\13\nend\13\n\13\nlocal function isInsideArea(ra, go, expansion)\13\n\9local x, y = go:getPos()\13\n\9local sx, sy = go.ngeAttributes.sizeX, go.ngeAttributes.sizeY\13\n\9local fromX, toX, fromY, toY = ra:getFOV()\13\n\9local expansion = expansion or {0, 0, 0, 0}\13\n\9\13\n\9if x +sx > fromX -expansion[1] and x < toX +expansion[2] and y +sy > fromY -expansion[3] and y < toY +expansion[4] then\13\n\9\9return true\13\n\9end\13\n\9\13\n\9return false\13\nend\13\n\13\nlocal function updateGameObjec(renderArea, go, ocgfUpdateQueue, dt)\13\n\9local isUpdated = uh.isUpdated\13\n\13\n\9if type(go) == \"number\" then\13\n\9\9go = c\13\n\9\9global.fatal(\"Update handler has unexpectet toUpdate table.\") --currently not relevant.\13\n\9end\13\n\13\n\9if not isUpdated[go] then\13\n\9\9for i, s in pairs(uh.signalQueue) do\13\n\9\9\9global.run(go[s.name], go, s.signal, s.name)\13\n\9\9end\13\n\9\9\13\n\9\9go:ngeUpdate(ocgfUpdateQueue, dt, renderArea)\13\n\9\9if calcSUpdate then\13\n\9\9\9tableInsert(uh.sUpdateQueue, {go, renderArea})\13\n\9\9end\13\n\9\9isUpdated[go] = true\13\n\13\n\9\9return go.gameObject\13\n\9end\13\nend\13\n\13\nlocal function checkLoadingStatus(go, updated)\13\n\9--global.log(updated, go.ngeAttributes.isLoaded)\13\n\9if not updated and go.ngeAttributes.isLoaded then\13\n\9\9global.run(go.ngeUnload, go)\13\n\9elseif updated and not go.ngeAttributes.isLoaded then\13\n\9\9global.run(go.ngeLoad, go)\13\n\9end\13\nend\13\n\13\nlocal function updateFrame(renderArea, dt)\13\n\9local ocgfUpdateQueue = uh.ocgfUpdateQueue\13\n\9local newOcgfUpdateQueue = uh.newOcgfUpdateQueue\13\n\9local ocgfGameObject = nil\13\n\9local expansion = renderArea.narrowUpdateExpansion\13\n\9local isUpdated = uh.isUpdated\13\n\13\n\9if narrowUpdateExpansion ~= false and not renderArea.updateAnything then\13\n\9\9for go in pairs(renderArea.gameObjects) do\13\n\9\9\9local l = go.ngeAttributes.layer\13\n\9\9\9\13\n\9\9\9if \13\n\9\9\9\9renderArea.layerBlacklist[l] ~= true and \13\n\9\9\9\9isInsideArea(renderArea, go, narrowUpdateExpansion) and \13\n\9\9\9\9isUpdated[go] ~= true or\13\n\9\9\9\9go.ngeAttributes.updateAlways\13\n\9\9\9then \13\n\9\9\9\9ocgfGameObject = updateGameObjec(renderArea, go, ocgfUpdateQueue, dt)\13\n\9\9\9\9checkLoadingStatus(go, true)\13\n\9\9\9\9if not go.ngeAttributes.ignoreOCGFGameObject then\13\n\9\9\9\9\9tableInsert(newOcgfUpdateQueue, ocgfGameObject)\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9checkLoadingStatus(go, false)\13\n\9\9\9end\13\n\9\9end\13\n\9else\13\n\9\9for go in pairs(renderArea.gameObjects) do\13\n\9\9\9ocgfGameObject = updateGameObjec(renderArea, go, ocgfUpdateQueue, dt)\13\n\9\9\9checkLoadingStatus(go, true)\13\n\9\9\9if not go.ngeAttributes.ignoreOCGFGameObject then\13\n\9\9\9\9tableInsert(newOcgfUpdateQueue, ocgfGameObject)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9renderArea.toUpdate = {}\13\nend\13\n\13\n--===== global functions =====--\13\nfunction uh.init()\13\n\9\13\nend\13\n\13\nfunction uh.update(dt)\13\n\9dt = dt or global.dt\13\n\9\13\n\9for ra in pairs(global.renderAreas) do\13\n\9\9if not ra.silent then\13\n\9\9\9updateFrame(ra, dt)\13\n\9\9end\13\n\9end\13\n\9\13\n\9uh.isUpdated = {}\13\n\9uh.signalQueue = {}\13\n\9uh.ocgfUpdateQueue = uh.newOcgfUpdateQueue\13\n\9uh.newOcgfUpdateQueue = {}\13\nend\13\n\13\nfunction uh.sUpdate(dt)\13\n\9dt = dt or global.dt\13\n\9\13\n\9for i, suq in pairs(uh.sUpdateQueue) do\13\n\9\9suq[1]:ngeSUpdate(suq[2].gameObjects, dt, suq[2])\13\n\9end\13\n\9uh.sUpdateQueue = {}\13\nend\13\n\13\nfunction uh.insertSignal(s, signalName)\13\n\9\13\n\9--[[\13\n\9local t = s\13\n\9\13\n\9if signalName ~= nil then\13\n\9\9t = {signalName}\13\n\9\9for i, c in pairs(s) do\13\n\9\9\9if i > 1 then\13\n\9\9\9\9t[i] = c\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9--uh.signalQueue[#uh.signalQueue][1] = signalName\13\n\9end\13\n\9]]\13\n\9--print(signalName)\13\n\9tableInsert(uh.signalQueue, {name = signalName, signal = s})\13\n\9\13\n\9--global.log(global.currentFrame, signalName)\13\n\9--global.slog(uh.signalQueue)\13\n\9\13\nend\13\n\13\n--===== init =====--\13\nif not calcSUpdate then\13\n\9uh.sUpdate = function() end\13\nend\13\n\13\nreturn uh",["./data/core/re.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--WorldRenderEngine\13\nlocal global = ...\13\nlocal re = {\13\n\9rendered = {},\13\n\9copyInstructions = {},\13\n}\13\n\13\n--===== local vars =====--\13\nlocal fromX, toX, fromY, toY = 0, 0, 0, 0 --regenerated every update.\13\n\13\nlocal overlapChecks = 0 --debug\13\n\13\nlocal tableInsert = table.insert\13\nlocal conf = global.conf\13\nlocal printDebug = conf.debug.reDebug\13\nlocal mathMin, mathMax = math.min, math.max\13\n\13\n--===== local functions =====--\13\nlocal function print(...)\13\n\9global.debug.log(...)\13\nend\13\n\13\nlocal function isInsideArea(ra, go, cmi)\13\n\9local x, y = go:getPos()\13\n\9local sx, sy = go.ngeAttributes.sizeX, go.ngeAttributes.sizeY\13\n\9local fromX, toX, fromY, toY = ra:getFOV()\13\n\9local expansion = {0, 0, 0, 0}\13\n\9local cmiRawX = cmi.raw.x\13\n\9local cmiRawY = cmi.raw.y\13\n\9\13\n\9if cmiRawX > 0 then\13\n\9\9expansion[1] = expansion[1] + 0\13\n\9\9expansion[2] = expansion[2] + cmiRawX\13\n\9elseif cmiRawX < 0 then\13\n\9\9expansion[1] = expansion[1] + cmiRawX\13\n\9\9expansion[2] = expansion[2] + 0\13\n\9end\13\n\9if cmiRawY > 0 then\13\n\9\9expansion[3] = expansion[3] + 0\13\n\9\9expansion[4] = expansion[4] + cmiRawY\13\n\9elseif cmiRawY < 0 then\13\n\9\9expansion[3] = expansion[3] + cmiRawY\13\n\9\9expansion[4] = expansion[4] + 0\13\n\9end\13\n\9\13\n\9if x +sx > fromX and x < toX and y +sy > fromY and y < toY then\13\n\9\9go.ngeAttributes.isVisibleIn[ra] = true\13\n\9\9return 1\13\n\9elseif x +sx > fromX +expansion[1] and x < toX +expansion[2] and y +sy > fromY +expansion[3] and y < toY +expansion[4] then\13\n\9\9go.ngeAttributes.isVisibleIn[ra] = true\13\n\9\9return 2\13\n\9end\13\n\9\13\n\9go.ngeAttributes.isVisibleIn[ra] = nil\13\n\9return 0\13\nend\13\n\13\nlocal function isInQueue(ra, go, l)\13\n\9return ra.toRender[l][go] ~= nil\13\nend\13\n\13\nlocal function checkOverlapping(renderArea, gameObject, layer)\13\n\9layer = layer or 0\13\n\13\n\9local gameObjectClearAreas = gameObject.ngeAttributes.clearAreas\13\n\9local notUseSmartOverap = not global.conf.useSmartOverlap\13\n\13\n\9local soSizeX, soSizeY = gameObject:getSize()\13\n\9local soLastPosX, soLastPosY = gameObject:getLastPos()\13\n\9local soPosX, soPosY = gameObject:getPos()\13\n\9\13\n\9for go in pairs(renderArea.gameObjects) do\13\n\9\9local l = go.ngeAttributes.layer\13\n\9\9local goClearAreas = go.ngeAttributes.clearAreas\13\n\9\9local renderAreaLayerIsBlacklisted = renderArea.layerBlacklist[l] ~= true\13\n\9\9local renderAreaGameObjectAttributes = renderArea.gameObjectAttributes[go]\13\n\9\9\13\n\9\9for i, oca in pairs(gameObjectClearAreas) do\13\n\9\9\9for i, ca in pairs(goClearAreas) do\13\n\9\9\9\9overlapChecks = overlapChecks +1\13\n\13\n\9\9\9\9if notUseSmartOverap and isInQueue(renderArea, go, l) then\13\n\9\9\9\9\9goto skip\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9if --[[l >= layer and]] renderAreaLayerIsBlacklisted and isInsideArea(renderArea, go, renderArea.cameraMoveInstructions) == 1 then\13\n\9\9\9\9\9local x, y = gameObject:getPos()\13\n\9\9\9\9\9local x2, y2 = go:getPos()\13\n\9\9\9\9\9local sx, sy = oca.sizeX, oca.sizeY\13\n\9\9\9\9\9local sx2, sy2 = ca.sizeX, ca.sizeY\13\n\9\9\9\9\9local lastPosX, lastPosY = gameObject:getLastPos()\13\n\9\9\9\9\9local lastPosX2, lastPosY2 = go:getLastPos()\13\n\13\n\9\9\9\9\9x, y = x + oca.posX, y + oca.posY\13\n\9\9\9\9\9x2, y2 = x2 + ca.posX, y2 + ca.posY\13\n\9\9\9\9\9lastPosX, lastPosY = lastPosX + oca.posX, lastPosY + oca.posY\13\n\9\9\9\9\9lastPosX2, lastPosY2 = lastPosX2 + ca.posX, lastPosY2 + ca.posY\13\n\13\n\9\9\9\9\13\n\9\9\9\9\9if gameObject ~= go and \13\n\9\9\9\9\9\9x + sx > x2 and\13\n\9\9\9\9\9\9x < x2 + sx2 and\13\n\9\9\9\9\9\9y + sy > y2 and\13\n\9\9\9\9\9\9y < y2 + sy2\13\n\9\9\9\9\9or gameObject ~= go and \13\n\9\9\9\9\9\9lastPosX + sx > lastPosX2 and\13\n\9\9\9\9\9\9lastPosX < lastPosX2 + sx2 and\13\n\9\9\9\9\9\9lastPosY + sy > lastPosY2 and\13\n\9\9\9\9\9\9lastPosY < lastPosY2 + sy2 \13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9if renderAreaGameObjectAttributes ~= nil then\13\n\9\9\9\9\9\9\9renderAreaGameObjectAttributes.mustBeRendered = true\13\n\9\9\9\9\9\9\9renderAreaGameObjectAttributes.causedByOverlap = true\13\n\9\9\9\9\9\9\9renderArea.toRender[l][go] = renderArea\13\n\13\n\9\9\9\9\9\9\9if global.conf.useSmartOverlap then\13\n\9\9\9\9\9\9\9\9tableInsert(renderAreaGameObjectAttributes.overlappingAreas, {\13\n\9\9\9\9\9\9\9\9\9soLastPosX,\13\n\9\9\9\9\9\9\9\9\9soLastPosX + soSizeX -1,\13\n\9\9\9\9\9\9\9\9\9soLastPosY,\13\n\9\9\9\9\9\9\9\9\9soLastPosY + soSizeY -1,\13\n\9\9\9\9\9\9\9\9})\13\n\9\9\9\9\9\9\9\9tableInsert(renderAreaGameObjectAttributes.overlappingAreas, {\13\n\9\9\9\9\9\9\9\9\9soPosX,\13\n\9\9\9\9\9\9\9\9\9soPosX + soSizeX -1,\13\n\9\9\9\9\9\9\9\9\9soPosY,\13\n\9\9\9\9\9\9\9\9\9soPosY + soSizeY -1,\13\n\9\9\9\9\9\9\9\9})\13\n\9\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9\9checkOverlapping(renderArea, go, l)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\9\13\n\9\9\9\9\9\9\9if printDebug then\13\n\9\9\9\9\9\9\9\9print(\"[RE]: Found overlap with: \" .. gameObject.ngeAttributes.name .. \": N:\" .. go.ngeAttributes.name .. \", L:\" .. tostring(l) .. \", X:\" .. tostring(x) .. \", Y:\" .. tostring(y) .. \", ID:\"..  tostring(go) .. \", F:\" .. tostring(global.currentFrame) .. \".\")\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9\9::skip::\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function calculateFrame(renderArea, area)\13\n\9for go in pairs(renderArea.gameObjects) do\13\n\9\9local l = go.ngeAttributes.layer\13\n\9\9local renderAreaGameObjectAttributes = renderArea.gameObjectAttributes[go]\13\n\9\9insideArea = isInsideArea(renderArea, go, renderArea.cameraMoveInstructions)\13\n\13\n\9\9if not isInQueue(renderArea, go, l) and renderArea.layerBlacklist[l] ~= true and insideArea ~= 0 then\13\n\9\9\9if renderAreaGameObjectAttributes.lastCalculatedFrame < global.currentFrame -1 then\13\n\9\9\9\9renderAreaGameObjectAttributes.mustBeRendered = true\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9if go.ngeAttributes.hasMoved then\13\n\9\9\9\9checkOverlapping(renderArea, go)\13\n\9\9\9\9renderArea.toRender[l][go] = renderArea\13\n\9\9\9elseif renderAreaGameObjectAttributes.mustBeRendered then\13\n\9\9\9\9renderAreaGameObjectAttributes.mustBeRendered = false\13\n\9\9\9\9checkOverlapping(renderArea, go, l)\13\n\9\9\9\9renderArea.toRender[l][go] = renderArea\13\n\9\9\9end\13\n\9\9elseif go.ngeAttributes.hasMoved and renderAreaGameObjectAttributes.causedByOverlap and renderArea.layerBlacklist[l] ~= true and insideArea ~= 0 then\13\n\9\9\9checkOverlapping(renderArea, go)\13\n\9\9elseif renderAreaGameObjectAttributes.wasVisible then\13\n\9\9\9renderArea.toClear[l][go] = renderArea\13\n\9\9\9renderAreaGameObjectAttributes.wasVisible = nil\13\n\9\9end\13\n\9\9renderAreaGameObjectAttributes.lastCalculatedFrame = global.currentFrame\13\n\9end\13\nend\13\n\13\nlocal function moveFrame(renderArea)\13\n\9if #renderArea.cameraMoveInstructions.copy > 0 then\13\n\9\9local cmi = renderArea.cameraMoveInstructions\13\n\9\9local cmiCopy = cmi.copy\13\n\9\9global.gpu.copy(cmiCopy[1], cmiCopy[2], cmiCopy[3], cmiCopy[4], cmiCopy[5], cmiCopy[6])\13\n\9\9if global.conf.useDoubleBuffering then\13\n\9\9\9tableInsert(re.copyInstructions, {cmiCopy[1], cmiCopy[2], cmiCopy[3], cmiCopy[4], cmiCopy[5], cmiCopy[6]})\13\n\9\9end\13\n\9\9\13\n\9\9global.oclrl:draw(0, 0, global.oclrl.generateTexture({\13\n\9\9\9{\"b\", global.backgroundColor},\13\n\9\9\9cmi.clear[1],\13\n\9\9\9cmi.clear[2],\13\n\9\9}), nil, renderArea.sizeArray)\13\n\9\9\13\n\9end\13\nend\13\n\13\nlocal function moveArea(renderArea)\13\n\9--global.log(\"move\")\13\n\9for i, ci in pairs(renderArea.copyInstructions) do\13\n\9\9if ci == nil or #ci <= 0 then\13\n\9\9\9global.warn(\"[RE]: CopyInstruction is empty: frame: \" .. tostring(global.currentFrame) .. \".\")\13\n\9\9\9return false\13\n\9\9end\13\n\9\9\13\n\9\9local fromX, toX, fromY, toY = renderArea:getRealFOV()\13\n\9\9local x1, y1, x2, y2 = ci[1], ci[2], ci[1] + ci[3] -1, ci[2] + ci[4] -1\13\n\9\9local ax, ay, asx, asy, atx, aty\13\n\9\9\13\n\9\9fromX = fromX - mathMin(ci[5], 0)\13\n\9\9fromY = fromY - mathMin(ci[6], 0)\9\9\13\n\9\9toX = toX - mathMax(ci[5] +1, 1)\13\n\9\9toY = toY - mathMax(ci[6] +1, 1)\13\n\9\9\13\n\9\9if #renderArea.cameraMoveInstructions.copy > 0 then\13\n\9\9\9x1, y1, x2, y2 = x1 + renderArea.cameraMoveInstructions.copy[5], y1 + renderArea.cameraMoveInstructions.copy[6], x2 + renderArea.cameraMoveInstructions.copy[5], y2 + renderArea.cameraMoveInstructions.copy[6]\13\n\9\9end\13\n\9\9\13\n\9\9x1 = mathMax(x1, fromX)\13\n\9\9y1 = mathMax(y1, fromY)\13\n\9\9x2 = mathMin(x2, toX)\13\n\9\9y2 = mathMin(y2, toY)\13\n\9\9\13\n\9\9ax = x1\13\n\9\9ay = y1\13\n\9\9asx = x2 - x1 +1\13\n\9\9asy = y2 - y1 +1\13\n\9\9\13\n\9\9global.gpu.copy(ax, ay, asx, asy, ci[5], ci[6])\13\n\9\9if global.conf.useDoubleBuffering then\13\n\9\9\9tableInsert(re.copyInstructions, {ax, ay, asx, asy, ci[5], ci[6]})\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clearFrame(renderArea, toClear)\13\n\9local clearList = global.ut.parseArgs(toClear, renderArea.toRender)\13\n\9\13\n\9for i, l in pairs(clearList) do\13\n\9\9for go in pairs(l) do\13\n\9\9\9if go.ngeAttributes.hasMoved and go.ngeAttributes.clearedAlready ~= true then\13\n\9\9\9\9if printDebug then\13\n\9\9\9\9\9print(\"[RE]: Clear: \" .. tostring(go.ngeAttributes.name) .. \": (\" .. tostring(go) .. \"), RA: \" .. renderArea.name .. \", frame: \" .. tostring(global.currentFrame) .. \".\")\13\n\9\9\9\9end\13\n\9\9\9\9go:ngeClear(renderArea)\13\n\9\9\9end\13\n\9\9end\13\n\9\9if toClear ~= nil then\13\n\9\9\9toClear[i] = {}\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(renderArea)\13\n\9for i, l in pairs(renderArea.toRender) do\13\n\9\9for go, area in pairs(l) do\13\n\9\9\9if printDebug then\13\n\9\9\9\9print(\"[RE]: Draw: \" .. tostring(go.ngeAttributes.name) .. \": (\" .. tostring(go) .. \"), RA: \" .. renderArea.name .. \", frame: \" .. tostring(global.currentFrame) .. \".\")\13\n\9\9\9end\13\n\9\9\9go:ngeDraw(area)\13\n\9\9\9re.rendered[go] = true\13\n\9\9\9renderArea.gameObjectAttributes[go].causedByOverlap = false\13\n\9\9end\13\n\9\9renderArea.toRender[i] = {}\13\n\9end\13\n\9global.core.uiHandler.draw()\13\nend\13\n\13\n--===== global functions =====--\13\nfunction re.init()\13\n\9\13\nend\13\n\13\nfunction re.draw()\13\n\9--print(\"[RE]: New frame: \" .. tostring(global.currentFrame))\13\n\9for ra in pairs(global.renderAreas) do\13\n\9\9if ra.visible then\13\n\9\9\9moveFrame(ra)\13\n\9\9\9moveArea(ra)\13\n\9\9\9clearFrame(ra, ra.toClear)\13\n\9\9\9clearFrame(ra)\13\n\9\9\9drawFrame(ra)\13\n\9\9\9ra:ngeDraw()\13\n\9\9\9ra:resetCMI()\13\n\9\9end\13\n\9end\13\n\9for go in pairs(re.rendered) do\13\n\9\9go:ngeSetLastPos()\13\n\9end\13\n\13\n\9--global.log(overlapChecks)\13\n\9overlapChecks = 0\13\n\13\nend\13\n\13\nfunction re.executeCopyOrders()\13\n\9if global.conf.useDoubleBuffering then\13\n\9\9for i, co in pairs(re.copyInstructions) do\13\n\9\9\9global.realGPU.copy(co[1], co[2], co[3], co[4], co[5], co[6])\13\n\9\9end\13\n\9\9re.copyInstructions = {}\13\n\9end\13\nend\13\n\13\nfunction re.newDraw(renderArea)\13\n\9for go in pairs(global.gameObjects) do\13\n\9\9renderArea.gameObjectAttributes[go].mustBeRendered = true\13\n\9end\13\nend\13\n\13\nfunction re.test()\13\n\9for ra in pairs(global.renderAreas) do\13\n\9\9print(\"TT\")\13\n\9\9calculateFrame(ra)\13\n\9\9clearFrame()\13\n\9\9drawFrame()\13\n\9end\13\nend\13\n\13\nre.calculateRenderArea = function() end\13\nre.checkOverlapping = function() end\13\n\13\nre.calculateRenderArea = calculateFrame\13\nre.checkOverlapping = checkOverlapping\9\13\n\13\n--===== init =====--\13\n\13\n\13\nreturn re",["./data/core/re_experimental.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\nlocal re = {\13\n\9toRender = {}\13\n}\13\n\13\n--===== local vars =====--\13\n\13\n--===== local functions =====--\13\nlocal function print(...)\13\n\9if global.conf.debug.reDebug then\13\n\9\9global.debug.log(...)\13\n\9end\13\nend\13\n\13\nlocal function bufferTexture(t, resetBuffer)\13\n\9local texture = t\13\n\9local textureBufferID\13\n\9local currentBufferID = global.gpu.getActiveBuffer()\13\n\9resetBuffer = global.ut.parseArgs(resetBuffer, true)\13\n\9\13\n\9if type(t) == \"string\" then\13\n\9\9texture = global.texture[t]\13\n\9end\13\n\9\13\n\9if texture.id ~= nil then\13\n\9\9print(\"[RE]: [BT]: Texture: \" .. tostring(t) .. \" is buffered already.\")\13\n\9\9return false, \"Texture is buffered already\"\13\n\9end\13\n\9\13\n\9if texture.format == \"pic\" then\13\n\9\9--[[\13\n\9\9textureBufferID = global.gpu.allocateBuffer(texture.resX, texture.resY)\13\n\9\9\13\n\9\9global.gpu.setActiveBuffer(textureBufferID)\13\n\9\9global.db.drawImage(1, 1, texture)\13\n\9\9global.db.drawChanges()\13\n\9\9]]\13\n\9\9\13\n\9\9local cfb, cff, cfs, bw, bh = global.db.getCurrentFrameTables()\13\n\9\9local nfb, nff, nfs = global.db.getNewFrameTables()\13\n\9\9textureBufferID = global.gpu.allocateBuffer(texture.resX, texture.resY)\13\n\9\9\13\n\9\9global.gpu.setActiveBuffer(textureBufferID)\13\n\9\9global.db.flush(texture.resX, texture.resY)\13\n\9\9global.db.drawImage(1, 1, texture)\13\n\9\9global.db.drawChanges()\13\n\9\9\13\n\9\9global.db.flush(bw, bh)\13\n\9\9global.db.setCurrentFrameTables(cfb, cff, cfs, bw, bh)\13\n\9\9global.db.setNewFrameTables(nfb, nff, nfs, bw, bh)\13\n\9\9\13\n\9elseif texture.format == \"OCGLT\" then\13\n\9\9local oclrlInternGPU = global.oclrl.gpu\13\n\9\9textureBufferID = global.gpu.allocateBuffer(texture.resX, texture.resY)\13\n\9\9\13\n\9\9global.gpu.setActiveBuffer(textureBufferID)\13\n\9\9global.oclrl.gpu = global.realGPU\13\n\9\9\13\n\9\9global.oclrl:draw(1, 1, texture)\13\n\9\9\13\n\9\9global.oclrl.gpu = oclrlInternGPU\13\n\9else\13\n\9\9global.warn(\"[RE]: [BT]: Invalid format, texture: \" .. tostring(t) .. \": \" .. tostring(texture.format))\13\n\9\9return false, \"Ivalid format\", texture.format\13\n\9end\13\n\9\13\n\9texture.bufferID = textureBufferID\13\n\9\13\n\9print(\"[RE]: [BT]: Texture: \" .. tostring(t) .. \" loaded into buffer: \" .. tostring(textureBufferID))\13\n\9\13\n\9if resetBuffer then\13\n\9\9global.gpu.setActiveBuffer(currentBufferID)\13\n\9end\13\n\9\13\n\9return textureBufferID\13\nend\13\n\13\n--===== global functions =====--\13\nfunction re.init()\13\n\9print(\"[RE]: [INIT]: bufferTexturesOnInit: \" .. tostring(global.conf.bufferTexturesOnInit) .. \", useBufferWhitelist: \" .. tostring(global.texturePack.useBufferWhitelist))\13\n\9\13\n\9if global.conf.useDoubleBuffering and false then\13\n\9\9global.gpu.freeAllBuffers()\13\n\9\9\13\n\9\9global.gpu = loadfile(\"libs/dbgpu_api.lua\")({path = \"libs/thirdParty\", directDraw = false, forceDraw = false, rawCopy = true, actualRawCopy = true, global = global})\13\n\9\9--[[\13\n\9\9global.gpu = global.realGPU\13\n\9\9global.gpu.drawChanges = function() end\13\n\9\9]]\13\n\9\9--global.oclrl.gpu = global.gpu\13\n\9\9global.oclrl.gpu = global.realGPU\13\n\9\9\13\n\9\9\13\n\9end\13\n\9\13\n\9global.gpu.freeAllBuffers()\13\n\9\13\n\9--global.db = nil\13\n\9--global.db = dofile(\"libs/thirdParty/DoubleBuffering.lua\")\13\n\9\13\n\9--print(xpcall(global.db.setCurrentFrameTables, debug.traceback, {}, {}, {}))\13\n\9\13\n\9--debug.traceback()\13\n\9\13\n\9\13\n\9if global.conf.bufferTexturesOnInit then\13\n\9\9print(\"[RE]: [INIT]: Buffer textures\")\13\n\9\9\13\n\9\9if global.texturePack.useBufferWhitelist then\13\n\9\9\13\n\9\9else\13\n\9\9\9for i, c in pairs(global.texture) do\13\n\9\9\9\9if global.texturePack.bufferBlacklist[i] == nil then\13\n\9\9\9\9\9bufferTexture(i)\13\n\9\9\9\9end\9\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9--gpu.bitblt(0, 1, 1, nil, nil, 6)\13\n\9--os.sleep(1)\13\n\9\13\n\9--global.oclrl = nil\13\nend\13\n\13\nfunction re.draw()\13\n\9print(\"[RE]: New frame: \" .. tostring(global.currentFrame))\13\n\9\13\n\9for ra, _ in pairs(global.renderAreas) do\13\n\9\9if global.renderAreas[ra] then\13\n\9\9\9ra:ngeCalculateNewRender()\13\n\9\9\9ra:ngeClear()\13\n\9\9\9ra:ngeDraw()\13\n\9\9\9ra:ngeClearRenderQueue()\13\n\9\9\9\13\n\9\9\9--global.realGPU.fill(1, 1, 100, 100, \" \")\13\n\9\9end\13\n\9end\13\n\9\13\n\9global.gpu.setActiveBuffer(global.screenBufferID)\13\n\9\13\n\9if global.conf.useDoubleBuffering then\13\n\9\9--global.core.re.executeCopyOrders()\13\n\9\9--global.gpu.drawChanges()\13\n\9end\13\n\9\13\n\9re.toRender = {}\13\nend\13\n\13\nfunction re.newDraw()\13\n\9\13\nend\13\n\13\nfunction re.test()\13\n\9\13\nend\13\n\13\n\13\n--===== init =====--\13\n\13\n\13\nreturn re",["./data/core/uiHandler.lua"] = "local global = ...\n\nlocal uiHandler = {\n    guiApplications = {}\n}\n\nfunction uiHandler.update(signal) \n\nend\n\nfunction uiHandler.draw()\n\nend\n\nfunction uiHandler.listApplication(application)\n    uiHandler.guiApplications[application] = true\nend\n\nfunction uiHandler.ignoreApplication(application)\n    uiHandler.guiApplications[application] = nil\nend\n\nfunction uiHandler.stop()\n    for app in pairs(uiHandler.guiApplications) do\n        app:stop()\n        uiHandler.guiApplications[app] = nil\n    end\nend\n\n--===== init =====--\nif global.conf.useDoubleBuffering then\n    uiHandler.update = function(signal)\n        for app in pairs(uiHandler.guiApplications) do\n            local suc, err = coroutine.resume(app.coroutine, table.unpack(signal))\n\n            if suc == false then\n                global.error(\"[GUI]: \", err, debug.traceback(app.coroutine))\n            end\n        end\n    end\n\n    uiHandler.draw = function()\n        for app in pairs(uiHandler.guiApplications) do\n            app:draw()\n        end\n    end\nend\n\nreturn uiHandler",["./data/core/Sprite_experimental.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\n\13\nlocal Sprite = {}\13\nSprite.__index = Sprite\13\n\13\nlocal pa = global.ut.parseArgs\13\n\13\nfunction Sprite.new(args)\13\n\9args = args or {}\13\n\9local this = setmetatable({}, Sprite)\13\n\9\13\n\9this.posX = pa(args.x, args.posX, args.offsetX, 0)\13\n\9this.posY = pa(args.y, args.posY, args.offsetY, 0)\13\n\9\13\n\9if type(args.texture) == \"string\" then\13\n\9\9this.texture = global.texture[args.texture]\13\n\9else\13\n\9\9this.texture = args.texture\13\n\9end\13\n\9\13\n\9return this, this.texture, this.posX, this.posY\13\nend\13\n\13\nfunction Sprite.clear(this, renderArea, area, offsetX, offsetY, setBackground)\13\n\9--[[\13\n\9if this.noClear then\13\n\9\9return false, \"noClear is set to true.\"\13\n\9end\13\n\9if setBackground or setBackground == nil then\13\n\9\9global.gpu.setBackground(0x0)\13\n\9end\13\n\9global.gpu.fill(this.posX + offsetX, this.posY + offsetY, this.texture.resX, this.texture.resY, \" \")\13\n\9]]\13\nend\13\n\13\nfunction Sprite.draw(this, renderArea, area, offsetX, offsetY)\13\n\9if this.texture.bufferID ~= nil then\13\n\9\9local posX, posY, resX, resY = this.posX + offsetX, this.posY + offsetY, this.texture.resX, this.texture.resY\13\n\9\9local textureBufferPosX, textureBufferPosY = 1, 1\13\n\9\9local overLapPrositiveX, overLapNegativeX, overLapPrositiveY, overLapNegativeY = 0, 0, 0, 0\13\n\9\9\13\n\9\9overLapNegativeX = math.max(area.posX - posX, 0)\13\n\9\9overLapPrositiveX = math.max((posX + resX) - (area.posX + area.sizeX), 0)\13\n\9\9overLapNegativeY = math.max(area.posY - posY, 0)\13\n\9\9overLapPrositiveY = math.max((posY + resY) - (area.posY + area.sizeY), 0)\13\n\9\9\13\n\9\9resX = resX - overLapPrositiveX - overLapNegativeX\13\n\9\9textureBufferPosX = overLapNegativeX +1\13\n\9\9posX = posX + overLapNegativeX\13\n\9\9resY = resY - overLapPrositiveY - overLapNegativeY\13\n\9\9textureBufferPosY = overLapNegativeY +1\13\n\9\9posY = posY + overLapNegativeY\13\n\9\9\13\n\9\9global.gpu.bitblt(renderArea:getBufferID(), math.floor(posX +.5), math.floor(posY +.5), math.floor(resX +.5), math.floor(resY +.5), this.texture.bufferID,  textureBufferPosY, textureBufferPosX)\13\n\9\9\13\n\9\9global.db.setBufferOnly(true)\13\n\9end\13\n\9\13\n\9if this.texture.format == \"pic\" and global.conf.useDoubleBuffering then\13\n\9\9global.db.setDrawLimit(area.posX, area.posY, area.posX + area.sizeX -1, area.posY + area.sizeY -1)\13\n\9\9\13\n\9\9global.db.drawImage(math.floor(this.posX + offsetX +.5), math.floor(this.posY + offsetY +.5), this.texture)\13\n\9\9\13\n\9\9global.db.resetDrawLimit()\13\n\9elseif this.texture.format == \"OCGLT\" and global.conf.useDoubleBuffering then\13\n\9\9global.oclrl:draw(this.posX + offsetX, this.posY + offsetY, this.texture, nil, {area.posX,  area.posX + area.sizeX -1, area.posY, area.posY + area.sizeY -1})\13\n\9end\13\n\9\13\n\9global.db.setBufferOnly(false)\13\nend\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\nreturn Sprite\13\n",["./data/core/luaConsole.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\n\13\nlocal luaShell = loadfile(\"libs/thirdParty/luaShell.lua\")(global)\13\nlocal lastAutoCompBase = \"\"\13\n\13\nglobal.tbConsole = global.ocui.TextBox.new(global.ocui, {x=1, y=0, sx=global.resX, sy=global.resY - (global.resY - global.conf.consoleSizeY), lineBreak = true, foregroundColor=0xcccccc, backgroundColor=0x333333, managed = {draw = false}})\13\n--global.setConsoleSize()\13\n\13\nglobal.tiConsole = global.ocui.TextInput.new(global.ocui, {x = 6, y = global.resY, s = global.resX -5, \13\n\9colors = {\13\n\9\0090xcccccc,\13\n\9\0090x333333,\13\n\9\0090xeeeeee,\13\n\9\0090x555555,\13\n\9},\13\n\9\13\n\9listedFunction = function(ti) \13\n\9\9global.print(\"[LUA]> \" .. ti.text)\13\n\9\9luaShell.textInput(ti.text)\13\n\9end,\13\n\9autoCompFunction = function(ti)\13\n\9\9if ti.autoCompBase ~= lastAutoCompBase then\13\n\9\9\9lastAutoCompBase = ti.autoCompBase\13\n\9\9\9ti.autoCompPos = 1\13\n\9\9\9\13\n\9\9\9local autoComp = luaShell.readHandler(ti.text, ti.cursorPosition + ti.stringPosition)\13\n\9\9\9\13\n\9\9\9if #autoComp == 1 then\13\n\9\9\9\9ti.autoCompBase = autoComp[1]\13\n\9\9\9\9lastAutoCompBase = ti.autoCompBase\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9ti.autoComplete = autoComp\13\n\9\9end\13\n\9end,\13\n})\13\n\13\nglobal.bConsolePlaceholder = global.ocui.Button.new(global.ocui, {x = 1, y = global.resY, sx = 0, sy = 0, texture0 = global.oclrl.generateTexture({\13\n\9{\"b\", 0x333333},\13\n\9{\"f\", 0xcccccc},\13\n\9{0, 0, \"lua> \"},\13\n})})\13\n\13\nglobal.mConsole = global.ocui.Menu.new(global.ocui, {x = 0, y = 0, managed = {update = false, draw = false}, c = {\13\n\9{global.tbConsole, 1, global.resY - global.conf.consoleSizeY}, \13\n\9{global.tiConsole, 6, global.resY}, \13\n\9{global.bConsolePlaceholder, 1,  global.resY},\13\n}})\13\n\13\n\13\n",["./data/core/nosGaCore.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--===== Requires =====--\13\nlocal global = ...\13\n\13\n--===== Variables =====--\13\nlocal orgPrint = print\13\nlocal frameCount = 0\13\nlocal lastFPSCheck = 0\13\nlocal dts = {}\13\n\13\nlocal xpcall = xpcall\13\n\13\n--===== Functions =====--\13\n\13\n_G.print = global.print\13\n\13\nlocal function run(func, ...)\13\n\9if func ~= nil then\13\n\9\9local suc, err = xpcall(func, debug.traceback, ...)\13\n\9\9if not suc then\13\n\9\9\9print(\"[ERROR][GE]: Tryed to call \" .. tostring(func) .. \":\")\13\n\9\9\9print(tostring(err))\13\n\9\9\9print(debug.traceback())\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function start()\13\n\9--[[\13\n\9global.gpu.setBackground(0x000000)\13\n\9global.gpu.clear()\13\n\9]]\13\n\9\13\n\9--global.clear()\13\n\9\13\n\9global.lastUptime = global.computer.uptime()\13\n\9\13\nend\13\n\13\nlocal function update()\13\n\9if frameCount >= global.conf.fpsCheckInterval then\13\n\9\9frameCount = 0\13\n\9end\13\n\9dts[frameCount] = global.dt\13\n\9local frameTimes = 0\13\n\9for i, c in pairs(dts) do\13\n\9\9frameTimes = frameTimes + c\13\n\9end\13\n\9frameCount = frameCount +1\13\n\9global.fps = 1 / (frameTimes / #dts)\13\n\13\n\9--global.core.re.draw() --needed here?\13\n\13\n\9--===== frame calculation =====--\13\n\9if global.state[global.currentState].update ~= nil then\9--manual check to avoid log spamming on missing update func.\13\n\9\9run(global.state[global.currentState].update, global.dt)\13\n\9end\13\n\9global.core.updateHandler.update()\13\n\13\n\9if not global.conf.useExperimentalRenderEngine then\13\n\9\9for ra in pairs(global.renderAreas) do\13\n\9\9\9global.core.re.calculateRenderArea(ra)\13\n\9\9\9ra:ngeCalculateNewRender()\13\n\9\9end\13\n\9end\13\n\9\13\nend\13\n\13\nlocal function draw()\13\n\9if global.state[global.currentState].draw ~= nil then\9--manual check to avoid log spamming on missing draw func.\13\n\9\9run(global.state[global.currentState].draw)\13\n\9end\13\n\13\n\9global.core.re.draw()\13\n\9\13\n\9if global.state[global.currentState].sUpdate ~= nil then\9--manual check to avoid log spamming on missing update func.\13\n\9\9run(global.state[global.currentState].sUpdate)\13\n\9end\13\n\9global.core.updateHandler.sUpdate()\13\n\9\13\n\9global.ocui:draw()\13\n\9\13\n\9global.debug.renderDebugInformations()\13\n\9if global.conf.showConsole then\13\n\9\9global.mConsole:draw()\13\n\9end\13\n\9\13\n\9if global.conf.useDoubleBuffering then\13\n\9\9if not global.conf.useExperimentalRenderEngine then\13\n\9\9\9global.core.re.executeCopyOrders()\13\n\9\9end\13\n\9\9global.gpu.drawChanges()\13\n\9end\13\nend\13\n\13\nlocal function progamEnd()\13\n\9global.core.eventHandler.stop()\13\n\9\13\n\9for _, s in pairs(global.state) do\13\n\9\9run(s.stop)\13\n\9end\13\n\9\13\n\9global.ocui:stop()\13\n\9global.tbConsole:draw()\13\n\9global.ocl.close()\13\nend\13\n\13\n--===== std program structure / main while =====--\13\nlocal std_previousScreenResolution = {global.gpu.getResolution()}\13\nlocal std_success = true\13\nlocal function std_onError(f, ...)\13\n\9print = orgPrint\13\n\9global.isRunning = false\13\n\9std_success = false\13\n\9global.gpu.setForeground(0xff0000)\13\n\9global.gpu.setBackground(0x000000)\13\n\9print(\"[FATAL] in func: \" .. f)\13\n\9print(...)\13\n\9global.gpu.setForeground(0xffffff)\13\n\9global.fatal(\"In func: \" .. tostring(f))\13\n\9global.fatal(...)\13\n\9global.tbConsole:draw()\13\n\9if global.conf.useDoubleBuffering then\13\n\9\9global.gpu.drawChanges()\13\n\9end\13\nend\13\n\13\nlocal s, m = xpcall(start, debug.traceback)\13\nif s == false then\13\n\9std_onError(\"start()\", m, debug.traceback())\13\nend\13\n\13\nwhile global.isRunning do\13\n\9local s, m = xpcall(update, debug.traceback)\13\n\9if s == false then\13\n\9\9std_onError(\"update()\", m, debug.traceback())\13\n\9\9break\13\n\9end\13\n\9\13\n\9if global.isRunning then\13\n\9\9local s, m = xpcall(draw, debug.traceback)\13\n\9\9if s == false then\13\n\9\9\9std_onError(\"draw()\", m, debug.traceback())\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9global.core.eventHandler.update()\13\n\9global.currentFrame = global.currentFrame +1\13\nend\13\n\13\nprogamEnd()\13\nglobal.gpu.setForeground(0xffffff)\13\nglobal.gpu.setBackground(0x000000)\13\nglobal.gpu.setResolution(std_previousScreenResolution[1], std_previousScreenResolution[2])\13\n_G.print = orgPrint\13\n\13\nreturn std_success, \"failed\"",["./data/core/RenderArea.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\n\13\n--====== local functions =====--\13\nlocal function print(...)\13\n\9if global.conf.debug.raDebug then\13\n\9\9global.debug.log(...)\13\n\9end\13\nend\13\n\13\n--===== class =====--\13\nlocal RenderArea = {}\13\nRenderArea.__index = RenderArea\13\n\13\nfunction RenderArea.init()\13\n\13\nend\13\n\13\nfunction RenderArea.new(args)\13\n\9args = args or {}\13\n\9local this = setmetatable({}, RenderArea)\13\n\9\13\n\9local pa = global.ut.parseArgs\13\n\9this.posX = pa(args.x, args.posX)\13\n\9this.posY = pa(args.y, args.posY)\13\n\9this.sizeX = pa(args.sx, args.sizeX, 0)\13\n\9this.sizeY = pa(args.sy, args.sizeY, 0)\13\n\9this.layer = pa(args.layer, global.conf.renderLayerAmount)\13\n\9this.silent = pa(args.silent, false) --if true the RA is not updating gameObjects.\13\n\9this.name = tostring(args.name)\13\n\9this.cameraPosX = pa(args.cx, args.cameraPosX, 0)\13\n\9this.cameraPosY = pa(args.cy, args.cameraPosY, 0)\13\n\9this.lastCameraPosX = this.cameraPosX\13\n\9this.lastCameraPosY = this.cameraPosY\13\n\9this.id = args.id\13\n\9this.layerBlacklist = pa(args.lbl, args.layerBlacklist, {})\13\n\9this.drawBorders = pa(args.drawBorders, false)\13\n\9this.borderColor = pa(args.borderColor, 0xFF69B4)\13\n\9this.narrowUpdateExpansion = pa(args.nue, args.narrowUpdateExpansion, global.conf.narrowUpdateExpansion)\13\n\9\13\n\9this.parent = args.parent\13\n\9this.gameObjects = {}\13\n\9this.gameObjectAttributes = {}\13\n\9this.toRender = {}\13\n\9this.toClear = {}\13\n\9this.toUpdate = {}\13\n\9--this.cameraMoveInstructions = {copy = {}, clear = {}, raw = {x = 0, y = 0}}\13\n\9this.cameraMoveInstructions = {copy = {}, clear = {}, raw = {x = 0, y = 0}}\13\n\9this.copyInstructions = {}\13\n\13\n\9this.sizeArray = {this.posX, this.posX + this.sizeX -1, this.posY, this.posY + this.sizeY -1}\13\n\9\13\n\9this.childs = {}\13\n\9\13\n\9this.visible = true\13\n\9\13\n\9if this.parent ~= nil then\13\n\9\9if this.parent.parent ~= nil then\13\n\9\9\9this.parent = this.parent.parent\13\n\9\9end\13\n\9\9\13\n\9\9this.gameObjects = this.parent.gameObjects\13\n\9\9this.parent.childs[this] = true\13\n\9\9for i, c in pairs(this.parent.gameObjectAttributes) do\13\n\9\9\9this.gameObjectAttributes[i] = c\13\n\9\9end\13\n\9\9\13\n\9\9this.narrowUpdateExpansion = this.parent.narrowUpdateExpansion\13\n\9end\13\n\9\13\n\9for i = 0, global.conf.renderLayerAmount do \13\n\9\9this.toRender[i] = {}\13\n\9\9this.toClear[i] = {}\13\n\9end\13\n\9\13\n\9--===== default functions =====--\13\n\9this.addGO = function(this, go, args)\13\n\9\9local path, goClass = global.ut.seperatePath(go)\13\n\9\9--local gameObject = global.gameObject\13\n\9\9\13\n\9\9for s in string.gmatch(tostring(path), \"[^/]+\") do\13\n\9\9\9global.gameObject = global.gameObject[s]\13\n\9\9end\13\n\9\9\13\n\9\9if global.gameObject[goClass] == nil then\13\n\9\9\9print(\"[RA/\" .. tostring(this.name) .. \"]: Failed to add gameObject: \\\"\" .. go .. \"\\\" (not found).\")\13\n\9\9else\13\n\9\9\9if this.parent ~= nil then\13\n\9\9\9\9return this.parent:addGO(go, args)\13\n\9\9\9else\13\n\9\9\9\9local id = #this.gameObjects +1\13\n\9\9\9\9local gameObject = nil\13\n\9\9\9\9\13\n\9\9\9\9print(\"[RA/\" .. tostring(this.name) .. \"]: Adding gameObject: \\\"\" .. go .. \"\\\" (#\" .. tostring(id) .. \").\")\13\n\9\9\9\9\13\n\9\9\9\9gameObject = global.gameObject[goClass].new(args)\13\n\9\9\9\9\13\n\9\9\9\9this.gameObjects[gameObject] = true\13\n\9\9\9\9\13\n\9\9\9\9gameObject.ngeAttributes.responsibleRenderAreas[this] = true\13\n\9\9\9\9this.gameObjectAttributes[gameObject] = {\13\n\9\9\9\9\9mustBeRendered = true,\13\n\9\9\9\9\9lastCalculatedFrame = 0,\13\n\9\9\9\9\9wasVisible,\13\n\9\9\9\9\9overlappingAreas = {},\13\n\9\9\9\9\9hasBeenRenderedOnce = false,\13\n\9\9\9\9}\13\n\9\9\9\9\13\n\9\9\9\9for c in pairs(this.childs) do\13\n\9\9\9\9\9gameObject.ngeAttributes.responsibleRenderAreas[c] = true\13\n\9\9\9\9\9c.gameObjectAttributes[gameObject] = {\13\n\9\9\9\9\9\9mustBeRendered = true,\13\n\9\9\9\9\9\9lastCalculatedFrame = 0,\13\n\9\9\9\9\9\9wasVisible,\13\n\9\9\9\9\9\9overlappingAreas = {},\13\n\9\9\9\9\9\9hasBeenRenderedOnce = false,\13\n\9\9\9\9\9}\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9--global.run(this.gameObjects[id].spawn)\13\n\9\9\9\9global.run(gameObject.ngeStart, gameObject)\13\n\9\9\9\9return gameObject\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9this.remGO = function(this, go, t)\13\n\9\9if go == nil then return false end\13\n\9\9\13\n\9\9if this.parent ~= nil then\13\n\9\9\9return this.parent:remGO(go, args)\13\n\9\9else\13\n\9\9\9print(\"[RA/\" .. tostring(this.name) .. \"]: Removing gameObject: \\\"\" .. go.ngeAttributes.name .. \"\\\" (#\" .. tostring(id) .. \").\")\13\n\9\9\9\13\n\9\9\9global.run(go.ngeStop, go)\13\n\9\9\9this.toRender[go.ngeAttributes.layer][go] = nil\9\9\9\13\n\9\9\9this.gameObjectAttributes[go] = nil\13\n\9\9\9\13\n\9\9\9go:ngeClear(this)\13\n\9\9\9global.core.re.checkOverlapping(this, go, go.ngeAttributes.layer)\13\n\9\9\9for c in pairs(this.childs) do\13\n\9\9\9\9c.gameObjectAttributes[go] = nil\13\n\9\9\9\9go:ngeClear(c)\13\n\9\9\9\9global.core.re.checkOverlapping(c, go, go.ngeAttributes.layer)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9this.gameObjects[go] = nil\13\n\9\9end\13\n\9end\13\n\9this.remAll = function(this)\13\n\9\9for go in pairs(this.gameObjects) do\13\n\9\9\9this:remGO(go)\13\n\9\9end\13\n\9end\13\n\9this.move = function(this, x, y)\13\n\9\9\13\n\9end\13\n\9this.moveTo = function(this, x, y)\13\n\9\9\13\n\9end\13\n\9this.moveCamera = function(this, x, y)\13\n\9\9local cmir = this.cameraMoveInstructions.raw\13\n\9\9cmir.x = cmir.x +x\13\n\9\9cmir.y = cmir.y -y\13\n\9end\13\n\9this.moveCameraTo = function(this, x, y)\13\n\9\9local cmir = this.cameraMoveInstructions.raw\13\n\9\9cmir.x = this.cameraPosX +x\13\n\9\9cmir.y = this.cameraPosY -y\13\n\9end\13\n\9\13\n\9this.rerenderAll = function(this)\13\n\9\9global.gpu.setBackground(global.backgroundColor)\13\n\9\9global.gpu.fill(this.posX, this.posY, this.sizeX, this.sizeY, \" \")\13\n\9\9\13\n\9\9for i, a in pairs(this.gameObjectAttributes) do\13\n\9\9\9a.mustBeRendered = true\13\n\9\9\9a.hasBeenRenderedOnce = false\13\n\9\9end\13\n\9end\13\n\9this.getFOV = function(this)\13\n\9\9local cmir = this.cameraMoveInstructions.raw\13\n\9\9return - this.cameraPosX + cmir.x, this.sizeX - this.cameraPosX + cmir.x, - this.cameraPosY + cmir.y, this.sizeY - this.cameraPosY + cmir.y\13\n\9end\13\n\9this.getFOVLegacy = function(this)\13\n\9\9return - this.cameraPosX, this.sizeX - this.cameraPosX, - this.cameraPosY, this.sizeY - this.cameraPosY\13\n\9end\13\n\9this.getLastFOV = function(this)\13\n\9\9return - this.lastCameraPosX, this.sizeX - this.lastCameraPosX, - this.lastCameraPosY, this.sizeY - this.lastCameraPosY\13\n\9end\13\n\9this.getRealFOV = function(this)\13\n\9\9return this.posX, this.posX + this.sizeX, this.posY, this.posY + this.sizeY\13\n\9end\13\n\9this.getPixelPos = function(this, x, y) --returns the renderArea pos from the screen pixel pos.\13\n\9\9return x - this.posX - this.cameraPosX, y - this.posY - this.cameraPosY\13\n\9end\13\n\9this.getGOPos = function(this, go) --returns the pos on the screen.\13\n\9\9return go.gameObject.posX + this.posX + this.cameraPosX, go.gameObject.posY + this.posY + this.cameraPosY\13\n\9end\13\n\9\13\n\9this.resetCMI = function(this)\13\n\9\9local cmi = this.cameraMoveInstructions\13\n\9\9local subPixelX = cmi.raw.x - math.floor(cmi.raw.x)\13\n\9\9local subPixelY = cmi.raw.y - math.floor(cmi.raw.y)\13\n\9\9\13\n\9\9this.cameraMoveInstructions = {copy = {}, clear = {}, raw = {x = subPixelX, y = subPixelY}}\13\n\9\9this.copyInstructions = {}\13\n\9end\13\n\9\13\n\9--===== engine functions =====--\13\n\9this.ngeStart = function(this) --parent func \13\n\9\9\13\n\9end\13\n\9this.ngeUpdate = function(this, RenderAreas, dt) --parent func\13\n\9\9\13\n\9end\13\n\9this.ngeCalculateNewRender = function(this) --parent func\13\n\9\9local cmi = this.cameraMoveInstructions\13\n\9\9local subPixelX = cmi.raw.x - math.floor(cmi.raw.x)\13\n\9\9local subPixelY = cmi.raw.y - math.floor(cmi.raw.y)\13\n\9\9cmi.raw.x = math.floor(cmi.raw.x)\13\n\9\9cmi.raw.y = math.floor(cmi.raw.y)\13\n\9\9\13\n\9\9if global.conf.useSmartCameraMove then\13\n\9\9\9--===== camera move calculation =====--\13\n\9\9\9if cmi.raw.x ~= 0 or cmi.raw.y ~= 0 then\13\n\9\9\9\9local fromX, toX, fromY, toY = this:getFOV()\13\n\9\9\9\9local fx, fy, sx, sy, tx, ty = 0, 0, 0, 0, -cmi.raw.x, -cmi.raw.y\13\n\9\9\9\9local newClearArea1, newClearArea2 = {0, this.posY, 0, this.sizeY}, {this.posX, 0, this.sizeX, 0}\13\n\9\9\9\9\13\n\9\9\9\9if cmi.raw.x >= 0 then\13\n\9\9\9\9\9fx = this.posX +cmi.raw.x\13\n\9\9\9\9\9sx = this.sizeX -cmi.raw.x\13\n\9\9\9\9\9newClearArea1[1] = this.posX + this.sizeX -cmi.raw.x\13\n\9\9\9\9\9newClearArea1[3] = cmi.raw.x\13\n\9\9\9\9else\13\n\9\9\9\9\9fx = this.posX\13\n\9\9\9\9\9sx = this.sizeX +cmi.raw.x\13\n\9\9\9\9\9newClearArea1[1] = this.posX\13\n\9\9\9\9\9newClearArea1[3] = -cmi.raw.x\13\n\9\9\9\9end\13\n\9\9\9\9if cmi.raw.y >= 0 then\13\n\9\9\9\9\9fy = this.posY +cmi.raw.y\13\n\9\9\9\9\9sy = this.sizeY -cmi.raw.y\13\n\9\9\9\9\9newClearArea2[2] = this.posY + this.sizeY -cmi.raw.y\13\n\9\9\9\9\9newClearArea2[4] = cmi.raw.y\13\n\9\9\9\9else\13\n\9\9\9\9\9fy = this.posY\13\n\9\9\9\9\9sy = this.sizeY +cmi.raw.y\13\n\9\9\9\9\9newClearArea2[2] = this.posY\13\n\9\9\9\9\9newClearArea2[4] = -cmi.raw.y\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9cmi.copy = {fx, fy, sx, sy, tx, ty}\13\n\9\9\9\9\13\n\9\9\9\9if cmi.raw.x ~= 0 then\13\n\9\9\9\9\9cmi.clear[1] = {newClearArea1[1], newClearArea1[2], newClearArea1[3], newClearArea1[4], \" \"}\13\n\9\9\9\9end\13\n\9\9\9\9if cmi.raw.y ~= 0 then\13\n\9\9\9\9\9cmi.clear[2] = {newClearArea2[1], newClearArea2[2], newClearArea2[3], newClearArea2[4], \" \"}\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9this.lastCameraPosX = this.cameraPosX\13\n\9\9\9\9this.lastCameraPosY = this.cameraPosY\13\n\9\9\9\9this.cameraPosX = this.cameraPosX + (-cmi.raw.x)\13\n\9\9\9\9this.cameraPosY = this.cameraPosY + (-cmi.raw.y)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9--===== new frame calculation =====--\13\n\9\9\9if #cmi.copy > 0 then\13\n\9\9\9\9local fromX, toX, fromY, toY = this:getFOV()\13\n\9\9\9\9local function addToDraw(go)\13\n\9\9\9\9\9if this.gameObjectAttributes[go].causedByOverlap then\13\n\9\9\9\9\9\9--this.gameObjectAttributes[go].needsFullRender = true\13\n\9\9\9\9\9\9--return\13\n\9\9\9\9\9end\13\n\9\9\9\9\9\13\n\9\9\9\9\9this.toRender[go.ngeAttributes.layer][go] = {}\13\n\9\9\9\9\9this.toRender[go.ngeAttributes.layer][go].realArea = this\13\n\9\9\9\9\9\13\n\9\9\9\9\9local function add(i)\13\n\9\9\9\9\9\9if cmi.clear[i] ~= nil then\13\n\9\9\9\9\9\9\9table.insert(this.toRender[go.ngeAttributes.layer][go], {\13\n\9\9\9\9\9\9\9\9posX = cmi.clear[i][1],\13\n\9\9\9\9\9\9\9\9posY = cmi.clear[i][2],\13\n\9\9\9\9\9\9\9\9sizeX = cmi.clear[i][3],\13\n\9\9\9\9\9\9\9\9sizeY = cmi.clear[i][4],\13\n\9\9\9\9\9\9\9\9getFOV = function()\13\n\9\9\9\9\9\9\9\9\9local fromX, toX, fromY, toY = this:getFOV()\13\n\9\9\9\9\9\9\9\9\9\13\n\9\9\9\9\9\9\9\9\9if i == 1 and cmi.copy[5] < 0 then\13\n\9\9\9\9\9\9\9\9\9\9fromX = fromX + this.sizeX - cmi.clear[i][3]\13\n\9\9\9\9\9\9\9\9\9elseif i == 1 and cmi.copy[5] > 0 then\13\n\9\9\9\9\9\9\9\9\9\9toX = fromX + cmi.clear[i][3]\13\n\9\9\9\9\9\9\9\9\9elseif i == 2 and cmi.copy[6] < 0 then\13\n\9\9\9\9\9\9\9\9\9\9fromY = fromY + this.sizeY - cmi.clear[i][4]\13\n\9\9\9\9\9\9\9\9\9elseif i == 2 and cmi.copy[6] > 0 then\13\n\9\9\9\9\9\9\9\9\9\9toY = fromY + cmi.clear[i][4]\13\n\9\9\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\9\9\9\13\n\9\9\9\9\9\9\9\9\9return fromX, toX, fromY, toY\13\n\9\9\9\9\9\9\9\9end,\13\n\9\9\9\9\9\9\9})\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9\9\13\n\9\9\9\9\9if cmi.clear[1] ~= nil then\13\n\9\9\9\9\9\9add(1)\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if cmi.clear[2] ~= nil then\13\n\9\9\9\9\9\9add(2)\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9\9local function isInsideArea(ra, go, i, leg)\13\n\9\9\9\9\9local x, y = go:getPos()\13\n\9\9\9\9\9local sx, sy = go.ngeAttributes.sizeX, go.ngeAttributes.sizeY\13\n\9\9\9\9\9--local fromX, toX, fromY, toY = ra:getFOV()\13\n\9\9\9\9\9\13\n\9\9\9\9\9local fromX, toX, fromY, toY = this:getFOVLegacy()\13\n\9\9\9\9\9if i == 1 and cmi.copy[5] < 0 then\13\n\9\9\9\9\9\9fromX = fromX + this.sizeX - cmi.clear[i][3]\13\n\9\9\9\9\9elseif i == 1 and cmi.copy[5] > 0 then\13\n\9\9\9\9\9\9toX = fromX + cmi.clear[i][3]\13\n\9\9\9\9\9elseif i == 2 and cmi.copy[6] < 0 then\13\n\9\9\9\9\9\9fromY = fromY + this.sizeY - cmi.clear[i][4]\13\n\9\9\9\9\9elseif i == 2 and cmi.copy[6] > 0 then\13\n\9\9\9\9\9\9toY = fromY + cmi.clear[i][4]\13\n\9\9\9\9\9end\13\n\9\9\9\9\9\13\n\9\9\9\9\9local function check(fromX, toX, fromY, toY)\13\n\9\9\9\9\9\9if x +sx > fromX and x < toX and y +sy > fromY and y < toY then\13\n\9\9\9\9\9\9\9return true\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9\9\13\n\9\9\9\9\9return check(fromX, toX, fromY, toY)\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9for go in pairs(this.gameObjects) do\13\n\9\9\9\9\9if go.ngeAttributes.isVisibleIn[this] then\13\n\9\9\9\9\9\9if cmi.clear[1] ~= nil and isInsideArea(this, go, 1) or cmi.clear[2] ~= nil and isInsideArea(this, go, 2) then\13\n\9\9\9\9\9\9\9addToDraw(go)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9cmi.raw.x = subPixelX\13\n\9\9\9cmi.raw.y = subPixelY\13\n\9\9elseif cmi.raw.x ~= 0 or cmi.raw.y ~= 0 then\13\n\9\9\9this.lastCameraPosX = this.cameraPosX\13\n\9\9\9this.lastCameraPosY = this.cameraPosY\13\n\9\9\9this.cameraPosX = this.cameraPosX + (-cmi.raw.x)\13\n\9\9\9this.cameraPosY = this.cameraPosY + (-cmi.raw.y)\13\n\9\9\9this:rerenderAll()\13\n\9\9end\13\n\9end\13\n\9this.ngeDraw = function(this) --parent func\13\n\9\9if this.drawBorders then\13\n\9\9\9--[[\13\n\9\9\9global.gpu.setBackground(this.borderColor)\13\n\9\9\9global.gpu.set(this.posX, this.posY -1, global.ut.fillString(\"\", this.sizeX -(this.sizeX/2) , \" \"))\13\n\9\9\9global.gpu.set(this.posX, this.posY + (this.sizeY), global.ut.fillString(\"\", this.sizeX-(this.sizeX/2), \" \"))\13\n\9\9\9global.gpu.set(this.posX -1, this.posY, global.ut.fillString(\"\", this.sizeY-(this.sizeY/2), \" \"), true)\13\n\9\9\9global.gpu.set(this.posX + (this.sizeX), this.posY, global.ut.fillString(\"\", this.sizeY-(this.sizeY/2), \" \"), true)\13\n\9\9\9]]\13\n\9\9\9\13\n\9\9\9global.gpu.setBackground(this.borderColor)\13\n\9\9\9global.gpu.set(this.posX, this.posY -1, global.ut.fillString(\"\", this.sizeX, \" \"))\13\n\9\9\9global.gpu.set(this.posX, this.posY + (this.sizeY), global.ut.fillString(\"\", this.sizeX, \" \"))\13\n\9\9\9global.gpu.set(this.posX -1, this.posY, global.ut.fillString(\"\", this.sizeY, \" \"), true)\13\n\9\9\9global.gpu.set(this.posX + (this.sizeX), this.posY, global.ut.fillString(\"\", this.sizeY, \" \"), true)\13\n\9\9\9\13\n\9\9end\13\n\9end\13\n\9this.ngeClear = function(this) --parent func\13\n\9\9\13\n\9end\13\n\9\13\n\9return this\13\nend\13\n\13\nreturn RenderArea",["./data/core/dataLoading.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--===== local variables =====--\13\nlocal args = ...\13\nlocal global = args.global\13\nlocal toLoad = args.toLoad\13\nlocal reload = args.reload\13\nlocal loadMods = args.loadMods\13\nlocal print = args.print or global.log\13\nlocal warn = args.warn or global.warn\13\nlocal error = args.error or global.error\13\n\13\nlocal baseDir = \"\"\13\n\13\n--===== local functions =====--\13\nlocal fprint\13\ndo \13\n\9local p = print\13\n\9fprint = function(...) p(...) end\13\nend\13\ndo \13\n\9local p = print\13\n\9print = function(...)\13\n\9\9if global.conf.debug.dlDebug then\13\n\9\9\9p(...)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function reloadFile(target, path, ...)\13\n\9local debugString = \"[DL]: Reloading file: \" .. path .. \": \"\13\n\9\13\n\9local suc, err = loadfile(path)\13\n\9if suc == nil then\13\n\9\9print(debugString .. tostring(err))\13\n\9else\13\n\9\9print(debugString .. tostring(suc))\13\n\9\9return suc(...)\13\n\9end\13\nend\13\n\13\nlocal function loadFiles(target, name, func, directPath, subDirs, structured, loadFunc, initFile)\13\n\9local path = baseDir .. name\13\n\9subDirs = global.ut.parseArgs(subDirs, true)\13\n\9\13\n\9if directPath then\13\n\9\9path = directPath\13\n\9end\13\n\9\13\n\9if global.alreadyLoaded[path] ~= true or reload then\13\n\9\9if global.alreadyLoaded[path] ~= true then\13\n\9\9\9print(\"[DL]: Loading data group: \" .. name .. \".\")\13\n\9\9elseif reload then\13\n\9\9\9print(\"[DL]: Reloading data group: \" .. name .. \".\")\13\n\9\9end\13\n\9\9global.loadData(target, path, func, {log = print, warn = warn, error = error}, reload, subDirs, structured, loadFunc, initFile)\13\n\9\9global.alreadyLoaded[path] = true\13\n\9\9return true\13\n\9else\13\n\9\9print(\"[DL]: Data group already loaded: \" .. name .. \".\")\13\n\9\9return false\13\n\9end\13\nend\13\n\13\n--===== init =====--\13\nlocal reloadString = \"\"\13\nfor i, c in pairs(toLoad) do\13\n\9if c then\13\n\9\9if #reloadString > 0 then\13\n\9\9\9reloadString = reloadString .. \", \" .. i\13\n\9\9else\13\n\9\9\9reloadString = reloadString .. i\13\n\9\9end\13\n\9end\13\nend\13\nif loadMods then\13\n\9fprint(\"[DL]: Loading mod data groups: \" .. reloadString .. \".\")\13\n\9baseDir = \"mods/\"\13\nelse\13\n\9fprint(\"[DL]: Loading data groups: \" .. reloadString .. \".\")\13\n\9baseDir = \"data/\"\13\nend\13\n\13\n\13\n\13\n--===== core reloadings =====--\13\nif toLoad.conf then\13\n\9local savedSettings = {\13\n\9\9showConsole = global.conf.showConsole,\13\n\9}\13\n\9\13\n\9global.conf = loadfile(\"nosGaConf.lua\")(global)\13\n\9\13\n\9for i, c in pairs(loadfile(\"conf.lua\")(global)) do\13\n\9\9global.conf[i] = c\13\n\9end\13\n\9\13\n\9global.controls = {c = {}, k = {}, m = {}}\13\n\9local controlsINI = global.LIP.load(\"controls.ini\")\13\n\9\13\n\9local function parseControls(toParse, target, convert)\13\n\9\9local function addEntry(t, i, e)\13\n\9\9\9if t[i] == nil then\13\n\9\9\9\9t[i] = {}\13\n\9\9\9end\13\n\9\9\9table.insert(t[i], e)\13\n\9\9end\13\n\9\9\13\n\9\9for i, c in pairs(toParse) do\13\n\9\9\9for s in string.gmatch(tostring(c), \"[^,]+\") do\13\n\9\9\9\9if convert then\13\n\9\9\9\9\9--addEntry(target, tonumber(string.byte(s)), i)\13\n\9\9\9\9\9addEntry(target, require(\"keyboard\").keys[s], i)\13\n\9\9\9\9else\13\n\9\9\9\9\9addEntry(target, tonumber(s), i)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9parseControls(controlsINI.code, global.controls.c)\13\n\9--parseControls(controlsINI.string, global.controls.c, true)\13\n\9parseControls(controlsINI.string, global.controls.k, true)\13\n\9parseControls(controlsINI.key, global.controls.k)\13\n\9parseControls(controlsINI.mouse, global.controls.m)\13\n\9\13\n\9for i, c in pairs(savedSettings) do\13\n\9\9global.conf[i] = c\13\n\9end\13\nend\13\n\13\nif toLoad.uh then\13\n\9global.core.updateHandler = reloadFile(global.core.updateHandler, \"data/core/updateHandler.lua\", global)\13\nend\13\n\13\nif toLoad.eh then\13\n\9global.core.eventHandler.stop()\13\n\9global.core.eventHandler = reloadFile(global.core.eventHandler, \"data/core/eventHandler.lua\", global)\13\nend\13\n\13\nif toLoad.dbgpu and global.conf.useDoubleBuffering then \13\n\9if global.conf.useExperimentalRenderEngine then\13\n\9\9global.gpu = reloadFile(global.gpu, \"libs/dbgpu_api.lua\", {path = \"libs/thirdParty\", directDraw = false, forceDraw = false, rawCopy = true, actualRawCopy = true, global = global})\13\n\9else\13\n\9\9global.gpu = reloadFile(global.gpu, \"libs/dbgpu_api.lua\", {path = \"libs/thirdParty\", directDraw = false, forceDraw = false, rawCopy = true, actualRawCopy = false})\13\n\9end\13\n\9global.oclrl.gpu = global.gpu\13\nend\13\nif toLoad.re then\13\n\9if global.conf.useExperimentalRenderEngine then\13\n\9\9global.core.re = reloadFile(global.core.re, \"data/core/re_experimental.lua\", global)\13\n\9\9global.run(global.core.re.init)\13\n\9else\13\n\9\9global.core.re = reloadFile(global.core.re, \"data/core/re.lua\", global)\13\n\9end\13\nend\13\nif toLoad.RenderArea then\13\n\9if global.conf.useExperimentalRenderEngine then\13\n\9\9global.core.RenderArea = reloadFile(global.core.RenderArea, \"data/core/RenderArea_experimental.lua\", global)\13\n\9else\13\n\9\9global.core.RenderArea = reloadFile(global.core.RenderArea, \"data/core/RenderArea.lua\", global)\13\n\9end\13\nend\13\nif toLoad.GameObject then\13\n\9if global.conf.useExperimentalRenderEngine then\13\n\9\9global.core.GameObject = reloadFile(global.core.GameObject, \"data/core/GameObject_experimental.lua\", global)\13\n\9else\13\n\9\9global.core.GameObject = reloadFile(global.core.GameObject, \"data/core/GameObject.lua\", global)\13\n\9end\13\nend\13\nif toLoad.Sprite then\13\n\9global.core.Sprite = reloadFile(global.core.Sprite, \"data/core/Sprite.lua\", global)\13\nend\13\nif toLoad.uiHandler or toLoad.gui then\13\n\9global.core.uiHandler = reloadFile(global.core.Sprite, \"data/core/uiHandler.lua\", global)\13\nend\13\n\13\n--===== asset loading =====--\13\nif toLoad.global then\13\n\9loadFiles(global, \"global\")\13\nend\13\nif toLoad.structuredGlobal or toLoad.globalStructured then\13\n\9loadFiles(global, \"globalStructured\", nil, nil, nil, true)\13\nend\13\nif toLoad.states then\13\n\9loadFiles(global.state, \"states\", nil, nil, nil, nil, nil, false)\13\nend\13\nif toLoad.textures then\13\n\9loadFiles(global.texture, \"textures\", nil, \"texturePacks/\" .. global.conf.texturePack .. \"/textures\", nil, true)\13\n\9--[[ --only needed in experimental render engine.\13\n\9if global.texturePack == nil or toLoad.reload then\13\n\9\9global.texturePack = dofile(\"texturePacks/\" .. global.conf.texturePack .. \"/info.lua\")\13\n\9end\13\n\9]]\13\nend\13\nif toLoad.animations then\13\n\9loadFiles(global.animation, \"animations\", nil, \"texturePacks/\" .. global.conf.texturePack .. \"/animations\", false, false, global.ocal.load)\13\nend\13\nif toLoad.parents then\13\n\9loadFiles(global.parent, \"parents\")\13\nend\13\nif toLoad.gameObjects then\13\n\9if loadFiles(global.gameObject, \"gameObjects\") then\13\n\9\9\13\n\9end\13\nend\13\nif toLoad.structuredGameObjects or toLoad.gameObjectsStructured then\13\n\9loadFiles(global.gameObject, \"gameObjectsStructured\", nil, nil, nil, true)\13\nend\13\n\13\n\13\nreturn true\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n",["./data/core/init.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal args = {...}\13\nlocal global = args[1]\13\n_G.ngeGlobal = global\13\n\13\n--===== dev =====--\13\nlocal orgRequire = require\13\nif global.conf.debug.isDev then\13\nlocal require = require\13\n\9require = function(s)\13\n\9\9if io.open(s .. \".lua\", \"r\") == nil then\13\n\9\9\9return orgRequire(s)\13\n\9\9else\13\n\9\9\9return dofile(s .. \".lua\")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal orgPrint = print\13\nlocal print = function(...)\13\n\9if global.conf.debug.isDev then\13\n\9\9orgPrint(...)\13\n\9end\13\nend\13\n\13\n--===== global vars =====--\13\n--global.tl = require(\"libs/tl\") --debug/testing\13\nglobal.fs = require(\"filesystem\")\13\nglobal.filesystem = global.fs\13\nglobal.shell = require(\"shell\")\13\nglobal.event = require(\"event\")\13\nglobal.term = require(\"term\")\13\nglobal.unicode = require(\"unicode\")\13\nglobal.ut = require(\"libs/UT\")\13\nglobal.ocl = require(\"libs/ocl\")\13\nglobal.computer = require(\"computer\")\13\nglobal.keyboard = require(\"keyboard\")\13\nglobal.serialization = require(\"serialization\")\13\nglobal.component = require(\"component\")\13\nglobal.realGPU = global.component.gpu\13\nglobal.LIP = require(\"libs/thirdParty/LIP\")\13\n\13\nprint(\"useDoubleBuffering: \" .. tostring(global.conf.useDoubleBuffering))\13\nif global.conf.useDoubleBuffering then\13\n\9if global.conf.useExperimentalRenderEngine then\13\n\9\9global.gpu = loadfile(\"libs/dbgpu_api.lua\")({path = \"libs/thirdParty\", directDraw = false, forceDraw = false, rawCopy = true, actualRawCopy = true, global = global})\13\n\9else\13\n\9\9global.gpu = loadfile(\"libs/dbgpu_api.lua\")({path = \"libs/thirdParty\", directDraw = false, forceDraw = false, rawCopy = true, actualRawCopy = false})\13\n\9end\13\nelse\13\n\9global.gpu = global.component.gpu\13\nend\13\n\13\nif global.conf.useDoubleBuffering then\13\n\9global.image = require(\"libs/thirdParty/image\")\13\n\9global.db = require(\"libs/thirdParty/DoubleBuffering\")\13\n\13\n\9package.loaded[\"libs/thirdParty/GUI\"] = nil\13\n\9global.gui = require(\"libs/thirdParty/GUI\")\13\nend\13\n\13\nglobal.oclrl = require(\"libs/oclrl\").initiate(global.gpu, {checkColor = true})\13\nglobal.ocal = require(\"libs/ocal\").initiate({oclrl = global.oclrl, db = global.db, libs = \"libs/thirdParty\"})\13\n--global.oclrl = require(\"oclrl\").initiate(global.gpu)\13\nglobal.ocui = require(\"libs/ocui\").initiate(global.oclrl)\13\nglobal.ocgf = require(\"libs/ocgf\").initiate({gpu = global.gpu, db = global.db, oclrl = global.oclrl, ocal = global.ocal})\13\n\13\nlocal func, err = loadfile(\"data/core/updateHandler.lua\")\13\nprint(\"[INIT]: Loading GE: \" .. tostring(func) .. \" \" .. tostring(err))\13\nglobal.core.updateHandler = func(global)\13\n\13\nif global.conf.useExperimentalRenderEngine then\13\n\9local func, err = loadfile(\"data/core/re_experimental.lua\")\13\n\9print(\"[INIT]: Loading RE: \" .. tostring(func) .. \" \" .. tostring(err))\13\n\9global.core.re = func(global)\13\nelse\13\n\9local func, err = loadfile(\"data/core/re.lua\")\13\n\9print(\"[INIT]: Loading legacy RE: \" .. tostring(func) .. \" \" .. tostring(err))\13\n\9global.core.re = func(global)\13\nend\13\nif global.conf.useExperimentalRenderEngine then\13\n\9local func, err = loadfile(\"data/core/RenderArea_experimental.lua\")\13\n\9print(\"[INIT]: Loading RenderArea: \" .. tostring(func) .. \" \" .. tostring(err))\13\n\9global.core.RenderArea = func(global)\13\nelse\13\n\9local func, err = loadfile(\"data/core/RenderArea.lua\")\13\n\9print(\"[INIT]: Loading legacy RenderArea: \" .. tostring(func) .. \" \" .. tostring(err))\13\n\9global.core.RenderArea = func(global)\13\nend\13\nif global.conf.useExperimentalRenderEngine then\13\n\9local func, err = loadfile(\"data/core/GameObject_experimental.lua\")\13\n\9print(\"[INIT]: Loading GameObject: \" .. tostring(func) .. \" \" .. tostring(err))\13\n\9global.core.GameObject = func(global)\13\nelse\13\n\9local func, err = loadfile(\"data/core/GameObject.lua\")\13\n\9print(\"[INIT]: Loading legacy GameObject: \" .. tostring(func) .. \" \" .. tostring(err))\13\n\9global.core.GameObject = func(global)\13\nend\13\nlocal func, err = loadfile(\"data/core/eventHandler.lua\")\13\nprint(\"[INIT]: Loading eventHandler: \" .. tostring(func) .. \" \" .. tostring(err))\13\nglobal.core.eventHandler = func(global)\13\n\13\nglobal.resX, global.resY = global.gpu.getResolution()\13\n\13\n--=== debug ===--\13\nglobal.ocl.open()\13\nlocal func, err = loadfile(\"data/core/luaConsole.lua\")\13\nprint(\"[INIT]: Loading luaConsole: \" .. tostring(func) .. \" \" .. tostring(err))\13\nfunc(global)\13\n\13\n--=== load data ===--\13\ndo --load global data.\13\n\9print(\"[INIT]: Loading global.\")\13\n\9global.loadData(global, \"/data/global\", nil, {log = print, warn = print, error = print})\13\n\9print(\"[INIT]: Loading states.\")\13\n\9global.loadData(global.state, \"/data/states\", nil, {log = print, warn = print, error = print})\13\n\13\n\9if global.state[global.conf.defaultState] == nil then\13\n\9\9local _, err = loadfile(\"data/states/\" .. global.conf.defaultState .. \".lua\")\13\n\9\9print(\"[INIT]: Default state cant be loaded: \" .. err)\13\n\9\9global.error(\"[INIT]: Default state cant be loaded: \" .. err)\13\n\9\9os.exit(1)\13\n\9end\13\nend\13\n\13\nif global.isDev then\13\n\9local func, err = loadfile(\"data/core/dataLoading.lua\")\13\n\9print(\"[INIT]: Check dataLoading: \" .. tostring(func) .. \" \" .. tostring(err))\13\nend\13\nglobal.load({\13\n\9toLoad = {\13\n\9\9conf = true,\13\n\9\9GameObject = true,\13\n\9\9RenderArea = true,\13\n\9\9Sprite = true,\13\n\9\9eh = true,\13\n\9\9structuredGlobal = true,\13\n\9\9uiHandler = true,\13\n\9},\13\n\9print = global.orgPrint,\13\n})\13\n\13\n--===== init engine =====--\13\nglobal.core.updateHandler.init()\13\nglobal.core.re.init()\13\n\13\nglobal.changeState(global.conf.defaultState)\13\n\13\n--====== init end ======--\13\nprint(\"[INIT]: Done.\")\13\nreturn true",["./data/core/"] = 0,["./data/global/nge/getButtonTexture.lua"] = "local global = ...\13\n\13\nreturn function(sx, sy, bc, fc, t)\13\n\9return global.oclrl.generateTexture({\13\n\9\9{\"f\", fc},\13\n\9\9{\"b\", bc},\13\n\9\9{0, 0, sx, sy, \" \"},\13\n\9\9{math.floor(sx / 2 - global.unicode.len(t) / 2), math.floor(sy / 2), t},\13\n\9})\13\nend",["./data/global/nge/globalDebuggingFunctions.lua"] = "local global = ...\13\n\13\nfunction gs()\13\n\9return global.getState()\13\nend",["./data/global/nge/splitTexture.lua"] = "--works with OCIF6\n\nlocal global = ...\n\nreturn function(orientation, texture, pos)\n    local split1, split2 = {format = \"pic\", 0, 0, {}, {}, {}, {}}, {format = \"pic\", 0, 0, {}, {}, {}, {}}\n    local resX, resY = texture[1], texture[2]\n    \n\n\n    if orientation == \"v\" then\n        if pos >= resX then\n            error(\"Split pos is >= vertical texture resolution.\", 2)\n        end\n\n        split1[1], split1[2] = pos, resY\n        split2[1], split2[2] = resX - pos, resY\n\n        local counter = 1\n\n        for y = 1, resY do\n            for x = 1, resX do\n                if x > resX then\n                    break\n                elseif x <= pos then\n                    table.insert(split1[3], texture[3][counter])\n                    table.insert(split1[4], texture[4][counter])\n                    table.insert(split1[5], texture[5][counter])\n                    table.insert(split1[6], texture[6][counter])\n                elseif x > pos then\n                    table.insert(split2[3], texture[3][counter])\n                    table.insert(split2[4], texture[4][counter])\n                    table.insert(split2[5], texture[5][counter])\n                    table.insert(split2[6], texture[6][counter])\n                else\n                    global.fatal(\"dafuq?!\")\n                end\n                counter = counter +1\n            end\n        end\n    elseif orientation == \"h\" then\n        if pos >= resX then\n            error(\"Split pos is >= horizontal texture resolution.\", 2)\n        end\n\n        split1[1], split1[2] = resX, pos\n        split2[1], split2[2] = resX, resY - pos\n\n        local counter = 1\n\n        for y = 1, resY do\n            for x = 1, resX do\n                if y > resY then\n                    break\n                elseif y <= pos then\n                    table.insert(split1[3], texture[3][counter])\n                    table.insert(split1[4], texture[4][counter])\n                    table.insert(split1[5], texture[5][counter])\n                    table.insert(split1[6], texture[6][counter])\n                elseif y > pos then\n                    table.insert(split2[3], texture[3][counter])\n                    table.insert(split2[4], texture[4][counter])\n                    table.insert(split2[5], texture[5][counter])\n                    table.insert(split2[6], texture[6][counter])\n                else\n                    global.fatal(\"dafuq?!\")\n                end\n                counter = counter +1\n            end\n        end\n    end\n\n    split1.resX, split1.resY = split1[1], split1[2]\n    split2.resX, split2.resY = split2[1], split2[2]\n\n    return split1, split2\n    --return texture\nend\n",["./data/global/nge/expandFunction.lua"] = "local global = ...\13\n\13\nreturn function(func1, func2)\13\n\9return function(...)\13\n\9\9func1(...)\13\n\9\9func2(...)\13\n\9end\13\nend",["./data/global/nge/getState.lua"] = "local global = ...\13\n\13\nreturn function()\13\n\9return global.state[global.currentState]\13\nend",["./data/global/nge/drawDebug.lua"] = "local global = ...\13\n\13\nreturn function(...)\13\n\9for _, s in pairs({...}) do\13\n\9\9global.debugString = global.debugString .. \" | \" .. s\13\n\9end\13\nend",["./data/global/nge/empty.lua"] = "local global = ...\13\n\13\nreturn function()\13\n\13\nend",["./data/global/nge/newGameObject.lua"] = "local global = ...\nreturn function(args)\n    return global.core.GameObject.new(args)\nend",["./data/global/nge/makeImageTransparent.lua"] = "local global = ...\13\n\13\nreturn function(image, color) --Probably only working with OCIF6 optimized dithering only using images.\13\n\9for i = 1, #image[3] do\13\n\9\9if image[3][i] == color and image[4][i] == color then\13\n\9\9\9image[5][i] = 2\13\n\9\9elseif image[3][i] == color then\13\n\9\9\9image[5][i] = 1\13\n\9\9elseif image[4][i] == color then\13\n\9\9\9local bc, fc = image[3][i], image[4][i]\13\n\9\9\9image[3][i], image[4][i] = fc, bc\13\n\9\9\9image[6][i] = \"\"\13\n\9\9\9image[5][i] = 1\13\n\9\9end\13\n\9end\13\n\9return image\13\nend",["./data/global/nge/dumpTable.lua"] = "local global = ...\13\n\13\nlocal function dumpTable(t, deep, sleepInterval) --Bug, ToDo: deep dumb is iterating itself!\13\n\9local s, count = \"\", 0\13\n\9for i, c in pairs(t) do\13\n\9\9s = s .. tostring(i) .. \" = \" .. tostring(c) .. \" | \"\13\n\9\9if deep then\13\n\9\9\9if type(c) == \"table\" then\13\n\9\9\9\9dumpTable(c, true, sleepInterval)\13\n\9\9\9end\13\n\9\9end\13\n\9\9count = count +1\13\n\9\9if sleepInterval ~= nil and sleepInterval ~= -1 and count > sleepInterval then\13\n\9\9\9os.sleep()\13\n\9\9\9count = 0\13\n\9\9end\13\n\9end\13\n\9return s\13\nend\13\n\13\nreturn dumpTable",["./data/global/nge/changeState.lua"] = "local global = ...\13\n\13\nreturn function(state)\13\n\9if global.state[state] == nil then\13\n\9\9global.fatal(\"[GE]: State not found: \\\"\" .. state .. \"\\\".\")\13\n\9else\13\n\9\9global.log(\"[GE]: Change state to: \\\"\" .. state .. \"\\\".\")\13\n\9\9if global.state[global.currentState] ~= nil then --To avoid crash at init phase.\13\n\9\9\9global.run(global.state[global.currentState].stop)\13\n\9\9end\13\n\9\9\13\n\9\9global.currentState = state\13\n\9\9\13\n\9\9if not global.state[state].isInitialized then\13\n\9\9\9local suc, err = global.run(global.state[state].init)\13\n\9\9\9global.log(suc)\13\n\9\9\9if not suc then\13\n\9\9\9\9global.fatal(\"Could not inizialize state:\\n\" .. tostring(err))\13\n\9\9\9end\13\n\13\n\9\9\9global.state[state].isInitialized = true\13\n\9\9end\13\n\9\9global.run(global.state[state].start)\13\n\9end\13\nend",["./data/global/nge/setActiveBuffer.lua"] = "local global = ...\13\n\13\nreturn function(id)\13\n\9global.warn(\"global.setActiveBuffer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\13\n\9if id == global.currentVBuffer then\13\n\9\9return false, \"Buffer is set already\"\13\n\9else\13\n\9\9local suc = global.realGPU.setActiveBuffer(id)\13\n\9\9if suc ~= nil then\13\n\9\9\9global.currentVBuffer = suc\13\n\9\9end\13\n\9\9return suc\13\n\9end\13\nend",["./data/global/nge/remRA.lua"] = "local global = ...\13\n\13\nreturn function(ra)\13\n\9print(\"[Global]: Removing renderArea: \" .. tostring(id) .. \"\\\"\" .. ra.name .. \"\\\".\")\13\n\9global.renderAreas[ra] = nil\13\nend",["./data/global/nge/addRA.lua"] = "local global = ...\13\n\13\nreturn function(args)\13\n\9local ra = global.core.RenderArea.new(args)\13\n\9global.renderAreas[ra] = true\13\n\9print(\"[Global]: Adding renderArea: \" .. tostring(id) .. \"\\\"\" .. args.name .. \"\\\".\")\13\n\9return ra\13\n\9\13\n\9--[[\13\n\9local id = #global.renderAreas +1\13\n\9args.id = id\13\n\9global.renderAreas[id] = global.core.RenderArea.new(args)\13\n\9print(\"[Global]: Adding renderArea: \" .. tostring(id) .. \"\\\"\" .. args.name .. \"\\\".\")\13\n\9return global.renderAreas[id]\13\n\9]]\13\nend",["./data/global/nge/clear.lua"] = "local global = ...\13\n\13\nreturn function()\13\n\9global.gpu.setBackground(global.backgroundColor)\13\n\9global.gpu.fill(1, 1, global.resX, global.resY, \" \")\13\n\9for ra in pairs(global.renderAreas) do\13\n\9\9ra:rerenderAll()\13\n\9end\13\n\9global.core.re.newDraw()\13\n\9if global.conf.useDoubleBuffering then\13\n\9\9global.gpu.drawChanges(true)\13\n\9end\13\nend",["./data/global/nge/"] = 0,["./data/global/"] = 0,["./data/globalStructured/sfx/explosion.lua"] = "local global = ...\13\n\13\nlocal function getForce(force, angle)\13\n\9local radians = -math.rad(angle)\13\n\9return math.cos(radians) * force, math.sin(radians) * force\13\nend\13\n\13\nreturn function(pc, x, y, particle, particleAmount, force, args, addedForceX, addedForceY)\13\n\9particleAmount = particleAmount * global.ut.parseArgs(global.conf.particles, 1)\13\n\9addedForceX = global.ut.parseArgs(addedForceX, 0)\13\n\9addedForceY = global.ut.parseArgs(addedForceY, 0)\13\n\9local angleSteps = 360 / particleAmount\13\n\9for c = 1, particleAmount do\13\n\9\9local fx, fy = getForce(force, angleSteps * c)\13\n\9\9local p = pc:addParticle(particle, x, y, args)\13\n\9\9p.gameObject:addForce(fx + addedForceX, fy + addedForceY)\13\n\9end\13\nend",["./data/globalStructured/sfx/"] = 0,["./data/globalStructured/.gitkeep"] = "",["./data/globalStructured/"] = 0,["./data/sf1/startGame.lua"] = "_G.gpuProxy = ...\n\nlocal shell = require(\"shell\")\nlocal currentWorkingDir = shell.getWorkingDirectory()\nshell.setWorkingDirectory(currentWorkingDir .. \"/data\")\n\n--_G.gpuProxy = loadfile(\"libs/dbgpu_api.lua\")({directDraw = false})\nlocal suc, err = xpcall(loadfile(\"game.lua\"), debug.traceback, true)\n\nif not suc then\n    print(err, debug.traceback())\nend\n\nshell.setWorkingDirectory(currentWorkingDir)",["./data/sf1/controls.ini"] = "# StreetFucker controls.\n# Only one key per action supported.\n\n[game]\nreset=r\nquit=q\n\n[player1]\nleft=a\nright=d\npunch= \n\n[player2]\nleft=j\nright=l\npunch=0",["./data/sf1/data/player.lua"] = "local Player = {}\13\n\13\nPlayer.left = nil\13\nPlayer.right = nil\13\nPlayer.punch = nil\13\n\13\nPlayer.posX = 0\13\nPlayer.posY = 13\13\n\13\nPlayer.life = 32\13\nPlayer.maxLife = 32\13\nPlayer.charge = 0\13\nPlayer.maxCharge = 32\13\n\13\nPlayer.oldPosX = Player.posX\13\nPlayer.oldPosY = Player.posY\13\n\13\nPlayer.keyboard = require(\"keyboard\")\13\n\13\nPlayer.looksLeft = false\13\nPlayer.isPunching = false\13\nPlayer.isCharging = false\13\n\13\nPlayer.face = 10\13\nPlayer.punchTime = 2\13\nPlayer.punchCount = 0\13\n\13\nPlayer.clearArm2 = false\13\nPlayer.clearArm3 = false\13\n\13\nfunction Player:Start()\13\n\13\nend\13\n\13\nfunction Player:Update()\13\n\9Player.oldPosX = Player.posX\13\n\9Player.oldPosX = Player.posX\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.right) and Player.isPunching == false then\13\n\9\9Player.posX = Player.posX +1\13\n\9\9Player.TurnAround(false)\13\n\9end\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.left) and Player.isPunching == false then\13\n\9\9Player.posX = Player.posX -1\13\n\9\9Player.TurnAround(true)\13\n\9end\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.punch) and Player.isPunching == false and Player.charge < Player.maxCharge then --Charge\13\n\9\9Player.isCharging = true\13\n\9\9if Player.charge < Player.maxCharge then\13\n\9\9\9Player.charge = Player.charge +2\13\n\9\9end\13\n\9elseif Player.isCharging then --Activate punch\13\n\9\9Player.isCharging = false\13\n\9\9Player.clearArm2 = true\13\n\9\9Player.isPunching = true\13\n\9end\13\n\9\13\n\9if Player.isPunching and Player.punchCount == Player.punchTime then --Reset punch\13\n\9\9Player.isPunching = false\13\n\9\9Player.clearArm3 = true\13\n\9\9Player.punchCount = 0\13\n\9\9Player.charge = 0\13\n\9elseif Player.isPunching then\13\n\9\9Player.punchCount = Player.punchCount +1\13\n\9end\13\n\13\n\9if Player.posX < -200 or Player.posX > 280 then\13\n\9\9SF1_isRunning = false\13\n\9end\13\nend\13\n\13\nfunction Player.TurnAround(lookLeft) \13\n\9if lookLeft then\13\n\9\9Player.looksLeft = true\13\n\9\9\13\n\9\9Player.body.aSet[Player.face][3] = \"o  \"\13\n\9\9Player.arm1.aSet = {\13\n\9\9\9[1] = {2, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9\9Player.arm2.aSet = {\13\n\9\9\9[1] = {4, 4, \"B\", 0x000000, 0xbbbb00},\13\n\9\9\9[2] = {6, 4, \"  \", 0x000000, 0x0000ff},\13\n\9\9}\13\n\9\9Player.arm3.aSet = {\13\n\9\9\9[2] = {-4, 3, \"     \", 0x000000, 0x0000ff},\13\n\9\9\9[3] = {-5, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9else\13\n\9\9Player.looksLeft = false\13\n\9\9\13\n\9\9Player.body.aSet[Player.face][3] = \"  o\"\13\n\9\9Player.arm1.aSet = {\13\n\9\9\9[1] = {4, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9\9Player.arm2.aSet = {\13\n\9\9\9[1] = {2, 4, \"B\", 0x000000, 0xbbbb00},\13\n\9\9\9[2] = {-1, 4, \"  \", 0x000000, 0x0000ff},\13\n\9\9}\13\n\9\9Player.arm3.aSet = {\13\n\9\9\9[2] = {6, 3, \"     \", 0x000000, 0x0000ff},\13\n\9\9\9[3] = {11, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9end\13\nend\13\n\13\nPlayer.body = {\13\n\9fillSize = 100,\13\n\9aFill = {\13\n\9\9[1] = {1, 3, 5, 3, \" \", 0x000000, 0x0000ff}, --Body\13\n\9\9\13\n\9\9[2] = {2, 7, 1, 3, \" \", 0x000000, 0x00aa00}, --Legs\13\n\9\9[3] = {4, 7, 1, 3, \" \"},\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 100,\13\n\9aSet = {\13\n\9\9[1] = {2, 1, \"   \", 0x000000, 0x7f2f11}, --Head\13\n\9\9--[2] = {} Payer2\13\n\9\9\13\n\9\9[10] = {2, 2, \"  o\", 0x000000, 0xbbbb00}, --Face\13\n\9\9\13\n\9\9[3] = {1, 6, \"     \", 0x000000, 0x00aa00}, --Leg\13\n\9\9\13\n\9\9[11] = {2, 9, \" \", 0x000000, 0x4f1f01}, --Shoe\13\n\9\9[12] = {4, 9, \" \"}, --Shoe\13\n\9\9\13\n\9},\13\n}\13\n\13\nPlayer.arm1 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 1,\13\n\9aSet = {\13\n\9\9[1] = {4, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9},\13\n}\13\n\13\nPlayer.arm2 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 2,\13\n\9aSet = {\13\n\9\9\13\n\9},\13\n}\13\n\13\nPlayer.arm3 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 3,\13\n\9aSet = {\13\n\9\9[2] = {6, 3, \"    \", 0x000000, 0x0000ff},\13\n\9\9[3] = {10, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9},\13\n}\13\n\13\n\13\nreturn Player\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n",["./data/sf1/data/background.lua"] = "local b = {}--Backgound\13\n\13\nb.street = {\13\n\9fillSize = 100,\13\n\9aFill = {\13\n\9\9[1] = {0, -17, 80, 25, \" \", 0x000000, 0x00509f},\13\n\9\9[2] = {0, 1, 80, 7, \" \", 0x000000, 0x666666},\13\n\9\9\13\n\9\9\13\n\9\9[9] = {5, -7, 7, 8, \" \", 0x00ff00, 0x777788},\13\n\9\9\13\n\9\9[11] = {22, -8, 2, 8, \" \", 0x00ff00, 0x878798},\13\n\9\9[12] = {39, -8, 2, 8, \" \"},\13\n\9\9[13] = {22, -9, 19, 7, \" \"},\13\n\9\9\13\n\9\9[14] = {24, -8, 15, 5, \"#\", 0xffe900, 0xdf00af},\13\n\9\9[15] = {6, -6, 5, 4, \"#\", 0x00dd00, 0xee0000},\13\n\9\9\13\n\9\9[16] = {46, -8, 1, 8, \" \", 0x00ff00, 0xb1bcdb},\13\n\9\9\13\n\9\9[17] = {53, -8, 2, 8, \"|\", 0x989bae, 0x9daac1},\13\n\9\9[18] = {55, -8, 27, 8, \" \", 0x989bae, 0x3581aa},\13\n\9\9[19] = {70, -8, 1, 8, \"|\", 0x989bae, 0x9daac1},\13\n\9\9\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 40,\13\n\9aSet = {\13\n\9\9--[10] = {0, -1, \"    |         |         |         |         |         |         |         |     \", 0x434343, 0x444444},\13\n\9\9[11] = {0, 8, \"       |         |         |         |         |         |         |         |  \", 0x434343, 0x444444},\13\n\9\9[12] = {0, 0, \"    |         |         |         |         |         |         |         |     \", 0x333333, 0x404040},\13\n\9\9[2] = {3, 4, \"        \", 0x000000, 0xbbbbbb},\13\n\9\9[3] = {22, 4, \"        \"},\13\n\9\9[4] = {41, 4, \"        \"},\13\n\9\9[5] = {60, 4, \"        \"},\13\n\9\9[6] = {79, 4, \" \"},\13\n\9\9\13\n\9\9[20] = {14, -3, \"\\\\    /\", 0x3f3f3f, 0x555555},\13\n\9\9[21] = {15, -2, \"IHHI\"},\13\n\9\9[22] = {15, -1, \"IHHI\"},\13\n\9\9\13\n\9\9[23] = {45, -9, \" # \", 0xaaaaaa, 0xcc2222},\13\n\9\9[24] = {44, -8, \" ### \", 0x555555, 0xdddddd},\13\n\9\9[25] = {45, -7, \" # \", 0xaaaaaa, 0x4455dd},\13\n\9\9\13\n\9\9[26] = {51, -9, \"/=vv===============v==========\", 0x989bae, 0x9daac1},\13\n\9\9\13\n\9\9[27] = {59, -2, \"                  \", 0x989bae, 0x4d310c},\13\n\9\9\13\n\9\9[28] = {61, -1, \" \", 0x989bae, 0x4c1501},\13\n\9\9[29] = {74, -1, \" \"},\13\n\9\9\13\n\9},\13\n}\13\n\13\nreturn b",["./data/sf1/data/deltaTime.lua"] = "local Delta = {}\13\nlocal computer = require(\"computer\")\13\n\13\nDelta.time = 0\13\nDelta.previousDeltaTime = 0\13\n\13\nfunction Delta:Set() \13\n\9Delta.time = os.difftime(computer.uptime(), Delta.previousDeltaTime)\13\n\9Delta.time = Delta.time / 70 * 1000\13\n\9Delta.previousDeltaTime = computer.uptime()\13\nend\13\n\13\n\13\nreturn Delta",["./data/sf1/data/libs/UT.lua"] = "--[[\13\n    UT Copyright (C) 2019-2020 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[UsefullThings libary\13\n\9\13\n]]\13\nlocal UT = {version = \"v0.7.2\"}\13\n\13\nfunction UT.parseArgs(...) --returns the first non nil parameter.\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction UT.seperatePath(path) --seperates a data path [\"./DIR/FILE.ENDING\"] into the dir path [\"./DIR/\"], the file name [\"FILE\"], and the file ending [\".ENDING\" or nil]\13\n\9if string.sub(path, #path) == \"/\" then\13\n\9\9return path\13\n\9end\13\n\9\13\n\9local dir, fileName, fileEnd = \"\", \"\", nil\13\n\9local tmpLatest = \"\"\13\n\9for s in string.gmatch(tostring(path), \"[^/]+\") do\13\n\9\9tmpLatest = s\13\n\9end\13\n\9dir = string.sub(path, 0, #path -#tmpLatest)\13\n\9for s in string.gmatch(tostring(tmpLatest), \"[^.]+\") do\13\n\9\9fileName = fileName .. s\13\n\9\9tmpLatest = s\13\n\9end\13\n\9if fileName == tmpLatest then\13\n\9\9fileName = tmpLatest\13\n\9else\13\n\9\9fileEnd = \".\" .. tmpLatest\13\n\9\9fileName = string.sub(fileName, 0, #fileName - #fileEnd +1)\13\n\9end\13\n\9\13\n\9return dir, fileName, fileEnd\13\nend\13\n\13\nfunction UT.getChars(s) --returns a array with the chars of the string.\13\n\9local chars = {}\13\n\9for c = 1, #s do\13\n\9\9chars[c] = string.sub(s, c, c)\13\n\9end\13\n\9return chars\13\nend\13\n\13\nfunction UT.makeString(c) --genetares a string from and array of chars/strings.\13\n\9local s = \"\"\13\n\9for c, v in ipairs(c) do\13\n\9\9s = s ..v\13\n\9end\13\n\9return s\13\nend\13\n\13\nfunction UT.inputCheck(m, c) --checks if a array (m) contains a value (c).\13\n\9for _, v in pairs(m) do\13\n\9\9if v == c then\13\n\9\9\9return true\13\n\9\9end\13\n\9end\13\n\9return false\13\nend\13\n\13\nfunction UT.fillString(s, amout, c) --fills a string (s) up with a (amout) of chars/strings (c).\13\n\9local s2 = s\13\n\9for c2 = 1, amout, 1 do\13\n\9\9s2 = s2 .. c\13\n\9end\13\n\9return s2\13\nend\13\n\13\n--[[Converts a table or an other variable type to a readable stirng.\13\n\9This is a modified \"Universal tostring\" routine from \"lua-users.org\".\13\n\9Original source code: <http://lua-users.org/wiki/TableSerialization>\13\n]]\13\nfunction UT.tostring(var, lineBreak, indent, done, internalRun) \13\n\9if internalRun == false or internalRun == nil then\13\n\9\9if type(var) == \"table\" then\13\n\9\9\9UT.tostring(var, lineBreak, indent, done, true)\13\n\9\9else\13\n\9\9\9return tostring(var)\13\n\9\9end\13\n\9end\13\n\9\13\n\9done = done or {}\13\n\9indent = indent or 2\13\n\9local lbString\13\n\9if lineBreak or lineBreak == nil then\13\n\9\9lbString = \"\\n\"\13\n\9\9lineBreak = true\13\n\9else\13\n\9\9lbString = \" \"\13\n\9end\13\n\9if type(var) == \"table\" then\13\n\9\9local sb = {}\13\n\9\9if not internalRun then\13\n\9\9\9table.insert(sb, \"{\" .. lbString)\13\n\9\9end\13\n\9\9for key, value in pairs (var) do\13\n\9\9\9if lineBreak then\13\n\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9end\13\n\9\9\9if type (value) == \"table\" and not done [value] then\13\n\9\9\9\9done [value] = true\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, \"[\" .. key .. \"] = {\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"[\" .. key .. \"] = {\");\13\n\9\9\9\9end\13\n\9\9\9\9table.insert(sb, UT.tostring(value, lineBreak, indent + 2, done, true))\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9\9\9table.insert(sb, \"},\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"},\");\13\n\9\9\9\9end\13\n\9\9\9elseif \"number\" == type(key) then\13\n\9\9\9\9table.insert(sb, string.format(\"[%s] = \", tostring(key)))\13\n\9\9\9\9table.insert(sb, string.format(\"\\\"%s\\\",\" .. lbString, tostring(value)))\13\n\9\9\9else\13\n\9\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9\9table.insert(sb, \" \")\13\n\9\9\9\9end\13\n\9\9\9\9table.insert(sb, string.format(\"%s = \\\"%s\\\",\" .. lbString, \"[\" .. tostring (key) .. \"]\", tostring(value)))\13\n\9\9\9end\13\n\9\9end\13\n\9\9if not internalRun then\13\n\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9table.insert(sb, \" }\")\13\n\9\9\9else\13\n\9\9\9\9table.insert(sb, \"}\")\13\n\9\9\9end\13\n\9\9end\13\n\9\9return table.concat(sb)\13\n\9else\13\n\9\9return var .. lbString\13\n\9end\13\nend\13\n\13\nreturn UT",["./data/sf1/data/libs/dbgpu_api.lua"] = "--[[\13\n\9!The api is not complete yet!\13\n\9\13\n\9This is a little api to make the DoubleBuffering libarry by IgorTimofeev acting like a normal OC gpu.\13\n\9\13\n\9With the default settings it is acting (nearly) exacly like a normal OC gpu (so its basicly useless).\13\n\9To get the full effect of the DoubleBuffering you should deactivate directDraw but then you manually need to use the drawChanges function.\13\n\9\13\n\9DoubleBuffering source: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n\9DoubleBuffering Copyright (c) 2018 Igor Timofeev\13\n\9\13\n\9dbgpu_api Copyright (c) 2019 NosPo Studio\13\n\9\13\n    dbgpu_api is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    dbgpu_api is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with dbgpu_api.  If not, see <https://www.gnu.org/licenses/>.\9\13\n]]\13\n\13\nlocal version = \"v0.3.1\"\13\n\13\nlocal args = ...\13\nlocal path = args.path or \"\"\13\n\13\nlocal buffer = require(path .. \"libs/DoubleBuffering\")\13\nlocal gpu = require(\"component\").gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal ut = require(\"libs/UT\")\13\n\13\nlocal lastBackground = gpu.getBackground()\13\nlocal lastForeground = gpu.getForeground()\13\n\13\nlocal currentVBuffer = 0\13\nlocal cpuBuffers = {}\13\n\13\nif gpu.getActiveBuffer then\13\n\9currentVBuffer = gpu.getActiveBuffer()\13\nend\13\n\13\nlocal function flushBuffer(id, w, h)\13\n\9cpuBuffers[id] = {\13\n\9\9drawLimit = {1, 1, w, h},\13\n\9\9current = {{}, {}, {}, w, h},\13\n\9\9new = {{}, {}, {}, w, h},\13\n\9}\13\n\9\13\n\9for y = 1, h do\13\n\9\9for x = 1, w do\13\n\9\9\9table.insert(cpuBuffers[id].current[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].current[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].current[3], \" \")\13\n\9\13\n\9\9\9table.insert(cpuBuffers[id].new[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].new[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].new[3], \" \")\13\n\9\9end\13\n\9end\13\nend\13\nlocal function setBuffer(id)\13\n\9cpuBuffers[currentVBuffer].drawLimit = {buffer.getDrawLimit()}\13\n\9\13\n\9buffer.setCurrentFrameTables(cpuBuffers[id].current[1], cpuBuffers[id].current[2], cpuBuffers[id].current[3], cpuBuffers[id].current[4], cpuBuffers[id].current[5])\13\n\9buffer.setNewFrameTables(cpuBuffers[id].new[1], cpuBuffers[id].new[2], cpuBuffers[id].new[3], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9buffer.setDrawLimit(cpuBuffers[id].drawLimit[1], cpuBuffers[id].drawLimit[2], cpuBuffers[id].drawLimit[3], cpuBuffers[id].drawLimit[4])\13\n\9\13\n\9currentVBuffer = id\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function getSubFunc(s)\13\n\9if #s ~= unicode.len(s) then\13\n\9\9return unicode.sub\13\n\9else\13\n\9\9return string.sub\13\n\9end\13\nend\13\n\13\nlocal dbgpu = {\13\n\9directDraw = parseArgs(args.directDraw, true),\13\n\9forceDraw = parseArgs(args.forceDraw, false),\13\n\9rawCopy = parseArgs(args.rawCopy, false),\13\n\9actualRawCopy = parseArgs(args.actualRawCopy, args.rawCopy),\13\n\9version = version,\13\n\9buffer = buffer,\13\n}\13\n\13\nlocal function draw()\13\n\9if dbgpu.directDraw then\13\n\9\9buffer.drawChanges(dbgpu.forceDraw)\13\n\9end\13\nend\13\n\13\nfunction dbgpu.set(x, y, s, v)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9if v then\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x, y +i -1, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9else\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x +i -1, y, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9end\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.fill(x, y, sx, sy, s)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9sx = math.floor(sx)\13\n\9sy = math.floor(sy)\13\n\9s = sub(s, 0, 1)\13\n\9buffer.drawRectangle(x, y, sx, sy, lastBackground, lastForeground, s)\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.copy(x, y, sx, sy, tx, ty)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9tx = math.floor(tx)\13\n\9ty = math.floor(ty)\13\n\9\13\n\9if sx * sy > 3200 then\13\n\9\9buffer.directCopy(x, y, sx, sy, tx +x, ty +y, dbgpu.rawCopy)\13\n\9else\13\n\9\9local data, rawData = buffer.copy(x, y, sx, sy, dbgpu.rawCopy)\13\n\9\9buffer.paste(tx +x, ty +y, data, rawData)\13\n\9end\13\n\9\13\n\9if dbgpu.rawCopy and dbgpu.actualRawCopy then\9\9\13\n\9\9gpu.copy(x, y, sx, sy, tx, ty)\13\n\9end\9\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.getBackground()\13\n\9return lastBackground\13\nend\13\nfunction dbgpu.getForeground()\13\n\9return lastForeground\13\nend\13\n\13\nfunction dbgpu.setBackground(c)\13\n\9lastBackground = c\13\n\9--return gpu.setBackground(c)\13\nend\13\nfunction dbgpu.setForeground(c)\13\n\9lastForeground = c\13\n\9--return gpu.setForeground(c)\13\nend\13\n\13\nfunction dbgpu.setResolution(x, y)\13\n\9buffer.setResolution(x, y)\13\nend\13\nfunction dbgpu.getResolution()\13\n\9return buffer.getResolution()\13\nend\13\n\13\nfunction dbgpu.drawChanges(f)\13\n\9buffer.drawChanges(f)\13\nend\13\n\13\nfunction dbgpu.drawImage(x, y, image)\13\n\9buffer.drawImage(x, y, image)\13\nend\13\n\13\nfunction dbgpu.getActiveBuffer()\13\n\9return currentVBuffer\13\nend\13\nfunction dbgpu.setActiveBuffer(id, force)\13\n\9if id == currentVBuffer or force then\13\n\9\9return false, \"Buffer is set already\"\13\n\9else\13\n\9\9local suc = gpu.setActiveBuffer(id)\13\n\9\9\13\n\9\9if suc ~= nil then\13\n\9\9\9\13\n\9\9\9setBuffer(id)\13\n\9\9\9\13\n\9\9\9do\13\n\9\9\9\9local b = buffer.getNewFrameTables()\13\n\9\9\9\9local b2 = cpuBuffers[id].new[1]\13\n\9\9\9\9\13\n\9\9\9\9--print(b, b2, b == b2)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9--print(\"T\", id)\13\n\9\9\9--print(cpuBuffers[0], cpuBuffers[1])\13\n\9\9\9--print(#cpuBuffers[0].new[1], #cpuBuffers[1].new[1], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9\9end\13\n\9\9return id\13\n\9end\13\nend\13\n--debug/dbgpuVBufferTest.lua > logs/test.log\13\nfunction dbgpu.allocateBuffer(w, h)\13\n\9local id = gpu.allocateBuffer(w, h)\13\n\9if type(id) == \"number\" then\13\n\9\9flushBuffer(id, w, h)\13\n\9end\13\n\9return id\13\nend\13\nfunction dbgpu.freeBuffer(id)\13\n\9cpuBuffers[id] = nil\13\n\9return gpu.freeBuffer(id)\13\nend\13\nfunction dbgpu.bitblt(...)\13\n\9return gpu.bitblt(...)\13\nend\13\nfunction dbgpu.freeAllBuffers()\13\n\9currentVBuffer = 0\13\n\9return gpu.freeAllBuffers()\13\nend\13\n\13\n--===== init =====--\13\nlocal resX, resY = gpu.getResolution()\13\nflushBuffer(0, resX, resY)\13\nsetBuffer(0)\13\n\13\n--dbgpu = setmetatable(dbgpu, {__index = gpu})\13\n--maxResolution\13\n--maxResolution\13\n\13\nreturn dbgpu",["./data/sf1/data/libs/LIP.lua"] = "--[[\13\n\9Copyright (c) 2012 Carreras Nicolas\13\n\9\13\n\9Permission is hereby granted, free of charge, to any person obtaining a copy\13\n\9of this software and associated documentation files (the \"Software\"), to deal\13\n\9in the Software without restriction, including without limitation the rights\13\n\9to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\n\9copies of the Software, and to permit persons to whom the Software is\13\n\9furnished to do so, subject to the following conditions:\13\n\9\13\n\9The above copyright notice and this permission notice shall be included in all\13\n\9copies or substantial portions of the Software.\13\n\9\13\n\9THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\n\9IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\n\9FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\n\9AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\n\9LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\n\9OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\n\9SOFTWARE.\13\n--]]\13\n--- Lua INI Parser.\13\n-- It has never been that simple to use INI files with Lua.\13\n--@author Dynodzzo\13\n\13\nlocal LIP = {};\13\n\13\n--- Returns a table containing all the data from the INI file.\13\n--@param fileName The name of the INI file to parse. [string]\13\n--@return The table containing all data from the INI file. [table]\13\nfunction LIP.load(fileName)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9local file = assert(io.open(fileName, 'r'), 'Error loading file : ' .. fileName);\13\n\9local data = {};\13\n\9local section;\13\n\9for line in file:lines() do\13\n\9\9local tempSection = line:match('^%[([^%[%]]+)%]$');\13\n\9\9if(tempSection)then\13\n\9\9\9section = tonumber(tempSection) and tonumber(tempSection) or tempSection;\13\n\9\9\9data[section] = data[section] or {};\13\n\9\9end\13\n\9\9local param, value = line:match('^([%w|_]+)%s-=%s-(.+)$');\13\n\9\9if(param and value ~= nil)then\13\n\9\9\9if(tonumber(value))then\13\n\9\9\9\9value = tonumber(value);\13\n\9\9\9elseif(value == 'true')then\13\n\9\9\9\9value = true;\13\n\9\9\9elseif(value == 'false')then\13\n\9\9\9\9value = false;\13\n\9\9\9end\13\n\9\9\9if(tonumber(param))then\13\n\9\9\9\9param = tonumber(param);\13\n\9\9\9end\13\n\9\9\9data[section][param] = value;\13\n\9\9end\13\n\9end\13\n\9file:close();\13\n\9return data;\13\nend\13\n\13\n--- Saves all the data from a table to an INI file.\13\n--@param fileName The name of the INI file to fill. [string]\13\n--@param data The table containing all the data to store. [table]\13\nfunction LIP.save(fileName, data)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9assert(type(data) == 'table', 'Parameter \"data\" must be a table.');\13\n\9local file = assert(io.open(fileName, 'w+b'), 'Error loading file :' .. fileName);\13\n\9local contents = '';\13\n\9for section, param in pairs(data) do\13\n\9\9contents = contents .. ('[%s]\\n'):format(section);\13\n\9\9for key, value in pairs(param) do\13\n\9\9\9contents = contents .. ('%s=%s\\n'):format(key, tostring(value));\13\n\9\9end\13\n\9\9contents = contents .. '\\n';\13\n\9end\13\n\9file:write(contents);\13\n\9file:close();\13\nend\13\n\13\nreturn LIP;",["./data/sf1/data/libs/DoubleBuffering.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are made some changes to provide the best possible performance in combination with the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (NosPo version) Copyright (c) 2019-2020 NosPo Studio\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\nlocal version = \"v0.8\" --NosPo version.\13\n\13\nlocal component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\nlocal color = require(\"libs/color\")\13\n--local image = require(\"libs/image\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal bufferWidth, bufferHeight\13\nlocal currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nlocal drawLimitX1, drawLimitX2, drawLimitY1, drawLimitY2\13\nlocal GPUProxy, GPUProxyGetResolution, GPUProxySetResolution, GPUProxyBind, GPUProxyGetBackground, GPUProxyGetForeground, GPUProxySetBackground, GPUProxySetForeground, GPUProxyGet, GPUProxySet, GPUProxyFill\13\n\13\nlocal mathCeil, mathFloor, mathModf, mathAbs = math.ceil, math.floor, math.modf, math.abs\13\nlocal tableInsert, tableConcat = table.insert, table.concat\13\nlocal colorBlend = color.blend\13\nlocal unicodeLen, unicodeSub = unicode.len, unicode.sub\13\n\13\nlocal drawAreas, nonDrawAreas = {}, {} --drawAreas == pixelWhiteList, nonDrawAreas == pixelBlackList\13\nlocal drawAreasAreWhitelist = true\13\nlocal drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nlocal bufferOnly = false\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getIndex(x, y)\13\n\9return bufferWidth * (y - 1) + x\13\nend\13\nlocal function getCoordinates(index)\13\n\9return index % bufferWidth, math.floor(index / bufferWidth) +1\13\nend\13\n\13\nlocal function getCurrentFrameTables()\13\n\9return currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function getNewFrameTables()\13\n\9return newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function setCurrentFrameTables(b, f, s, w, h)\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\nlocal function setNewFrameTables(b, f, s, w, h)\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\n\13\nlocal function setBufferOnly(b)\13\n\9bufferOnly = b\13\nend\13\nlocal function getBufferOnly()\13\n\9return bufferOnly\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function setDrawLimit(x1, y1, x2, y2)\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = x1, y1, x2, y2\13\nend\13\n\13\nlocal function resetDrawLimit()\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = 1, 1, bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getDrawLimit()\13\n\9return drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2\13\nend\13\n\13\nlocal function setDrawAreas(areas)\13\n\9drawAreas = areas\13\nend\13\nlocal function resetDrawAreas()\13\n\9drawAreas = {}\13\nend\13\nlocal function getDrawAreas()\13\n\9return drawAreas\13\nend\13\nlocal function setNonDrawAreas(areas)\13\n\9nonDrawAreas = areas\13\nend\13\nlocal function resetNonDrawAreas()\13\n\9nonDrawAreas = {}\13\nend\13\nlocal function getNonDrawAreas()\13\n\9return nonDrawAreas\13\nend\13\n\13\nlocal function setDrawAreaOffset(x, y)\13\n\9drawAreaOffsetX = x or drawAreaOffsetX\13\n\9drawAreaOffsetY = y or drawAreaOffsetY\13\n\9\13\nend\13\nlocal function getDrawAreaOffset()\13\n\9return drawAreaOffsetX, drawAreaOffsetY\13\nend\13\nlocal function resetDrawAreaOffset()\13\n\9drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nend\13\n\13\nlocal function isDrawable(x, y)\13\n\9local drawable = true\13\n\9\13\n\9if #drawAreas == 0 and #nonDrawAreas == 0 then\13\n\9\9--return true\13\n\9end\13\n\9\13\n\9for _, a in pairs(drawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = true\13\n\9\9\9break\13\n\9\9end\13\n\9\9drawable = false\13\n\9end\13\n\9for _, a in pairs(nonDrawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = false\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9return drawable\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function flush(width, height)\13\n\9if not width or not height then\13\n\9\9width, height = GPUProxyGetResolution()\13\n\9end\13\n\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = {}, {}, {}, {}, {}, {}\13\n\9bufferWidth = width\13\n\9bufferHeight = height\13\n\9resetDrawLimit()\13\n\13\n\9for y = 1, bufferHeight do\13\n\9\9for x = 1, bufferWidth do\13\n\9\9\9tableInsert(currentFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(currentFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(currentFrameSymbols, \" \")\13\n\13\n\9\9\9tableInsert(newFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(newFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(newFrameSymbols, \" \")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function setResolution(width, height)\13\n\9GPUProxySetResolution(width, height)\13\n\9flush(width, height)\13\nend\13\n\13\nlocal function getResolution()\13\n\9return bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getWidth()\13\n\9return bufferWidth\13\nend\13\n\13\nlocal function getHeight()\13\n\9return bufferHeight\13\nend\13\n\13\nlocal function bindScreen(...)\13\n\9GPUProxyBind(...)\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\nlocal function getGPUProxy()\13\n\9return GPUProxy\13\nend\13\n\13\nlocal function updateGPUProxyMethods()\13\n\9GPUProxyGet = GPUProxy.get\13\n\9GPUProxyGetResolution = GPUProxy.getResolution\13\n\9GPUProxyGetBackground = GPUProxy.getBackground\13\n\9GPUProxyGetForeground = GPUProxy.getForeground\13\n\13\n\9GPUProxySet = GPUProxy.set\13\n\9GPUProxySetResolution = GPUProxy.setResolution\13\n\9GPUProxySetBackground = GPUProxy.setBackground\13\n\9GPUProxySetForeground = GPUProxy.setForeground\13\n\13\n\9GPUProxyBind = GPUProxy.bind\13\n\9GPUProxyFill = GPUProxy.fill\13\nend\13\n\13\nlocal function bindGPU(address)\13\n\9GPUProxy = component.proxy(address)\13\n\9updateGPUProxyMethods()\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function rawSet(index, background, foreground, symbol)\13\n\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9if bufferOnly then\13\n\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9end\13\nend\13\n\13\nlocal function rawGet(index)\13\n\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\nend\13\n\13\nlocal function get(x, y)\13\n\9if x >= 1 and y >= 1 and x <= bufferWidth and y <= bufferHeight then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9else\13\n\9\9return 0x000000, 0x000000, \" \"\13\n\9end\13\nend\13\n\13\nlocal function set(x, y, background, foreground, symbol)\13\n\9if x >= drawLimitX1 and y >= drawLimitY1 and x <= drawLimitX2 and y <= drawLimitY2 and isDrawable(x, y) then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9if bufferOnly then\13\n\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawRectangle(x, y, width, height, background, foreground, symbol, transparency) \13\n\9local index, indexStepOnReachOfSquareWidth = bufferWidth * (y - 1) + x, bufferWidth - width\13\n\9for j = y, y + height - 1 do\13\n\9\9if j >= drawLimitY1 and j <= drawLimitY2 then\13\n\9\9\9for i = x, x + width - 1 do\13\n\9\9\9\9if i >= drawLimitX1 and i <= drawLimitX2 and isDrawable(i, j) then\13\n\9\9\9\9\9if transparency then\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9colorBlend(newFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9colorBlend(newFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9index = index + 1\13\n\9\9\9end\13\n\13\n\9\9\9index = index + indexStepOnReachOfSquareWidth\13\n\9\9else\13\n\9\9\9index = index + bufferWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clear(color, transparency)\13\n\9drawRectangle(1, 1, bufferWidth, bufferHeight, color or 0x0, 0x000000, \" \", transparency)\13\nend\13\n\13\nlocal function copy(x, y, width, height, current)\13\n\9local copyArray, index = { width, height }\13\n\9local rawCopyArray = { width, height }\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, newFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameSymbols[index])\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameForegrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameSymbols[index])\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, \" \")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return copyArray, rawCopyArray\13\nend\13\n\13\nlocal function paste(startX, startY, picture, currentPicture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\9\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9newFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9\9if currentPicture ~= nil then\13\n\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = currentPicture[pictureIndex]\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = currentPicture[pictureIndex + 1]\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = currentPicture[pictureIndex + 2]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function copyCurrent(x, y, width, height)\13\n\9local copyArray, index = { width, height }\13\n\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameSymbols[index])\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return copyArray\13\nend\13\n\13\nlocal function pasteCurrent(startX, startY, picture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9currentFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function directCopy(x, y, width, height, tx, ty, current, actualBuffer)\13\n\9local index\13\n\9local imageWidth = width\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (ty - 1) + tx, 3, bufferWidth - imageWidth\13\n\9\13\n\9local newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols\13\n\9\13\n\9if actualBuffer then\13\n\9\9newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9else\13\n\9\9newBackgrounds, newForegrounds, newSymbols = {table.unpack(newFrameBackgrounds)}, {table.unpack(newFrameForegrounds)}, {table.unpack(newFrameSymbols)}\13\n\9\13\n\9\13\n\9\9if current or bufferOnly then\13\n\9\9\9currentBackgrounds, currentForegrounds, currentSymbols = {table.unpack(currentFrameBackgrounds)}, {table.unpack(currentFrameForegrounds)}, {table.unpack(currentFrameSymbols)}\13\n\9\9end\13\n\9end\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9local newX, newY = getCoordinates(bufferIndex)\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(ewX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9newForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9newSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = currentFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = currentFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = currentFrameSymbols[index]\13\n\9\9\9\9\9\9--[[\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\9]]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(newX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9--[[\13\n\9\9\9\9\9newBackgrounds[newIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[newIndex] = 0x0\13\n\9\9\9\9\9newSymbols[newIndex] = \" \"\13\n\9\9\9\9\9]]\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9end\13\n\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9end\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = newBackgrounds, newForegrounds, newSymbols\13\n\9if current or bufferOnly then\13\n\9\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols = currentBackgrounds, currentForegrounds, currentSymbols\13\n\9end\13\nend\13\n\13\nlocal function rasterizeLine(x1, y1, x2, y2, method)\13\n\9local inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = x1, x2, y1, y2, false, mathAbs(x2 - x1), mathAbs(y2 - y1)\13\n\9if inLoopValueDelta < outLoopValueDelta then\13\n\9\9inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = y1, y2, x1, x2, true, outLoopValueDelta, inLoopValueDelta\13\n\9end\13\n\13\n\9if outLoopValueFrom > outLoopValueTo then\13\n\9\9outLoopValueFrom, outLoopValueTo = outLoopValueTo, outLoopValueFrom\13\n\9\9inLoopValueFrom, inLoopValueTo = inLoopValueTo, inLoopValueFrom\13\n\9end\13\n\13\n\9local outLoopValue, outLoopValueCounter, outLoopValueTriggerIncrement = outLoopValueFrom, 1, inLoopValueDelta / outLoopValueDelta\13\n\9local outLoopValueTrigger = outLoopValueTriggerIncrement\13\n\9for inLoopValue = inLoopValueFrom, inLoopValueTo, inLoopValueFrom < inLoopValueTo and 1 or -1 do\13\n\9\9if isReversed then\13\n\9\9\9method(outLoopValue, inLoopValue)\13\n\9\9else\13\n\9\9\9method(inLoopValue, outLoopValue)\13\n\9\9end\13\n\13\n\9\9outLoopValueCounter = outLoopValueCounter + 1\13\n\9\9if outLoopValueCounter > outLoopValueTrigger then\13\n\9\9\9outLoopValue, outLoopValueTrigger = outLoopValue + 1, outLoopValueTrigger + outLoopValueTriggerIncrement\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function rasterizeEllipse(centerX, centerY, radiusX, radiusY, method)\13\n\9local function rasterizeEllipsePoints(XP, YP)\13\n\9\9method(centerX + XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY - YP)\13\n\9\9method(centerX + XP, centerY - YP) \13\n\9end\13\n\13\n\9local x, y, changeX, changeY, ellipseError, twoASquare, twoBSquare = radiusX, 0, radiusY * radiusY * (1 - 2 * radiusX), radiusX * radiusX, 0, 2 * radiusX * radiusX, 2 * radiusY * radiusY\13\n\9local stoppingX, stoppingY = twoBSquare * radiusX, 0\13\n\13\n\9while stoppingX >= stoppingY do\13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9y, stoppingY, ellipseError = y + 1, stoppingY + twoASquare, ellipseError + changeY\13\n\9\9changeY = changeY + twoASquare\13\n\13\n\9\9if (2 * ellipseError + changeX) > 0 then\13\n\9\9\9x, stoppingX, ellipseError = x - 1, stoppingX - twoBSquare, ellipseError + changeX\13\n\9\9\9changeX = changeX + twoBSquare\13\n\9\9end\13\n\9end\13\n\13\n\9x, y, changeX, changeY, ellipseError, stoppingX, stoppingY = 0, radiusY, radiusY * radiusY, radiusX * radiusX * (1 - 2 * radiusY), 0, 0, twoASquare * radiusY\13\n\13\n\9while stoppingX <= stoppingY do \13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9x, stoppingX, ellipseError = x + 1, stoppingX + twoBSquare, ellipseError + changeX\13\n\9\9changeX = changeX + twoBSquare\13\n\9\9\13\n\9\9if (2 * ellipseError + changeY) > 0 then\13\n\9\9\9y, stoppingY, ellipseError = y - 1, stoppingY - twoASquare, ellipseError + changeY\13\n\9\9\9changeY = changeY + twoASquare\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawLine(x1, y1, x2, y2, background, foreground, symbol)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawEllipse(centerX, centerY, radiusX, radiusY, background, foreground, symbol)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawText(x, y, textColor, data, transparency)\13\n\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9local charIndex, bufferIndex = 1, bufferWidth * (y - 1) + x\13\n\9\9\13\n\9\9for charIndex = 1, unicodeLen(data) do\13\n\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9if transparency then\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9end\13\n\9\9\9\9else\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9newFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\13\n\9\9\9x, bufferIndex = x + 1, bufferIndex + 1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawImage(startX, startY, picture, blendForeground)\13\n\9local bufferIndex, pictureIndex, imageWidth, backgrounds, foregrounds, alphas, symbols = bufferWidth * (startY - 1) + startX, 1, picture[1], picture[3], picture[4], picture[5], picture[6]\13\n\9local bufferIndexStepOnReachOfImageWidth = bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9if alphas[pictureIndex] == 0 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex], newFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex], currentFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] > 0 and alphas[pictureIndex] < 1 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if blendForeground then\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] == 1 and symbols[pictureIndex] ~= \" \" then\13\n\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 1\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(x, y, width, height, color)\13\n\9local stringUp, stringDown, x2 = \"\" .. string.rep(\"\", width - 2) .. \"\", \"\" .. string.rep(\"\", width - 2) .. \"\", x + width - 1\13\n\9\13\n\9drawText(x, y, color, stringUp); y = y + 1\13\n\9for i = 1, height - 2 do\13\n\9\9drawText(x, y, color, \"\")\13\n\9\9drawText(x2, y, color, \"\")\13\n\9\9y = y + 1\13\n\9end\13\n\9drawText(x, y, color, stringDown)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function semiPixelRawSet(index, color, yPercentTwoEqualsZero, internalRun) --ToDo\13\n\9local upperPixel, lowerPixel, bothPixel = \"\", \"\", \" \"\13\n\9local backgroundBuffer, foregroundBuffer, symbolBuffer = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\n\9\13\n\9if internalRun then\13\n\9\9backgroundBuffer, foregroundBuffer, symbolBuffer = currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9end\13\n\9\13\n\9local background, foreground, symbol = backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index]\13\n\13\n\9if yPercentTwoEqualsZero then\13\n\9\9if symbol == upperPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9end\13\n\9else\13\n\9\9if symbol == lowerPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9end\13\n\9end\13\n\9\13\n\9if bufferOnly and not internalRun then\13\n\9\9semiPixelRawSet(index, color, yPercentTwoEqualsZero, true)\13\n\9end\13\nend\13\n\13\nlocal function semiPixelSet(x, y, color)\13\n\9local yFixed = mathCeil(y / 2)\13\n\9if x >= drawLimitX1 and yFixed >= drawLimitY1 and x <= drawLimitX2 and yFixed <= drawLimitY2 and isDrawable(x, yFixed) then\13\n\9\9semiPixelRawSet(bufferWidth * (yFixed - 1) + x, color, y % 2 == 0)\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelRectangle(x, y, width, height, color)\13\n\9local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = bufferWidth * (mathCeil(y / 2) - 1) + x, (bufferWidth - width), width\13\n\9for j = y, y + height - 1 do\13\n\9\9jPercentTwoEqualsZero = j % 2 == 0\13\n\9\9\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9jFixed = mathCeil(j / 2)\13\n\9\9\9semiPixelRawSet(index, color, jPercentTwoEqualsZero)\13\n\9\9\9index = index + 1\13\n\9\9end\13\n\13\n\9\9if jPercentTwoEqualsZero then\13\n\9\9\9index = index + indexStepForward\13\n\9\9else\13\n\9\9\9index = index - indexStepBackward\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelLine(x1, y1, x2, y2, color)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\nlocal function drawSemiPixelEllipse(centerX, centerY, radiusX, radiusY, color)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getPointTimedPosition(firstPoint, secondPoint, time)\13\n\9return {\13\n\9\9x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,\13\n\9\9y = firstPoint.y + (secondPoint.y - firstPoint.y) * time\13\n\9}\13\nend\13\n\13\nlocal function getConnectionPoints(points, time)\13\n\9local connectionPoints = {}\13\n\9for point = 1, #points - 1 do\13\n\9\9tableInsert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))\13\n\9end\13\n\9return connectionPoints\13\nend\13\n\13\nlocal function getMainPointPosition(points, time)\13\n\9if #points > 1 then\13\n\9\9return getMainPointPosition(getConnectionPoints(points, time), time)\13\n\9else\13\n\9\9return points[1]\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelCurve(points, color, precision)\13\n\9local linePoints = {}\13\n\9for time = 0, 1, precision or 0.01 do\13\n\9\9tableInsert(linePoints, getMainPointPosition(points, time))\13\n\9end\13\n\9\13\n\9for point = 1, #linePoints - 1 do\13\n\9\9drawSemiPixelLine(mathFloor(linePoints[point].x), mathFloor(linePoints[point].y), mathFloor(linePoints[point + 1].x), mathFloor(linePoints[point + 1].y), color)\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function drawChanges(force)\13\n\9local index, indexStepOnEveryLine, changes = bufferWidth * (drawLimitY1 - 1) + drawLimitX1, (bufferWidth - drawLimitX2 + drawLimitX1 - 1), {}\13\n\9local x, equalChars, equalCharsIndex, charX, charIndex, currentForeground\13\n\9local currentFrameBackground, currentFrameForeground, currentFrameSymbol, changesCurrentFrameBackground, changesCurrentFrameBackgroundCurrentFrameForeground\13\n\13\n\9local changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\13\n\9for y = drawLimitY1, drawLimitY2 do\13\n\9\9x = drawLimitX1\13\n\9\9while x <= drawLimitX2 do\9\9\9\13\n\9\9\9-- Determine if some pixel data was changed (or if <force> argument was passed)\13\n\9\9\9if\13\n\9\9\9\9currentFrameBackgrounds[index] ~= newFrameBackgrounds[index] or\13\n\9\9\9\9currentFrameForegrounds[index] ~= newFrameForegrounds[index] or\13\n\9\9\9\9currentFrameSymbols[index] ~= newFrameSymbols[index] or\13\n\9\9\9\9force\13\n\9\9\9then\13\n\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9currentFrameBackground, currentFrameForeground, currentFrameSymbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9\9\9\9currentFrameBackgrounds[index] = currentFrameBackground\13\n\9\9\9\9currentFrameForegrounds[index] = currentFrameForeground\13\n\9\9\9\9currentFrameSymbols[index] = currentFrameSymbol\13\n\13\n\9\9\9\9-- Look for pixels with equal chars from right of current pixel\13\n\9\9\9\9equalChars, equalCharsIndex, charX, charIndex = {currentFrameSymbol}, 2, x + 1, index + 1\13\n\9\9\9\9while charX <= drawLimitX2 do\13\n\9\9\9\9\9-- Pixels becomes equal only if they have same background and (whitespace char or same foreground)\13\n\9\9\9\9\9if\9\13\n\9\9\9\9\9\9currentFrameBackground == newFrameBackgrounds[charIndex] and\13\n\9\9\9\9\9\9(\13\n\9\9\9\9\9\9\9newFrameSymbols[charIndex] == \" \" or\13\n\9\9\9\9\9\9\9currentFrameForeground == newFrameForegrounds[charIndex]\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9\9 \9currentFrameBackgrounds[charIndex] = newFrameBackgrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameForegrounds[charIndex] = newFrameForegrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameSymbols[charIndex] = newFrameSymbols[charIndex]\13\n\13\n\9\9\9\9\9 \9equalChars[equalCharsIndex], equalCharsIndex = currentFrameSymbols[charIndex], equalCharsIndex + 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9charX, charIndex = charX + 1, charIndex + 1\13\n\9\9\9\9end\13\n\13\n\9\9\9\9-- Group pixels that need to be drawn by background and foreground\13\n\9\9\9\9changes[currentFrameBackground] = changes[currentFrameBackground] or {}\13\n\9\9\9\9changesCurrentFrameBackground = changes[currentFrameBackground]\13\n\9\9\9\9changesCurrentFrameBackground[currentFrameForeground] = changesCurrentFrameBackground[currentFrameForeground] or {index = 1}\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground = changesCurrentFrameBackground[currentFrameForeground]\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForegroundIndex = changesCurrentFrameBackgroundCurrentFrameForeground.index\13\n\9\9\9\9\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = x, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = y, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = tableConcat(equalChars), changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9\13\n\9\9\9\9x, index, changesCurrentFrameBackgroundCurrentFrameForeground.index = x + equalCharsIndex - 2, index + equalCharsIndex - 2, changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\9\9\9end\13\n\13\n\9\9\9x, index = x + 1, index + 1\13\n\9\9end\13\n\13\n\9\9index = index + indexStepOnEveryLine\13\n\9end\13\n\9\13\n\9-- Draw grouped pixels on screen\13\n\9for background, foregrounds in pairs(changes) do\13\n\9\9GPUProxySetBackground(background)\13\n\13\n\9\9for foreground, pixels in pairs(foregrounds) do\13\n\9\9\9if currentForeground ~= foreground then\13\n\9\9\9\9GPUProxySetForeground(foreground)\13\n\9\9\9\9currentForeground = foreground\13\n\9\9\9end\13\n\13\n\9\9\9for i = 1, #pixels, 3 do\13\n\9\9\9\9GPUProxySet(pixels[i], pixels[i + 1], pixels[i + 2])\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9changes = nil\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nbindGPU(component.getPrimary(\"gpu\").address)\13\n\13\nreturn {\13\n\9getCoordinates = getCoordinates,\13\n\9getIndex = getIndex,\13\n\9setDrawLimit = setDrawLimit,\13\n\9resetDrawLimit = resetDrawLimit,\13\n\9getDrawLimit = getDrawLimit,\13\n\9flush = flush,\13\n\9setResolution = setResolution,\13\n\9bindScreen = bindScreen,\13\n\9bindGPU = bindGPU,\13\n\9getGPUProxy = getGPUProxy,\13\n\9getResolution = getResolution,\13\n\9getWidth = getWidth,\13\n\9getHeight = getHeight,\13\n\9getCurrentFrameTables = getCurrentFrameTables,\13\n\9getNewFrameTables = getNewFrameTables,\13\n\9setCurrentFrameTables = setCurrentFrameTables,\13\n\9setNewFrameTables = setNewFrameTables,\13\n\9setBufferOnly = setBufferOnly,\13\n\9getBufferOnly = getBufferOnly,\13\n\13\n\9rawSet = rawSet,\13\n\9rawGet = rawGet,\13\n\9get = get,\13\n\9set = set,\13\n\9clear = clear,\13\n\9copy = copy,\13\n\9paste = paste,\13\n\9directCopy = directCopy,\13\n\9copyCurrent = copyCurrent,\13\n\9pasteCurrent = pasteCurrent,\13\n\9rasterizeLine = rasterizeLine,\13\n\9rasterizeEllipse = rasterizeEllipse,\13\n\9semiPixelRawSet = semiPixelRawSet,\13\n\9semiPixelSet = semiPixelSet,\13\n\9drawChanges = drawChanges,\13\n\13\n\9drawRectangle = drawRectangle,\13\n\9drawLine = drawLine,\13\n\9drawEllipse = drawEllipse,\13\n\9drawText = drawText,\13\n\9drawImage = drawImage,\13\n\9drawFrame = drawFrame,\13\n\13\n\9drawSemiPixelRectangle = drawSemiPixelRectangle,\13\n\9drawSemiPixelLine = drawSemiPixelLine,\13\n\9drawSemiPixelEllipse = drawSemiPixelEllipse,\13\n\9drawSemiPixelCurve = drawSemiPixelCurve,\13\n\9\13\n\9setDrawAreas = setDrawAreas,\13\n\9resetDrawAreas = resetDrawAreas,\13\n\9getDrawAreas = getDrawAreas,\13\n\9setNonDrawAreas = setNonDrawAreas,\13\n\9resetNonDrawAreas = resetNonDrawAreas,\13\n\9getNonDrawAreas = getNonDrawAreas,\13\n\9\13\n\9setDrawAreaOffset = setDrawAreaOffset,\13\n\9getDrawAreaOffset = getDrawAreaOffset,\13\n\9resetDrawAreaOffset = resetDrawAreaOffset,\13\n}",["./data/sf1/data/libs/color.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are possibly made some changes if needed to fit in to the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/Color>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\ncolor Copyright (c) 2018 \13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\n\13\nlocal computer = require(\"computer\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal palette = {0x000000, 0x000040, 0x000080, 0x0000BF, 0x0000FF, 0x002400, 0x002440, 0x002480, 0x0024BF, 0x0024FF, 0x004900, 0x004940, 0x004980, 0x0049BF, 0x0049FF, 0x006D00, 0x006D40, 0x006D80, 0x006DBF, 0x006DFF, 0x009200, 0x009240, 0x009280, 0x0092BF, 0x0092FF, 0x00B600, 0x00B640, 0x00B680, 0x00B6BF, 0x00B6FF, 0x00DB00, 0x00DB40, 0x00DB80, 0x00DBBF, 0x00DBFF, 0x00FF00, 0x00FF40, 0x00FF80, 0x00FFBF, 0x00FFFF, 0x0F0F0F, 0x1E1E1E, 0x2D2D2D, 0x330000, 0x330040, 0x330080, 0x3300BF, 0x3300FF, 0x332400, 0x332440, 0x332480, 0x3324BF, 0x3324FF, 0x334900, 0x334940, 0x334980, 0x3349BF, 0x3349FF, 0x336D00, 0x336D40, 0x336D80, 0x336DBF, 0x336DFF, 0x339200, 0x339240, 0x339280, 0x3392BF, 0x3392FF, 0x33B600, 0x33B640, 0x33B680, 0x33B6BF, 0x33B6FF, 0x33DB00, 0x33DB40, 0x33DB80, 0x33DBBF, 0x33DBFF, 0x33FF00, 0x33FF40, 0x33FF80, 0x33FFBF, 0x33FFFF, 0x3C3C3C, 0x4B4B4B, 0x5A5A5A, 0x660000, 0x660040, 0x660080, 0x6600BF, 0x6600FF, 0x662400, 0x662440, 0x662480, 0x6624BF, 0x6624FF, 0x664900, 0x664940, 0x664980, 0x6649BF, 0x6649FF, 0x666D00, 0x666D40, 0x666D80, 0x666DBF, 0x666DFF, 0x669200, 0x669240, 0x669280, 0x6692BF, 0x6692FF, 0x66B600, 0x66B640, 0x66B680, 0x66B6BF, 0x66B6FF, 0x66DB00, 0x66DB40, 0x66DB80, 0x66DBBF, 0x66DBFF, 0x66FF00, 0x66FF40, 0x66FF80, 0x66FFBF, 0x66FFFF, 0x696969, 0x787878, 0x878787, 0x969696, 0x990000, 0x990040, 0x990080, 0x9900BF, 0x9900FF, 0x992400, 0x992440, 0x992480, 0x9924BF, 0x9924FF, 0x994900, 0x994940, 0x994980, 0x9949BF, 0x9949FF, 0x996D00, 0x996D40, 0x996D80, 0x996DBF, 0x996DFF, 0x999200, 0x999240, 0x999280, 0x9992BF, 0x9992FF, 0x99B600, 0x99B640, 0x99B680, 0x99B6BF, 0x99B6FF, 0x99DB00, 0x99DB40, 0x99DB80, 0x99DBBF, 0x99DBFF, 0x99FF00, 0x99FF40, 0x99FF80, 0x99FFBF, 0x99FFFF, 0xA5A5A5, 0xB4B4B4, 0xC3C3C3, 0xCC0000, 0xCC0040, 0xCC0080, 0xCC00BF, 0xCC00FF, 0xCC2400, 0xCC2440, 0xCC2480, 0xCC24BF, 0xCC24FF, 0xCC4900, 0xCC4940, 0xCC4980, 0xCC49BF, 0xCC49FF, 0xCC6D00, 0xCC6D40, 0xCC6D80, 0xCC6DBF, 0xCC6DFF, 0xCC9200, 0xCC9240, 0xCC9280, 0xCC92BF, 0xCC92FF, 0xCCB600, 0xCCB640, 0xCCB680, 0xCCB6BF, 0xCCB6FF, 0xCCDB00, 0xCCDB40, 0xCCDB80, 0xCCDBBF, 0xCCDBFF, 0xCCFF00, 0xCCFF40, 0xCCFF80, 0xCCFFBF, 0xCCFFFF, 0xD2D2D2, 0xE1E1E1, 0xF0F0F0, 0xFF0000, 0xFF0040, 0xFF0080, 0xFF00BF, 0xFF00FF, 0xFF2400, 0xFF2440, 0xFF2480, 0xFF24BF, 0xFF24FF, 0xFF4900, 0xFF4940, 0xFF4980, 0xFF49BF, 0xFF49FF, 0xFF6D00, 0xFF6D40, 0xFF6D80, 0xFF6DBF, 0xFF6DFF, 0xFF9200, 0xFF9240, 0xFF9280, 0xFF92BF, 0xFF92FF, 0xFFB600, 0xFFB640, 0xFFB680, 0xFFB6BF, 0xFFB6FF, 0xFFDB00, 0xFFDB40, 0xFFDB80, 0xFFDBBF, 0xFFDBFF, 0xFFFF00, 0xFFFF40, 0xFFFF80, 0xFFFFBF, 0xFFFFFF}\13\nlocal mathFloor, mathMax, mathMin, mathModf = math.floor, math.max, math.min, math.modf\13\nlocal integerToRGB, RGBToInteger, blend, transition, to8Bit\13\n\13\nlocal color = {}\13\n\13\n--------------------------------------------------------------------------------\13\n\13\n-- Optimized Lua 5.3 bitwise support\13\nif computer.getArchitecture and computer.getArchitecture() == \"Lua 5.3\" then\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9return integerColor >> 16, integerColor >> 8 & 0xFF, integerColor & 0xFF\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r << 16 | g << 8 | b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9return\13\n\9\9\9\9\9((color2 >> 16) * invertedTransparency + (color1 >> 16) * transparency) // 1 << 16 |\13\n\9\9\9\9\9((color2 >> 8 & 0xFF) * invertedTransparency + (color1 >> 8 & 0xFF) * transparency) // 1 << 8 |\13\n\9\9\9\9\9((color2 & 0xFF) * invertedTransparency + (color1 & 0xFF) * transparency) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1, g1, b1 = color1 >> 16, color1 >> 8 & 0xFF, color1 & 0xFF\13\n\9\9\9\9return\13\n\9\9\9\9\9(r1 + ((color2 >> 16) - r1) * position) // 1 << 16 |\13\n\9\9\9\9\9(g1 + ((color2 >> 8 & 0xFF) - g1) * position) // 1 << 8 |\13\n\9\9\9\9\9(b1 + ((color2 & 0xFF) - b1) * position) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local r, g, b, closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = color24Bit >> 16, color24Bit >> 8 & 0xFF, color24Bit & 0xFF, mathHuge, 1\13\n\13\n\9\9\9\9for i = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[i]\13\n\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return i - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR, paletteG, paletteB = paletteColor >> 16, paletteColor >> 8 & 0xFF, paletteColor & 0xFF\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, i\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nelse\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9local r = integerColor / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (integerColor - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\13\n\9\9\9\9return r, g, integerColor - r * 65536 - g * 256\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r * 65536 + g * 256 + b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r2 * invertedTransparency + r1 * transparency,\13\n\9\9\9\9\9g2 * invertedTransparency + g1 * transparency,\13\n\9\9\9\9\9(color2 - r2 * 65536 - g2 * 256) * invertedTransparency + (color1 - r1 * 65536 - g1 * 256) * transparency\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\9\9\9\9local b1 = color1 - r1 * 65536 - g1 * 256\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r1 + (r2 - r1) * position,\13\n\9\9\9\9\9g1 + (g2 - g1) * position,\13\n\9\9\9\9\9b1 + (color2 - r2 * 65536 - g2 * 256 - b1) * position\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = mathHuge, 1\13\n\13\n\9\9\9\9local r = color24Bit / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (color24Bit - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\9\9\9\9local b = color24Bit - r * 65536 - g * 256\13\n\13\n\9\9\9\9for index = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[index]\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return index - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR = paletteColor / 65536\13\n\9\9\9\9\9\9paletteR = paletteR - paletteR % 1\13\n\9\9\9\9\9\9paletteG = (paletteColor - paletteR * 65536) / 256\13\n\9\9\9\9\9\9paletteG = paletteG - paletteG % 1\13\n\9\9\9\9\9\9paletteB = paletteColor - paletteR * 65536 - paletteG * 256\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, index\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function RGBToHSB(r, g, b)\13\n\9local max, min = mathMax(r, g, b), mathMin(r, g, b)\13\n\13\n\9if max == min then\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g >= b then\13\n\9\9return 60 * (g - b) / (max - min), max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g < b then\13\n\9\9return 60 * (g - b) / (max - min) + 360, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == g then\13\n\9\9return 60 * (b - r) / (max - min) + 120, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == b then\13\n\9\9return 60 * (r - g) / (max - min) + 240, max == 0 and 0 or (1 - min / max), max / 255\13\n\9else\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9end\13\nend\13\n\13\nlocal function HSBToRGB(h, s, b)\13\n\9local integer, fractional = mathModf(h / 60)\9\13\n\9local p, q, t = b * (1 - s), b * (1 - s * fractional), b * (1 - (1 - fractional) * s)\13\n\13\n\9if integer == 0 then\13\n\9\9return mathFloor(b * 255), mathFloor(t * 255), mathFloor(p * 255)\13\n\9elseif integer == 1 then\13\n\9\9return mathFloor(q * 255), mathFloor(b * 255), mathFloor(p * 255)\13\n\9elseif integer == 2 then\13\n\9\9return mathFloor(p * 255), mathFloor(b * 255), mathFloor(t * 255)\13\n\9elseif integer == 3 then\13\n\9\9return mathFloor(p * 255), mathFloor(q * 255), mathFloor(b * 255)\13\n\9elseif integer == 4 then\13\n\9\9return mathFloor(t * 255), mathFloor(p * 255), mathFloor(b * 255)\13\n\9else\13\n\9\9return mathFloor(b * 255), mathFloor(p * 255), mathFloor(q * 255)\13\n\9end\13\nend\13\n\13\nlocal function integerToHSB(integerColor)\13\n\9return RGBToHSB(integerToRGB(integerColor))\13\nend\13\n\13\nlocal function HSBToInteger(h, s, b)\13\n\9return RGBToInteger(HSBToRGB(h, s, b))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function to24Bit(color8Bit)\13\n\9return palette[color8Bit + 1]\13\nend\13\n\13\nlocal function optimize(color24Bit)\13\n\9return to24Bit(to8Bit(color24Bit))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nreturn {\13\n\9RGBToInteger = RGBToInteger,\13\n\9integerToRGB = integerToRGB,\13\n\9RGBToHSB = RGBToHSB,\13\n\9HSBToRGB = HSBToRGB,\13\n\9integerToHSB = integerToHSB,\13\n\9HSBToInteger = HSBToInteger,\13\n\9blend = blend,\13\n\9transition = transition,\13\n\9to8Bit = to8Bit,\13\n\9to24Bit = to24Bit,\13\n\9optimize = optimize,\13\n}",["./data/sf1/data/libs/"] = 0,["./data/sf1/data/game.lua"] = "local usesDoubleBuffer = ...\13\n\13\nlocal version = \"v1.1.2c\"\13\nlocal isDevVersion = false\13\n\13\nlocal resX, resY = require(\"component\").gpu.getResolution()\13\nlocal offsetX, offsetY = resX / 2 / 2, resY / 2 / 2\13\nSF1_isRunning = true\13\n\13\nlocal component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal system = require(\"os\")\13\nlocal term = require(\"term\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\npackage.loaded.player = nil\13\nlocal player = require(\"player\")\13\npackage.loaded.player = nil\13\nlocal player2 = require(\"player\")\13\n\13\npackage.loaded.graphic = nil\13\nrequire(\"graphic\")\13\n\13\npackage.loaded.deltaTime = nil\13\nlocal delta = require(\"deltaTime\")\13\n\13\npackage.loaded.background = nil\13\nlocal background = require(\"background\")\13\n\13\nlocal deltaTime = 0\13\nlocal previousDeltaTime = 0\13\n\13\nlocal fpsCheckInterval = 20\13\nlocal deltaTimeTable = {}\13\nlocal fps = 0\13\nlocal frameCounter = 0\13\nlocal realDeltaTime = 0\13\n\13\nlocal lastBlinkTime = computer.uptime()\13\nlocal blinkState = true\13\nlocal lastLooser\13\n\13\nlocal gameIsRunning = true\13\n\13\n--==========--\13\nlocal blinkDelay = 1\13\n\13\nlocal orgResX = 80\13\nlocal orgResY = 25\13\n\13\nlocal sleepTime = 1 --caps it to about 20 fps\13\n\13\nlocal controls = require(\"libs/LIP\").load(\"../controls.ini\")\13\n\13\n--===== init =====--\13\nif usesDoubleBuffer then\13\n\9gpu = gpuProxy\13\nelse\13\n\9gpu = component.gpu\13\nend\13\n\13\n--=============== Functions ===============--\13\n\13\nfunction Start()\13\n\9player.Start()\13\n\9player2.Start()\13\n\13\n\9player.right = tostring(controls.player1.right)\13\n\9player.left = tostring(controls.player1.left)\13\n\9player.punch = tostring(controls.player1.punch)\13\n\9\13\n\9player2.right = tostring(controls.player2.right)\13\n\9player2.left = tostring(controls.player2.left)\13\n\9player2.punch = tostring(controls.player2.punch)\13\n\9\13\n\9player2.body.aSet[1] = {2, 1, \"   \", 0x000000, 0xbf2f11}\13\n\9player2.body.aSet[2] = {3, 0, \" \"}\13\n\9\13\n\9Reset()\13\nend\13\n\13\nfunction Update()\13\n\9if gameIsRunning then\13\n\9\9player.Update()\13\n\9\9player2.Update()\13\n\9\9\13\n\9\9Draw()\13\n\9\9\13\n\9\9if HitCheck(player, player2) then\13\n\9\9\9player2.life = player2.life - (player.charge /2)\13\n\9\9\9player.charge = 0\13\n\9\9end\13\n\9\9if HitCheck(player2, player) then\13\n\9\9\9player.life = player.life - (player2.charge /2)\13\n\9\9\9player2.charge = 0\13\n\9\9end\13\n\9\9\13\n\9\9if player2.life <= 0 and player.life <= 0 then\13\n\9\9\9GameOver(0)\13\n\9\9else\13\n\9\9\9if player.life <= 0 then\13\n\9\9\9\9GameOver(\"Player2\")\13\n\9\9\9elseif player2.life <= 0 then\13\n\9\9\9\9GameOver(\"Player1\")\13\n\9\9\9end\13\n\9\9end\13\n\9else\13\n\9\9if computer.uptime() - lastBlinkTime > blinkDelay then\13\n\9\9\9if blinkState then\13\n\9\9\9\9DrawResetText()\13\n\9\9\9\9blinkState = false\13\n\9\9\9else\13\n\9\9\9\9Draw()\13\n\9\9\9\9GameOver(lastLooser)\13\n\9\9\9\9blinkState = true\13\n\9\9\9end\13\n\9\9\9lastBlinkTime = computer.uptime()\13\n\9\9end\13\n\9end\13\nend\13\n\13\n\13\nfunction Draw()\13\n\9--gpu.fill(1, 1, resX, resY, \" \")\13\n\9--DrawAt(testTexture, 0, 0, gpu)\13\n\9\13\n\9ClearAt(player2.body, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player.body, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player.arm2, player.oldPosX, player.oldPosY, gpu)\13\n\9ClearAt(player.arm3, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player2.arm2, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player2.arm3, player2.oldPosX, player2.oldPosY, gpu)\13\n\9\13\n\9--Background\13\n\9DrawAt(background.street, 1, 17, gpu)\13\n\9\13\n\9--Player\13\n\9\13\n\9DrawAt(player.body, player.posX, player.posY, gpu)\13\n\9DrawAt(player2.body, player2.posX, player2.posY, gpu)\13\n\9\13\n\9DrawArms(player)\13\n\9DrawArms(player2)\13\n\9\13\n\9LifeGui()\13\n\13\n\9gpu.setBackground(0x0)\13\n\9gpu.fill(1, 1, resX, offsetY, \" \")\13\n\9gpu.fill(1, offsetY + orgResY + 1, resX, offsetY, \" \")\13\n\9gpu.fill(1, 1, offsetX, resY, \" \")\13\n\9gpu.fill(offsetX + orgResX + 1, 1, offsetX, resY, \" \")\13\n\13\n\9gpu.setBackground(0x5a5a5a)\13\n\9gpu.setForeground(0xe1e1e1)\13\n\9gpu.fill(offsetX - 1, offsetY, orgResX + 4, 1, \"\")\13\n\9gpu.fill(offsetX - 1, offsetY + orgResY + 1, orgResX + 4, 1, \"\")\13\n\9gpu.fill(offsetX - 1, offsetY, 1, orgResY + 2, \" \")\13\n\9gpu.fill(offsetX, offsetY + 1, 1, orgResY, \"\")\13\n\9gpu.fill(offsetX + orgResX + 2, offsetY, 1, orgResY + 2, \" \")\13\n\9gpu.fill(offsetX + orgResX + 1, offsetY + 1, 1, orgResY, \"\")\13\n\13\nend\13\n\13\nfunction LifeGui() \13\n\9DrawAt({\13\n\9\9fillSize = 4,\13\n\9\9aFill = {\13\n\9\9\9[1] = {2, 1, 36, 5, \" \", 0x000000, 0xaaaaaa},\13\n\9\9\9[2] = {42, 1, 36, 5, \" \", 0x000000, 0xaaaaaa},\13\n\9\9\9\13\n\9\9},\13\n\9\9\13\n\9\9setSize = 2,\13\n\9\9aSet = {\13\n\9\9\9\13\n\9\9},\13\n\9}, 1, 1, gpu)\13\n\9gpu.setBackground(0x000000)\13\n\9gpu.set(5 + offsetX, 3 + offsetY, \"                                \")\13\n\9gpu.set(45 + offsetX, 3 + offsetY, \"                                \")\13\n\9gpu.set(5 + offsetX, 5 + offsetY, \"                                \")\13\n\9gpu.set(45 + offsetX, 5 + offsetY, \"                                \")\13\n\9gpu.setBackground(0x00aa00)\13\n\9gpu.fill(5 + offsetX, 3 + offsetY, player.life, 1, \" \")\13\n\9gpu.fill(45 + offsetX, 3 + offsetY, player2.life, 1, \" \")\13\n\9gpu.setBackground(0x000000ff)\13\n\9gpu.fill(5 + offsetX, 5 + offsetY, player.charge, 1, \" \")\13\n\9gpu.fill(45 + offsetX, 5 + offsetY, player2.charge, 1, \" \")\13\n\9\13\n\9gpu.setForeground(0xaaaaaa)\13\n\9gpu.setBackground(0x00509f)\13\n\9gpu.set(orgResX / 2 - unicode.len(version) / 2 + 1 + offsetX, 1 + offsetY, version)\13\nend\13\n\13\nfunction HitCheck(p1, p2)\13\n\9if p1.looksLeft then\13\n\9\9if p1.isPunching then\13\n\9\9\9if p1.posX <= p2.posX + 10 and p1.posX > p2.posX + 5 then\13\n\9\9\9\9return true\13\n\9\9\9end\13\n\9\9end\13\n\9elseif p1.looksLeft == false then\13\n\9\9if p1.isPunching then\13\n\9\9\9if p1.posX + 10 >= p2.posX and p1.posX + 5 < p2.posX then\13\n\9\9\9\9return true\13\n\9\9\9end\13\n\9\9end\13\n\9else\13\n\9\9return false\13\n\9end\13\nend\13\n\13\nfunction DrawArms(player)\9\13\n\9if player.isCharging then\13\n\9\9DrawAt(player.arm2, player.posX, player.posY, gpu)\13\n\9elseif player.isPunching then\13\n\9\9DrawAt(player.arm3, player.posX, player.posY, gpu)\13\n\9else\13\n\9\9DrawAt(player.arm1, player.posX, player.posY, gpu)\13\n\9end\13\nend\13\n\13\nfunction GameOver(name)\13\n\9LifeGui()\13\n\9\13\n\9if name ~= 0 then\13\n\9\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 4,\13\n\9\9aSet = {\13\n\9\9\9[1] = {28, 6, \"########################\", 0x500000, 0xba0000},\13\n\9\9\9[2] = {28, 7, \"##     GameOver!      ##\", 0x500000, 0xba0000},\13\n\9\9\9[3] = {28, 8, \"##  \" .. name .. \" has won!  ##\"},\13\n\9\9\9[4] = {28, 9, \"########################\", 0x500000, 0xba0000},\13\n\9\9}}, 1, 1, gpu)\13\n\9else\13\n\9\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 4,\13\n\9\9aSet = {\13\n\9\9\9[1] = {28, 6, \"########################\", 0x500000, 0xba0000},\13\n\9\9\9[2] = {28, 7, \"##     GameOver!      ##\", 0x500000, 0xba0000},\13\n\9\9\9[3] = {28, 8, \"##       Tie!         ##\"},\13\n\9\9\9[4] = {28, 9, \"########################\", 0x500000, 0xba0000},\13\n\9\9}}, 1, 1, gpu)\13\n\9end\13\n\13\n\9if blinkState then\13\n\9\9DrawResetText()\13\n\9end\13\n\9\13\n\9gameIsRunning = false\13\n\9lastLooser = name\13\nend\13\n\13\nfunction DrawResetText()\13\n\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 1,\13\n\9\9aSet = {\13\n\9\9\9[1] = {30, 12, \" Press \" .. unicode.upper(controls.game.reset) .. \" to restart \", 0x705000, 0xee6000},\13\n\9}}, 1, 9, gpu)\13\nend\13\n\13\nfunction Reset() \13\n\9player.posX = 5\13\n\9player.life = player.maxLife\13\n\9player.charge = 0\13\n\9player.TurnAround(false)\13\n\9\13\n\9player2.posX = 70\13\n\9player2.life = player2.maxLife\13\n\9player2.charge = 0\13\n\9player2.TurnAround(true)\13\n\9\13\n\9gameIsRunning = true\13\n\9\13\n\9blinkState = true\13\n\9\13\n\9ClearAt(player2.body, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player.body, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player.arm2, player.oldPosX, player.oldPosY, gpu)\13\n\9ClearAt(player.arm3, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player2.arm2, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player2.arm3, player2.oldPosX, player2.oldPosY, gpu)\13\n\9\13\nend\13\n\13\nfunction Reload() --For DEV\13\n\9ClearAt(background.street, 1, 17, gpu)\13\n\9package.loaded.background = nil\13\n\9background = require(\"background\")\13\nend\13\nlocal devCount = 0\13\n\13\n--=============== Main while ===============--\13\n--term.clear()\13\n--gpu.setResolution(resX, resY)\13\n\13\n\13\nStart()\13\nwhile SF1_isRunning do\13\n\9Update()\13\n\9--system.sleep(0.001)\13\n\9deltaTime = (computer.uptime() - previousDeltaTime) * 100 / 7\13\n\9realDeltaTime = computer.uptime() - previousDeltaTime\13\n\9previousDeltaTime = computer.uptime()\13\n\9\13\n\9if isDevVersion then\13\n\9\9if frameCounter >= fpsCheckInterval then\13\n\9\9\9frameCounter = 0\13\n\9\9end\13\n\9\9deltaTimeTable[frameCounter] = realDeltaTime\13\n\9\9local frameTimes = 0\13\n\9\9for i, c in pairs(deltaTimeTable) do\13\n\9\9\9frameTimes = frameTimes + c\13\n\9\9end\13\n\9\9frameCounter = frameCounter +1\13\n\9\9fps = 1 / (frameTimes / #deltaTimeTable)\13\n\13\n\9\9gpu.setForeground(0xaaaaaa)\13\n\9\9gpu.setBackground(0x000000)\13\n\9\9gpu.set(1, 1, \"                              \")\13\n\9\9delta.Set()\13\n\9\9--gpu.set(1, 1, \"Delta time: \" .. deltaTime .. \" | \" .. (sleepTime - deltaTime) / 1000 .. \" | \" )\13\n\9\9gpu.set(1, 1, \"FPS: \" .. fps)\13\n\9end\13\n\13\n\9if usesDoubleBuffer then\13\n\9\9gpu.drawChanges()\13\n\9end\13\n\9\13\n\9if keyboard.isKeyDown(controls.game.quit) then\13\n\9\9gpu.setForeground(0xaaaaaa)\13\n\9\9gpu.setBackground(0x000000)\13\n\9\9--print(\"BREAK                       \")\13\n\9\9break\13\n\9elseif keyboard.isKeyDown(controls.game.reset) then\13\n\9\9Reset()\13\n\9end\13\n\9if keyboard.isKeyDown('t') then\13\n\9\9Reload()\13\n\9\9devCount = 0\13\n\9end\13\n\13\n\9os.sleep((sleepTime - deltaTime) / 1000)\13\nend\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n",["./data/sf1/data/graphic.lua"] = "--GraphicLib v0.1c\13\n\13\nlocal resX, resY = require(\"component\").gpu.getResolution()\13\nlocal offsetX, offsetY = resX / 2 / 2, resY / 2 / 2\13\n\13\nfunction ClearAt(t, posX, posY, gpu)\13\n\9posX, posY = posX + offsetX, posY + offsetY\13\n\9AddToTexture(t, posX, posY)\13\n\9ClearTexture(t, gpu)\13\n\9AddToTexture(t, -posX, -posY)\13\nend\13\n\13\nfunction ClearTexture(t, gpu) \13\n\9gpu.setBackground(0x000000)\13\n\9for c = 1, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9if t.aFill[c][5] ~= nil then\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], \" \")\13\n\9\9\9end\9\9\13\n\9\9end\13\n\9end\13\n\13\n\9for c = 1, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9if t.aSet[c][3] ~= nil then\13\n\9\9\9\9gpu.fill(t.aSet[c][1], t.aSet[c][2], string.len(t.aSet[c][3]), 1, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction DrawAt(t, posX, posY, gpu)\13\n\9posX, posY = posX + offsetX, posY + offsetY\13\n\9AddToTexture(t, posX, posY)\13\n\9DrawTexture(t, gpu)\13\n\9AddToTexture(t, -posX, -posY)\13\nend\13\n\13\nfunction DrawTexture(t, gpu) \13\n\9local previousForeground = gpu.getForeground()\13\n\9local previousBackground = gpu.getBackground()\13\n\9for c = 1, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9if t.aFill[c][6] ~= nil then\13\n\9\9\9\9if previousForeground ~= t.aFill[c][6] then\13\n\9\9\9\9\9gpu.setForeground(t.aFill[c][6])\13\n\9\9\9\9\9previousForeground = t.aFill[c][6]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aFill[c][7] then\13\n\9\9\9\9\9gpu.setBackground(t.aFill[c][7])\13\n\9\9\9\9\9previousBackground = t.aFill[c][7]\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], t.aFill[c][5])\13\n\9\9\9elseif #t.aFill[c] == 2 then\13\n\9\9\9\9if previousForeground ~= t.aFill[c][1] then\13\n\9\9\9\9\9gpu.setForeground(t.aFill[c][1])\13\n\9\9\9\9\9previousForeground = t.aFill[c][1]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aFill[c][2] then\13\n\9\9\9\9\9gpu.setBackground(t.aFill[c][2])\13\n\9\9\9\9\9previousBackground = t.aFill[c][2]\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], t.aFill[c][5])\13\n\9\9\9end\13\n\9\9\9\13\n\9\9end\13\n\9end\13\n\13\n\9for c = 1, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9if t.aSet[c][4] ~= nil then\13\n\9\9\9\9if previousForeground ~= t.aSet[c][4] then\13\n\9\9\9\9\9gpu.setForeground(t.aSet[c][4])\13\n\9\9\9\9\9previousForeground = t.aSet[c][4]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aSet[c][5] then\13\n\9\9\9\9\9gpu.setBackground(t.aSet[c][5])\13\n\9\9\9\9\9previousBackground = t.aSet[c][5]\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9gpu.set(t.aSet[c][1], t.aSet[c][2], t.aSet[c][3])\13\n\9\9\9elseif #t.aSet[c] == 2 then\13\n\9\9\9\9if previousForeground ~= t.aSet[c][1] then\13\n\9\9\9\9\9gpu.setForeground(t.aSet[c][1])\13\n\9\9\9\9\9previousForeground = t.aSet[c][1]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aSet[c][2] then\13\n\9\9\9\9\9gpu.setBackground(t.aSet[c][2])\13\n\9\9\9\9\9previousBackground = t.aSet[c][2]\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9gpu.set(t.aSet[c][1], t.aSet[c][2], t.aSet[c][3])\13\n\9\9\9end\13\n\9\9\9\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction AddToTexture(t, x, y)\13\n\9for c = 0, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9t.aFill[c][1] = t.aFill[c][1] + x\13\n\9\9\9t.aFill[c][2] = t.aFill[c][2] + y\13\n\9\9end\13\n\9end\13\n\9for c = 0, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9t.aSet[c][1] = t.aSet[c][1] + x\13\n\9\9\9t.aSet[c][2] = t.aSet[c][2] + y\13\n\9\9end\13\n\9end\13\nend",["./data/sf1/data/"] = 0,["./data/sf1/"] = 0,["./data/gameObjects/Exhaust.lua"] = "local global = ...\n\nExhaust = {}\nExhaust.__index = Exhaust\n\nfunction Exhaust.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"Exhaust: init\")\nend\n\nfunction Exhaust.new(args)\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9--args.particle = \"TestParticle2\"\n\9args.type = 1\n\9args.useCollision = false\n\9args.updateAlways = true\n\9\n\9--===== default stuff =====--\n\9local this = nil\n\9\n\9if args.particleContainer ~= nil then\n\9\9this = args.particleContainer\n\9else\n\9\9this = global.parent.ParticleContainer.new(args)\n\9end\n\9\n\9this = setmetatable(this, Exhaust)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9this.parent = args.parent\n\9this.smokeRate = global.ut.parseArgs(args.smokeRate, 2) * global.ut.parseArgs(global.conf.particles, 1)\n\9this.particle = args.particle or \"Smoke\"\n\9this.width = pa(args.width)\n\9this.height = pa(args.height)\n\9this.offsetX = pa(args.ox, args.offsetX, 0)\n\9this.offsetY = pa(args.oy, args.offsetY, 0)\n\9\n\9this.pastTime = 0\n\9\n\9--===== global functions =====--\n\9this.setSmokeRate = function(this, sr)\n\9\9this.smokeRate = sr * global.ut.parseArgs(global.conf.particles, 1)\n\9end\n\9this.getSmokeRate = function(this)\n\9\9return this.smokeRate\n\9end\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9this.pastTime = this.pastTime + dt\n\9\9\n\9\9local x, y = this.parent:getPos()\n\9\9local toSpawn = math.floor(this.pastTime * this.smokeRate)\n\9\9this.pastTime = this.pastTime - toSpawn / this.smokeRate\n\9\9\n\9\9if this.pastTime ~= this.pastTime then \n\9\9\9this.pastTime = 0\n\9\9end\n\9\9\n\9\9for c = 1, toSpawn do\n\9\9\9--global.log(this.particle, x + this.parent.exhaustOffsetX, y + this.parent.exhaustOffsetY)\n\9\9\9local rx, ry = math.random(this.width) -1, math.random(this.height) -1\n\9\9\9\n\9\9\9local particle = this:addParticle(this.particle, x + this.offsetX + rx, y + this.offsetY + ry)\n\9\9\9\n\9\9\9particle.gameObject:setSpeed(this.parent:getSpeed())\n\9\9end\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.stop = function(this) \n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn Exhaust",["./data/gameObjects/Test3.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\nlocal game = global.state.game\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 100\n\9args.sizeY = 100\n\9args.components = { --Define the GameObjects components.\n\9\9{\"ClearArea\",\n\9\9\9x = 4,\n\9\9\9y = 0,\n\9\9\9sizeX = 13,\n\9\9\9sizeY = 17,\n\9\9},\n\9\9--{\"Sprite\", texture = global.texture.player.head1, x = 7, y = 1},\n\9\9--{\"Sprite\", texture = global.texture.player.body, x = 4, y = 1},\n\9\9{\"Sprite\", texture = global.texture.player.arm1, x = 2, y = 0},\n\9\9--[[{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = global.texture.player.head1,\n\9\9},]]\n\9}\n\9args.usesAnimation = true\n\9args.noSizeArea = true\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9game = global.state.game\n\n\9--this.head = this.gameObject:addSprite({texture = global.texture.player.head1, x = 7, y = 1})\n\9--this.body = this.gameObject:addSprite({texture = global.texture.player.body, x = 4, y = 0})\n\9--this.arm = this.gameObject:addSprite({texture = global.texture.player.arm1, x = 2, y = 0})\n\n\9\n\9--this.legs = this.gameObject:addSprite({texture = global.animation.legs, x = 6, y = 14})\n\9--this.legs:stop()\n\9\n\9\n\9--=== conf ===--\n\n\9--=== runtime vars ===--\n\9\n\9--===== custom functions =====--\n\9this.ctrl_player1_left_key_pressed = function()\n\9\9this:move(-1, 0)\n\9end\n\9this.ctrl_player1_right_key_pressed = function()\n\9\9this:move(1, 0)\n\9end\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\9\9\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/GameOverOverlay.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\nlocal game = global.state.game\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 32\n\9args.sizeY = 37\n\9args.components = { --Define the GameObjects components.\n\9\9--[[{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = global.texture.player.head1,\n\9\9},]]\n\9}\n\9args.usesAnimation = false\n\9args.noSizeArea = false\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9game = global.state.game\n\9\n\9--=== conf ===--\n\9this.startPosX = args.posX\n\9this.startPosY = args.posY\n\n\n\9--=== runtime vars ===--\n\9this.blinkDelay = 1\n\9this.lastBlinkTime = uptime()\n\9this.blinkStatus = true\n\9\n\9--===== custom functions =====--\n\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\9\9--global.log(game.gameIsRunning)\n\9\9if game.gameIsRunning and select(2, this:getPos()) < 1000 then\n\9\9\9this:moveTo(1000, 1000)\n\9\9elseif not game.gameIsRunning then\n\9\9\9this:moveTo(this.startPosX, this.startPosY)\n\9\9end\n\n\9\9if not game.gameIsRunning and uptime() - this.lastBlinkTime > this.blinkDelay then\n\9\9\9if this.blinkStatus then\n\9\9\9\9this.blinkStatus = false\n\9\9\9else\n\9\9\9\9this.blinkStatus = true\n\9\9\9end\n\9\9\9this.lastBlinkTime = uptime()\n\9\9\9this:rerender()\n\9\9end\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\9\9local posX, posY = this:getPos()\n\n\9\9if not game.gameIsRunning then\n\9\9\9local text = \"Game Over!\"\n\9\9\9local name = \">> \" .. tostring(game.winner) .. \" <<\"\n\9\9\9local endText = \"Is the Winner!\"\n\9\9\9local width = 30\n\n\9\9\9local resetKeys = \"R\"\n\9\9\9local resetText = \">> Press \" .. resetKeys .. \" to restart <<\"\n\n\9\9\9global.oclrl:draw(posX +1, posY +1, global.oclrl.generateTexture({\n\9\9\9\9{\"b\", 0x500000},\n\9\9\9\9{\"f\", 0xba5500},\n\9\9\9\9\n\9\9\9\9{2, 1, width - 2, 5, \" \"},\n\9\9\9\9{0, 0, width, 1, \"#\"},\n\9\9\9\9{0, 6, width, 1, \"#\"},\n\9\9\9\9{0, 0, 2, 6, \"#\"},\n\9\9\9\9{width, 0, 2, 7, \"#\"},\n\n\9\9\9\9{width / 2 - global.unicode.len(text) / 2, 2, text},\n\9\9\9\9{width / 2 - global.unicode.len(name) / 2, 3, name},\n\9\9\9\9{width / 2 - global.unicode.len(endText) / 2, 4, endText},\n\9\9\9}))\n\n\9\9\9if this.blinkStatus then\n\9\9\9\9global.oclrl:draw(posX +1, posY + 36, global.oclrl.generateTexture({\n\9\9\9\9\9{\"b\", 0xee6000},\n\9\9\9\9\9{\"f\", 0x705000},\n\9\9\9\9\9\n\9\9\9\9\9{width / 2 - global.unicode.len(resetText) / 2, 0, resetText}\n\9\9\9\9}))\n\9\9\9end\n\9\9end\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/Test2.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\nlocal game = global.state.game\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 100\n\9args.sizeY = 100\n\9args.components = { --Define the GameObjects components.\n\9\9{\"ClearArea\",\n\9\9\9x = 4,\n\9\9\9y = 0,\n\9\9\9sizeX = 13,\n\9\9\9sizeY = 17,\n\9\9},\n\9\9--{\"Sprite\", texture = global.texture.player.head1, x = 7, y = 1},\n\9\9{\"Sprite\", texture = global.texture.player.body, x = 4, y = 1},\n\9\9--{\"Sprite\", texture = global.texture.player.arm1, x = 2, y = 0},\n\9\9--[[{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = global.texture.player.head1,\n\9\9},]]\n\9}\n\9args.usesAnimation = true\n\9args.noSizeArea = true\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9game = global.state.game\n\n\9--this.head = this.gameObject:addSprite({texture = global.texture.player.head1, x = 7, y = 1})\n\9--this.body = this.gameObject:addSprite({texture = global.texture.player.body, x = 4, y = 0})\n\9--this.arm = this.gameObject:addSprite({texture = global.texture.player.arm1, x = 2, y = 0})\n\n\9\n\9--this.legs = this.gameObject:addSprite({texture = global.animation.legs, x = 6, y = 14})\n\9--this.legs:stop()\n\9\n\9\n\9--=== conf ===--\n\n\9--=== runtime vars ===--\n\9\n\9--===== custom functions =====--\n\9this.ctrl_player1_left_key_pressed = function()\n\9\9this:move(-1, 0)\n\9end\n\9this.ctrl_player1_right_key_pressed = function()\n\9\9this:move(1, 0)\n\9end\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\9\9\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/BloodContainer.lua"] = "local global = ...\n\nBloodContainer = {}\nBloodContainer.__index = BloodContainer\n\nfunction BloodContainer.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"BloodContainer: init\")\nend\n\nfunction BloodContainer.new(args)\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9--args.particle = \"TestParticle2\"\n\9args.type = 1\n\9args.useCollision = false\n\9args.updateAlways = true\n\9\n\9--===== default stuff =====--\n\9local this = global.parent.ParticleContainer.new(args)\n\9this = setmetatable(this, BloodContainer)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9--===== global functions =====--\n\9this.bloodExplosion = function(this, x, y, amount)\n\9\9this:addParticle(\"Blood\", x, y)\n\9end\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.stop = function(this) --will called when gameObject object becomes deloaded (e.g. out of screen)\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.activate = function(this) --will called when the gameObject get activated by player or signal (not implemented yet).\n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn BloodContainer",["./data/gameObjects/particles/Blood.lua"] = "local global = ...\n\nSmoke = {}\nSmoke.__index = Smoke\n\nfunction Smoke.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"Smoke: init\")\nend\n\nfunction Smoke.new(args)\n\9local pa = global.ut.parseArgs\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9args.name = \"Blood\"\n\9args.color = 0x8a0303\n\9args.lifeTime = pa(args.lt, args.lifeTime, args.maxLifeTime, 3)\n\9\n\9--===== default stuff =====--\n\9local this = global.parent.Particle.new(args)\n\9this = setmetatable(this, Smoke)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9this.rng = pa(args.rng, args.wind, 0)\n\9this.defaultParticleContainer = pa(args.dpc, args.defaultParticleContainer)\n\9\n\9this.stillAttached = -1\n\9this.objectType = \"Particle\"\n\9\n\9this.gameObject:addRigidBody({\n\9\9g = pa(g, 70), \n\9\9stiffness = 10,\n\9\9stickiness = 1, --.36, --.95,\n\9\9speedRetain = .9,\n\9})\n\9this.gameObject:addBoxTrigger({x = .25, y = .5, sx = .5, sy = .5, lf = function(collider, otherCollider)\n\9\9local this = collider.gameObject.parent\n\9\9local obj = otherCollider.gameObject.parent\n\9\9\n\9\9if obj.objectType ~= \"Particle\" and obj.particleContainer ~= nil and obj.particleContainer ~= this.container then\n\9\9\9local x, y = this.gameObject:getPos()\n\9\9\9obj.particleContainer:addParticle(\"Blood\", x, y, {dpc = this.defaultParticleContainer, clt = this.lifeTime})\n\9\9\9this:destroy()\n\9\9end\n\9\9\n\9\9cprint(debug.traceback())\n\9\9\n\9\9if obj.objectType ~= \"Particle\" then\n\9\9\9collider.gameObject:attach(otherCollider.gameObject)\n\9\9end\n\9\9this.stillAttached = 1\n\9end})\n\9\n\9--===== global functions =====--\n\9\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.stop = function(this) --will called when gameObject object becomes deloaded (e.g. out of screen)\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9local x = 0\n\9\9if math.random() > .5 then\n\9\9\9x = math.random()\n\9\9else\n\9\9\9x = -math.random()\n\9\9end\n\9\9\n\9\9this.gameObject:addForce(x *this.rng *dt, 0)\n\9\9\n\9\9if this.stillAttached == 0 then\n\9\9\9this.gameObject:detach()\n\9\9\9\n\9\9elseif this.stillAttached == 1 then\n\9\9\9this.stillAttached = 0\n\9\9end\n\n\9\9if select(2, this.gameObject:getPos()) > 50 then\n\9\9\9this:destroy()\n\9\9end\n\9\9\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.activate = function(this) --will called when the gameObject get activated by player or signal (not implemented yet).\n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn Smoke",["./data/gameObjects/particles/Fire.lua"] = "local global = ...\n\nSmoke = {}\nSmoke.__index = Smoke\n\nfunction Smoke.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"Smoke: init\")\nend\n\nfunction Smoke.new(args)\n\9local pa = global.ut.parseArgs\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9args.name = \"Smoke\"\n\9args.color = 0xffb600\n\9args.lifeTime = pa(args.lt, args.lifeTime, args.maxLifeTime, 1)\n\9\n\9if math.random() > .5 then\n\9\9args.lifeTime = math.max(args.lifeTime + math.random(pa(args.ltrng, args.lifeTimeRNG, .5) * 100) / 100, .2)\n\9else\n\9\9args.lifeTime = math.max(args.lifeTime - math.random(pa(args.ltrng, args.lifeTimeRNG, .5) * 100) / 100, .2)\n\9end\n\9\n\9--===== default stuff =====--\n\9local this = global.parent.Particle.new(args)\n\9this = setmetatable(this, Smoke)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9this.rng = pa(args.rng, args.wind, 20)\n\9\n\9this.gameObject:addRigidBody({g = -pa(args.heat, 20), speedLoss = 1})\n\9this.gameObject:addBoxCollider({y = .5, sx = 1, sy = .5})\n\9\n\9--this.name = pa(args.name, \"Smoke\")\n\9\n\9--===== global functions =====--\n\9\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.stop = function(this) --will called when gameObject object becomes deloaded (e.g. out of screen)\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9local x = 0\n\9\9if math.random() > .5 then\n\9\9\9x = math.random()\n\9\9else\n\9\9\9x = -math.random()\n\9\9end\n\9\9\n\9\9if dt > global.conf.maxTickTime then\n\9\9\9global.log(dt, global.dt)\n\9\9end\n\9\9\n\9\9this.gameObject:addForce(x *this.rng *dt, 0)\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.activate = function(this) --will called when the gameObject get activated by player or signal (not implemented yet).\n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn Smoke",["./data/gameObjects/particles/Dust.lua"] = "local global = ...\n\nSmoke = {}\nSmoke.__index = Smoke\n\nfunction Smoke.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"Smoke: init\")\nend\n\nfunction Smoke.new(args)\n\9local pa = global.ut.parseArgs\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9args.name = \"Smoke\"\n\9args.color = 0x1e1e1e\n\9args.lifeTime = pa(args.lt, args.lifeTime, args.maxLifeTime, 3)\n\9\n\9--===== default stuff =====--\n\9local this = global.parent.Particle.new(args)\n\9this = setmetatable(this, Smoke)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9this.rng = pa(args.rng, args.wind, 20)\n\9\n\9this.gameObject:addRigidBody({g = pa(args.weight, 20), speedLoss = 1})\n\9this.gameObject:addBoxCollider({y = .5, sx = 1, sy = .5})\n\9\n\9--this.name = pa(args.name, \"Smoke\")\n\9\n\9--===== global functions =====--\n\9\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.stop = function(this) --will called when gameObject object becomes deloaded (e.g. out of screen)\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9local x = 0\n\9\9if math.random() > .5 then\n\9\9\9x = math.random()\n\9\9else\n\9\9\9x = -math.random()\n\9\9end\n\9\9\n\9\9if dt > global.conf.maxTickTime then\n\9\9\9global.log(dt, global.dt)\n\9\9end\n\9\9\n\9\9this.gameObject:addForce(x *this.rng *dt, 0)\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.activate = function(this) --will called when the gameObject get activated by player or signal (not implemented yet).\n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn Smoke",["./data/gameObjects/particles/Smoke.lua"] = "local global = ...\n\nSmoke = {}\nSmoke.__index = Smoke\n\nfunction Smoke.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"Smoke: init\")\nend\n\nfunction Smoke.new(args)\n\9local pa = global.ut.parseArgs\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9args.name = \"Smoke\"\n\9args.color = 0x0000000\n\9args.lifeTime = pa(args.lt, args.lifeTime, args.maxLifeTime, 3)\n\9\n\9if math.random() > .5 then\n\9\9args.lifeTime = math.max(args.lifeTime + math.random(pa(args.ltrng, args.lifeTimeRNG, 1) * 100) / 100, .2)\n\9else\n\9\9args.lifeTime = math.max(args.lifeTime - math.random(pa(args.ltrng, args.lifeTimeRNG, 1) * 100) / 100, .2)\n\9end\n\9\n\9--===== default stuff =====--\n\9local this = global.parent.Particle.new(args)\n\9this = setmetatable(this, Smoke)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9this.rng = pa(args.rng, args.wind, 20)\n\9\n\9this.gameObject:addRigidBody({g = -pa(args.heat, 20), speedLoss = 1})\n\9this.gameObject:addBoxCollider({y = .5, sx = 1, sy = .5})\n\9\n\9--this.name = pa(args.name, \"Smoke\")\n\9\n\9--===== global functions =====--\n\9\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.stop = function(this) --will called when gameObject object becomes deloaded (e.g. out of screen)\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9local x = 0\n\9\9if math.random() > .5 then\n\9\9\9x = math.random()\n\9\9else\n\9\9\9x = -math.random()\n\9\9end\n\9\9\n\9\9if dt > global.conf.maxTickTime then\n\9\9\9global.log(dt, global.dt)\n\9\9end\n\9\9\n\9\9this.gameObject:addForce(x *this.rng *dt, 0)\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.activate = function(this) --will called when the gameObject get activated by player or signal (not implemented yet).\n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn Smoke",["./data/gameObjects/particles/"] = 0,["./data/gameObjects/DefaultParticleContainer.lua"] = "local global = ...\n\nParticleTestContainer = {}\nParticleTestContainer.__index = ParticleTestContainer\n\nfunction ParticleTestContainer.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"ParticleTestContainer: init\")\nend\n\nfunction ParticleTestContainer.new(args)\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9--args.particle = \"TestParticle2\"\n\9args.type = 1\n\9args.useCollision = false\n\9args.updateAlways = true\n\9\n\9--===== default stuff =====--\n\9local this = global.parent.ParticleContainer.new(args)\n\9this = setmetatable(this, ParticleTestContainer)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9--===== global functions =====--\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.stop = function(this) --will called when gameObject object becomes deloaded (e.g. out of screen)\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.activate = function(this) --will called when the gameObject get activated by player or signal (not implemented yet).\n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn ParticleTestContainer",["./data/gameObjects/Fire.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\nlocal game = global.state.game\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 1\n\9args.sizeY = 1\n\9args.components = { --Define the GameObjects components.\n\n\9}\n\9args.usesAnimation = false\n\9args.noSizeArea = false\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9game = global.state.game\n\n\9this.ParticleContainer = game.raMain:addGO()\n\9\n\9--=== conf ===--\n\n\9--=== runtime vars ===--\n\9\n\9--===== custom functions =====--\n\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\9\9\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/Background.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 160\n\9args.sizeY = 50\n\9args.components = { --Define the GameObjects components.\n\9\9{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = global.texture.background,\n\9\9},\n\9}\n\9args.usesAnimation = false\n\9args.deco = true\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\9\9\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/BackgroundTile.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9local texture = args.texture\n\n\9if type(texture) == \"string\" then\n\9\9texture = global.texture[texture]\n\9end\n\n\9assert(texture, \"Cant add GameObject. No valid texture/animation given.\")\n\n\9args.sizeX = texture.resX\n\9args.sizeY = texture.resY\n\9args.components = { --Define the GameObjects components.\n\9\9{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = texture,\n\9\9},\n\9}\n\9args.usesAnimation = false\n\9args.deco = true\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\9\9\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/BloodJet.lua"] = "local global = ...\n\nExhaust = {}\nExhaust.__index = Exhaust\n\nfunction Exhaust.init(this) --will calles when the gameObject become loaded/reloaded.\n\9--global.log(\"Exhaust: init\")\nend\n\nfunction Exhaust.new(args)\n\9--===== gameObject definition =====--\n\9args = args or {}\n\9--args.particle = \"TestParticle2\"\n\9args.type = 1\n\9args.useCollision = false\n\9args.updateAlways = true\n\9\n\9--===== default stuff =====--\n\9local this = nil\n\9\n\9if args.particleContainer ~= nil then\n\9\9this = args.particleContainer\n\9else\n\9\9this = global.parent.ParticleContainer.new(args)\n\9end\n\9\n\9this = setmetatable(this, Exhaust)\n\9\n\9--===== init =====--\n\9local pa = global.ut.parseArgs\n\9\n\9this.parent = args.parent\n\9this.smokeRate = global.ut.parseArgs(args.smokeRate, 2) * global.ut.parseArgs(global.conf.particles, 1)\n\9this.particle = args.particle or \"Blood\"\n\9this.width = pa(args.width)\n\9this.height = pa(args.height)\n\9this.offsetX = pa(args.ox, args.offsetX, 0)\n\9this.offsetY = pa(args.oy, args.offsetY, 0)\n\9this.upForce = pa(args.force, 0)\n\9this.upForceRange = pa(args.upForceRange, 0)\n\9this.sideForceRange = pa(args.sideForceRange, 0)\n\9\n\9this.pastTime = 0\n\9\n\9--===== global functions =====--\n\9this.setSmokeRate = function(this, sr)\n\9\9this.smokeRate = sr * global.ut.parseArgs(global.conf.particles, 1)\n\9end\n\9this.getSmokeRate = function(this)\n\9\9return this.smokeRate\n\9end\n\9\n\9--===== default functions =====--\n\9this.start = function(this) --will called everytime a new object of the gameObject is created.\n\9\9\n\9end\n\9\n\9this.update = function(this, dt, ra) --will called on every game tick.\n\9\9this.pastTime = this.pastTime + dt\n\9\9\n\9\9local x, y = this.parent:getPos()\n\9\9local toSpawn = math.floor(this.pastTime * this.smokeRate)\n\9\9this.pastTime = this.pastTime - toSpawn / this.smokeRate\n\9\9\n\9\9if this.pastTime ~= this.pastTime then \n\9\9\9this.pastTime = 0\n\9\9end\n\9\9\n\9\9for c = 1, toSpawn do\n\9\9\9--global.log(this.particle, x + this.parent.exhaustOffsetX, y + this.parent.exhaustOffsetY)\n\9\9\9local rx, ry = math.random(this.width) -1, math.random(this.height) -1\n\9\9\9local sideForce = math.random(-this.sideForceRange, this.sideForceRange)\n\9\9\9local upForce = math.random(-this.upForceRange, this.upForceRange)\n\9\9\9\n\9\9\9local particle = this:addParticle(this.particle, x + this.offsetX + rx, y + this.offsetY + ry)\n\9\9\9\n\9\9\9--particle.gameObject:setSpeed(this.parent:getSpeed())\n\9\9\9particle.gameObject:setSpeed(sideForce, - this.upForce + upForce)\n\9\9end\n\9end\n\9\n\9this.draw = function(this) --will called every time the gameObject will drawed.\n\9\9\n\9end\n\9\n\9this.clear = function(this, acctual) --will called when the sntity graphics are removed.\n\9\9\n\9end\n\9\n\9this.stop = function(this) \n\9\9\n\9end\n\9\n\9return this\nend\n\nreturn Exhaust",["./data/gameObjects/Player.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 24\n\9args.sizeY = 19\n\9args.components = { --Define the GameObjects components.#\n\9\9--[[\n\9\9{\"CopyArea\",\n\9\9\9x = 5,\n\9\9\9y = 0,\n\9\9\9sizeX = 12,\n\9\9\9sizeY = 17,\n\9\9},\n\9\9]]\n\9\9--[[{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = global.texture.player.head1,\n\9\9},]]\n\9}\n\9args.usesAnimation = true\n\9args.noSizeArea = false\n\9args.deco = true\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9this.bloodContainer = global.state.game.raMain:addGO(\"BloodContainer\", {\n\9\9layer = 5,\n\9})\n\n\9--=== textures / animations ===--\n\9this.head = this.gameObject:addSprite({texture = global.texture.player.head1, x = 8, y = 1})\n\9this.body = this.gameObject:addSprite({texture = global.texture.player.body, x = 7, y = 6})\n\9this.arm = this.gameObject:addSprite({texture = global.texture.player.arm1, x = 11, y = 6})\n\n\9\n\9this.legs = this.gameObject:addSprite({texture = global.animation.legs, x = 7, y = 13})\n\9this.legs:stop()\n\n\9if args.id == 2 then\n\9\9this.hat = this.gameObject:addSprite({texture = global.texture.player.hat, x = 8, y = 0})\n\9end\n\n\n\9this.bloodJet = global.state.game.raMain:addGO(\"BloodJet\", {\n\9\9parent = this,\n\9\9width = 5,\n\9\9height = 1,\n\9\9offsetX = 9,\n\9\9offsetY = 5,\n\9\9smokeRate = 0,\n\9\9sideForceRandom = 10,\n\9})\n\n\9--=== conf ===--\n\9this.hitFaceTime = .5\n\9this.punchArmTime = .5\n\9this.headLooseDelay = 0\n\9\n\9this.bloodPunchAmountMultiplier = .2\n\9this.bloodPunchForceMultiplier = .4\n\9\n\9this.bloodJetMultiplier = 100\n\9this.bloodJetForce = 60\n\9this.bloodJetTime = 6\n\9this.sideForceRange = 20\n\9this.upForceRange = 20\n\n\9this.speed = 40\n\9this.maxCharge = 100 --has to be 100\n\9this.chargeMultiplier = .5\n\9this.chargePerSecond = 100\n\n\9this.width = 10\n\9this.armRange = 10\n\9this.fistWidth = 2\n\n\9this.playerID = args.id\n\n\9this.name = args.name\n\n\n\9--=== runtime vars ===--\n\9this.lookingLeft = false\n\n\9this.punchStatus = 0 --0 == normal, 1 == chargin, 2 == punching\n\9this.charge = 0\n\n\9this.life = 100 --has to be 100\n\9this.actualSpeed = this.speed\n\9\n\9this.lastHitTime = 0\n\9this.chargeStartTime = uptime()\n\9this.punchTime = uptime()\n\9this.deathTime = uptime()\n\9this.bloodJetStartTime = uptime()\n\9\n\9--===== custom functions =====--\n\9this.ctrl_test_key_down = function(this)\n\9\9this:hit()\n\9end\n\n\9this.hit = function(this, charge)\n\9\9this.lastHitTime = uptime()\n\9\9this.life = this.life - charge * this.chargeMultiplier\n\n\9\9if this.life <= 0 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.head.texture = global.texture.player.head3_flipped\n\9\9\9else\n\9\9\9\9this.head.texture = global.texture.player.head3\n\9\9\9end\n\9\9\9this.deathTime = uptime()\n\9\9end\n\9end\n\n\9this.left = function(this)\n\9\9if this.life <= 0 and uptime() - this.bloodJetStartTime > this.bloodJetTime then\n\9\9\9return true\n\9\9end\n\9\9this:move(-this.actualSpeed * global.dt, 0)\n\9\9this.lookingLeft = true\n\9\9this.legs:play(-1)\n\9end\n\9this.right = function(this)\n\9\9if this.life <= 0 and uptime() - this.bloodJetStartTime > this.bloodJetTime then\n\9\9\9return true\n\9\9end\n\9\9this:move(this.actualSpeed * global.dt, 0)\n\9\9this.lookingLeft = false\n\9\9this.legs:play(1)\n\9end\n\n\9this.startCharging = function(this)\n\9\9this.charge = 0\n\9\9this.punchStatus = 1\n\9\9this.chargeStartTime = uptime()\n\9end\n\9this.punch = function(this)\n\9\9if this.punchStatus == 1 then\n\9\9\9this.punchStatus = 2\n\9\9\9this.punchTime = uptime()\n\n\9\9\9do\n\9\9\9\9local enemy\n\9\9\9\9local posX, posY = this:getPos()\n\9\9\9\9local enemyPosX\n\9\9\9\9local fistPosX\n\9\9\9\9\n\9\9\9\9if this.playerID == 1 then\n\9\9\9\9\9enemy = global.state.game.player2\n\9\9\9\9else\n\9\9\9\9\9enemy = global.state.game.player1\n\9\9\9\9end\n\n\9\9\9\9enemyPosX = enemy:getPos()\n\n\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9fistPosX = posX + 4 - this.armRange\n\9\9\9\9else\n\9\9\9\9\9fistPosX = posX + 6 + this.armRange\n\9\9\9\9end\n\n\9\9\9\9if fistPosX >= enemyPosX and fistPosX <= enemyPosX + this.width then\n\9\9\9\9\9local addedBloodForce = 0\n\9\9\9\9\9local particleAmount = this.charge * this.bloodPunchAmountMultiplier\n\n\9\9\9\9\9enemy:hit(math.min(this.charge, this.maxCharge))\n\n\9\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9\9addedBloodForce = - this.charge * this.bloodPunchForceMultiplier\n\9\9\9\9\9else\n\9\9\9\9\9\9addedBloodForce = this.charge * this.bloodPunchForceMultiplier\n\9\9\9\9\9end\n\n\9\9\9\9\9global.sfx.explosion(this.bloodContainer, fistPosX + 5, posY +5, \"Blood\", particleAmount, 3, {rng = 100}, addedBloodForce * .2)\n\9\9\9\9\9global.sfx.explosion(this.bloodContainer, fistPosX + 5, posY +5, \"Blood\", particleAmount, 6, {rng = 100}, addedBloodForce * .5)\n\9\9\9\9\9global.sfx.explosion(this.bloodContainer, fistPosX + 5, posY +5, \"Blood\", particleAmount, 10, {rng = 100}, addedBloodForce * .7)\n\9\9\9\9end\n\9\9\9end\n\n\9\9end\n\9end\n\n\9this.reset = function(this)\n\9\9local _, posY = this:getPos()\n\9\9\n\9\9this.life = 100\n\9\9this.charge = 0\n\9\9this.actualSpeed = this.speed\n\n\9\9this.bloodJet.smokeRate = 0\n\n\9\9if this.head.posY > 1000 then\n\9\9\9this.head:move(0, -1000)\n\9\9end\n\9\9if this.hat and this.hat.posY > 1000 then\n\9\9\9this.hat:move(0, -1000)\n\9\9end\n\9\9\n\9\9if this.playerID == 1 then\n\9\9\9this:moveTo(10, posY)\n\n\9\9\9this.lookingLeft = false\n\9\9else\n\9\9\9this:moveTo(130, posY)\n\n\9\9\9this.lookingLeft = true\n\9\9end\n\9end\n\n\n\9this.ctrl_player1_left_key_pressed = function()\n\9\9if this.playerID == 1 then\n\9\9\9this:left()\n\9\9end\n\9end\n\9this.ctrl_player1_right_key_pressed = function()\n\9\9if this.playerID == 1 then\n\9\9\9this:right()\n\9\9end\n\9end\n\n\9this.ctrl_player1_punch_key_down = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\9\9\n\9\9if this.playerID == 1 then\n\9\9\9this:startCharging()\n\9\9end\n\9end\n\9this.ctrl_player1_punch_key_up = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\n\9\9if this.playerID == 1 then\n\9\9\9this:punch()\n\9\9end\n\9end\n\n\9this.ctrl_player2_left_key_pressed = function()\n\9\9if this.playerID == 2 then\n\9\9\9this:left()\n\9\9end\n\9end\n\9this.ctrl_player2_right_key_pressed = function()\n\9\9if this.playerID == 2 then\n\9\9\9this:right()\n\9\9end\n\9end\n\n\9this.ctrl_player2_punch_key_down = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\n\9\9if this.playerID == 2 then\n\9\9\9this:startCharging()\n\9\9end\n\9end\n\9this.ctrl_player2_punch_key_up = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\9\9\n\9\9if this.playerID == 2 then\n\9\9\9this:punch()\n\9\9end\n\9end\n\n\9this.ctrl_reset_key_down = function()\n\9\9this:reset()\n\9end\n\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\9\9--global.log(args.name, this.charge)\n\n\9\9local posX, posY = this:getPos()\n\n\9\9if this.life <= 0 and uptime() - this.bloodJetStartTime > this.bloodJetTime then\n\9\9\9this.legs:stop(1)\n\9\9end\n\n\9\9if this.life <= 0 and uptime() - this.deathTime > this.headLooseDelay then\n\9\9\9local timeSinceJetStart = uptime() - this.bloodJetStartTime\n\9\9\9local bloodMultiplier = (this.bloodJetTime - timeSinceJetStart) / this.bloodJetTime\n\n\9\9\9if this.head.posY < 1000 then\n\9\9\9\9this.head:move(0, 1000)\n\9\9\9\9if this.hat then\n\9\9\9\9\9this.hat:move(0, 1000)\n\9\9\9\9end\n\9\9\9\9this.bloodJetStartTime = uptime()\n\9\9\9end\n\n\9\9\9this.bloodJet.smokeRate = math.max(this.bloodJetMultiplier * bloodMultiplier, 0)\n\9\9\9this.bloodJet.upForce = math.max(this.bloodJetForce * bloodMultiplier, 0)\n\9\9\9this.bloodJet.sideForceRange = math.max(this.sideForceRange * bloodMultiplier, 0)\n\9\9\9this.bloodJet.upForceRange = math.max(this.upForceRange * bloodMultiplier, 0)\n\n\9\9\9this.actualSpeed = this.speed * bloodMultiplier\n\9\9end\n\n\9\9if select(1, this:getLastPos()) == select(1, this:getPos()) then\n\9\9\9this.legs:stop()\n\9\9end\n\n\9\9if this.punchStatus == 2 and uptime() - this.punchTime > this.punchArmTime then\n\9\9\9this.punchStatus = 0\n\9\9\9this.charge = 0\n\9\9end\n\9\9if this.punchStatus == 1 then\n\9\9\9this.charge = math.min(this.charge + this.chargePerSecond * global.dt, this.maxCharge)\n\9\9end\n\9\9if this.punchStatus == 1 and this.charge >= this.maxCharge then\n\9\9\9this:punch()\n\9\9end\n\n\n\9\9if this.punchStatus == 0 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm.texture = global.texture.player.arm1_flipped\n\9\9\9\9this.arm:moveTo(posX + 10, posY + 6)\n\9\9\9else\n\9\9\9\9this.arm.texture = global.texture.player.arm1\n\9\9\9\9this.arm:moveTo(posX + 11, posY + 6)\n\9\9\9end\n\9\9elseif this.punchStatus == 1 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm.texture = global.texture.player.arm2_flipped\n\9\9\9\9this.arm:moveTo(posX + 11, posY + 6)\n\9\9\9else\n\9\9\9\9this.arm.texture = global.texture.player.arm2\n\9\9\9\9this.arm:moveTo(posX + 4, posY + 6)\n\9\9\9end\n\9\9elseif this.punchStatus == 2 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm.texture = global.texture.player.arm3_flipped\n\9\9\9\9this.arm:moveTo(posX, posY + 6)\n\9\9\9else\n\9\9\9\9this.arm.texture = global.texture.player.arm3\n\9\9\9\9this.arm:moveTo(posX + 11, posY + 6)\n\9\9\9end\n\9\9end\n\n\9\9if this.life > 0 then\n\9\9\9if uptime() - this.lastHitTime > this.hitFaceTime then\n\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9this.head.texture = global.texture.player.head1_flipped\n\9\9\9\9else\n\9\9\9\9\9this.head.texture = global.texture.player.head1\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9this.head.texture = global.texture.player.head2_flipped\n\9\9\9\9else\n\9\9\9\9\9this.head.texture = global.texture.player.head2\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9if this.life > 0 and this.playerID == 2 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.hat.texture = global.texture.player.hat_flipped\n\9\9\9else\n\9\9\9\9this.hat.texture = global.texture.player.hat\n\9\9\9end\n\9\9end\n\n\9\9if posX < -20 or posX > 390 then\n\9\9\9if not this.easter then\n\9\9\9\9local function resolve(action)\n\9\9\9\9\9local key\n\9\9\9\9\9for i, k in pairs(global.controls.k) do\n\9\9\9\9\9\9if k[1] == action then\n\9\9\9\9\9\9\9key = i\n\9\9\9\9\9\9\9break\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\9\9\9\9\9return key\n\9\9\9\9end\n\n\9\9\9\9local currentWorkingDir = global.shell.getWorkingDirectory()\n\9\9\9\9global.log(global.shell.setWorkingDirectory(currentWorkingDir .. \"/data/sf1\"))\n\9\9\9\9this.easter = true\n\n\9\9\9\9local suc, err = xpcall(loadfile(\"startGame.lua\"), debug.traceback, global.gpu)\n\9\9\9\9if not suc then\n\9\9\9\9\9global.fatal(err, debug.traceback())\n\9\9\9\9end\n\n\9\9\9\9global.state.game.raMain:rerenderAll()\n\9\9\9\9global.shell.setWorkingDirectory(currentWorkingDir)\n\9\9\9\9do --queue reset signals\n\9\9\9\9\9global.computer.pushSignal(\"key_down\", \"\", 0, resolve(\"reset\") or 1)\n\9\9\9\9\9global.core.eventHandler.resetPressedKeys()\n\9\9\9\9end\n\9\9\9end\n\9\9elseif posX > -190 and posX < 380 then\n\9\9\9this.easter = false\n\9\9end\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\9\9\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/Test.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\nlocal game = global.state.game\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 100\n\9args.sizeY = 100\n\9args.components = { --Define the GameObjects components.\n\9\9{\"ClearArea\",\n\9\9\9x = 4,\n\9\9\9y = 0,\n\9\9\9sizeX = 13,\n\9\9\9sizeY = 17,\n\9\9},\n\9\9{\"Sprite\", texture = global.texture.player.head1, x = 7, y = 1},\n\9\9--{\"Sprite\", texture = global.texture.player.body, x = 4, y = 1},\n\9\9--{\"Sprite\", texture = global.texture.player.arm1, x = 2, y = 0},\n\9\9--[[{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = global.texture.player.head1,\n\9\9},]]\n\9}\n\9args.usesAnimation = true\n\9args.noSizeArea = true\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9game = global.state.game\n\n\9--this.head = this.gameObject:addSprite({texture = global.texture.player.head1, x = 7, y = 1})\n\9--this.body = this.gameObject:addSprite({texture = global.texture.player.body, x = 4, y = 0})\n\9--this.arm = this.gameObject:addSprite({texture = global.texture.player.arm1, x = 2, y = 0})\n\n\9\n\9--this.legs = this.gameObject:addSprite({texture = global.animation.legs, x = 6, y = 14})\n\9--this.legs:stop()\n\9\n\9\n\9--=== conf ===--\n\n\9--=== runtime vars ===--\n\9\n\9--===== custom functions =====--\n\9this.ctrl_player1_left_key_pressed = function()\n\9\9this:move(-1, 0)\n\9end\n\9this.ctrl_player1_right_key_pressed = function()\n\9\9this:move(1, 0)\n\9end\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/Player copy.lua"] = "--[[\n    This file is a GameObject example for the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nlocal global = ... --Here we get global.\n\nGameObjectsTemplate = {}\nGameObjectsTemplate.__index = GameObjectsTemplate\n\n--Called once when the class is loaded by the engine.\nfunction GameObjectsTemplate.init(this) \n\9\nend\n\n--local aliaces \nlocal uptime = global.computer.uptime\n\n\n--Calles on the bject creation of the class. Here you define/initiate the class.\nfunction GameObjectsTemplate.new(args) \n\9--===== gameObject definition =====--\n\9--Take given GameObject args if present and prevents it from being nil if not.\n\9args = args or {} \n\n\9args.sizeX = 24\n\9args.sizeY = 19\n\9args.components = { --Define the GameObjects components.\n\9\9{\"ClearArea\",\n\9\9\9x = 4,\n\9\9\9y = 0,\n\9\9\9sizeX = 13,\n\9\9\9sizeY = 17,\n\9\9}\n\9\9--[[{\"Sprite\", \n\9\9\9x = 0, \n\9\9\9y = 0, \n\9\9\9--texture = \"exampleTexture\",\n\9\9\9texture = global.texture.player.head1,\n\9\9},]]\n\9}\n\9args.usesAnimation = true\n\9args.noSizeArea = true\n\9\n\9--===== default stuff =====--\n\9--Inheritance from the GameObject main class.\n\9local this = global.core.GameObject.new(args) \n\9this = setmetatable(this, GameObjectsTemplate) \n\9\n\9--===== init =====--\n\9--=== textures / animations ===--\n\9this.head = this.gameObject:addSprite({texture = global.texture.player.head1, x = 8, y = 1})\n\9this.body = this.gameObject:addSprite({texture = global.texture.player.body, x = 7, y = 6})\n\9this.arm = this.gameObject:addSprite({texture = global.texture.player.arm1, x = 11, y = 6})\n\n\9\n\9this.legs = this.gameObject:addSprite({texture = global.animation.legs, x = 7, y = 14})\n\9this.legs:stop()\n\n\9if args.id == 2 then\n\9\9this.hat = this.gameObject:addSprite({texture = global.texture.player.hat, x = 8, y = 0})\n\9end\n\n\n\9this.bloodJet = global.state.game.raMain:addGO(\"BloodJet\", {\n\9\9parent = this,\n\9\9width = 5,\n\9\9height = 1,\n\9\9offsetX = 9,\n\9\9offsetY = 5,\n\9\9smokeRate = 0,\n\9\9sideForceRandom = 10,\n\9})\n\n\9--=== conf ===--\n\9this.hitFaceTime = .5\n\9this.punchArmTime = .5\n\9this.headLooseDelay = .1\n\9\n\9this.bloodPunchAmountMultiplier = .2\n\9this.bloodPunchForceMultiplier = .4\n\9\n\9this.bloodJetMultiplier = 50\n\9this.bloodJetForce = 60\n\9this.bloodJetTime = 1\n\9this.sideForceRange = 20\n\9this.upForceRange = 20\n\n\9this.speed = 30\n\9this.maxCharge = 100 --has to be 100\n\9this.chargeMultiplier = 1\n\9this.chargePerSecond = 5\n\n\9this.width = 10\n\9this.armRange = 10\n\9this.fistWidth = 2\n\n\9this.playerID = args.id\n\n\9this.name = args.name\n\n\n\9--=== runtime vars ===--\n\9this.lookingLeft = false\n\n\9this.punchStatus = 0 --0 == normal, 1 == chargin, 2 == punching\n\9this.charge = 0\n\n\9this.life = 100\n\9this.actualSpeed = this.speed\n\9\n\9this.lastHitTime = uptime()\n\9this.chargeStartTime = uptime()\n\9this.punchTime = uptime()\n\9this.deathTime = uptime()\n\9this.bloodJetStartTime = uptime()\n\9\n\9--===== custom functions =====--\n\9this.ctrl_test_key_down = function(this)\n\9\9this:hit()\n\9end\n\n\9this.hit = function(this, charge)\n\9\9this.lastHitTime = uptime()\n\9\9this.life = this.life - charge * this.chargeMultiplier\n\n\9\9if this.life <= 0 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.head.texture = global.texture.player.head3_flipped\n\9\9\9else\n\9\9\9\9this.head.texture = global.texture.player.head3\n\9\9\9end\n\9\9\9this.deathTime = uptime()\n\9\9end\n\9end\n\n\9this.left = function(this)\n\9\9if this.life <= 0 and uptime() - this.bloodJetStartTime > this.bloodJetTime then\n\9\9\9return true\n\9\9end\n\n\9\9if not this.lookingLeft then\n\9\9\9this.arm:move(-1, 0)\n\9\9end\n\9\9this:move(-this.actualSpeed * global.dt, 0)\n\9\9this.lookingLeft = true\n\9\9this.legs:play(-1)\n\9end\n\9this.right = function(this)\n\9\9if this.life <= 0 and uptime() - this.bloodJetStartTime > this.bloodJetTime then\n\9\9\9return true\n\9\9end\n\n\9\9if this.lookingLeft then\n\9\9\9this.arm:move(1, 0)\n\9\9end\n\9\9this:move(this.actualSpeed * global.dt, 0)\n\9\9this.lookingLeft = false\n\9\9this.legs:play(1)\n\9end\n\n\9this.startCharging = function(this)\n\9\9this.charge = 0\n\9\9this.punchStatus = 1\n\9\9if this.lookingLeft then\n\9\9\9this.arm:move(1, 0)\n\9\9else\n\9\9\9this.arm:move(-7, 0)\n\9\9end\n\9\9this.chargeStartTime = uptime()\n\9end\n\9this.punch = function(this)\n\9\9if this.punchStatus == 1 then\n\9\9\9this.punchStatus = 2\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm:move(-11, 0)\n\9\9\9else\n\9\9\9\9this.arm:move(7, 0)\n\9\9\9end\n\9\9\9this.punchTime = uptime()\n\n\9\9\9do\n\9\9\9\9local enemy\n\9\9\9\9local posX, posY = this:getPos()\n\9\9\9\9local enemyPosX\n\9\9\9\9local fistPosX\n\9\9\9\9\n\9\9\9\9if this.playerID == 1 then\n\9\9\9\9\9enemy = global.state.game.player2\n\9\9\9\9else\n\9\9\9\9\9enemy = global.state.game.player1\n\9\9\9\9end\n\n\9\9\9\9enemyPosX = enemy:getPos()\n\n\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9fistPosX = posX + 5 - this.armRange\n\9\9\9\9else\n\9\9\9\9\9fistPosX = posX + 5 + this.armRange\n\9\9\9\9end\n\n\9\9\9\9if fistPosX >= enemyPosX and fistPosX <= enemyPosX + this.width then\n\9\9\9\9\9local addedBloodForce = 0\n\9\9\9\9\9local particleAmount = this.charge * this.bloodPunchAmountMultiplier\n\n\9\9\9\9\9enemy:hit(math.min(this.charge, this.maxCharge))\n\n\9\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9\9addedBloodForce = - this.charge * this.bloodPunchForceMultiplier\n\9\9\9\9\9else\n\9\9\9\9\9\9addedBloodForce = this.charge * this.bloodPunchForceMultiplier\n\9\9\9\9\9end\n\n\9\9\9\9\9global.sfx.explosion(global.state.game.bloodContainer, fistPosX + 5, posY +5, \"Blood\", particleAmount, 3, {rng = 100}, addedBloodForce)\n\9\9\9\9\9global.sfx.explosion(global.state.game.bloodContainer, fistPosX + 5, posY +5, \"Blood\", particleAmount, 6, {rng = 100}, addedBloodForce)\n\9\9\9\9\9global.sfx.explosion(global.state.game.bloodContainer, fistPosX + 5, posY +5, \"Blood\", particleAmount, 10, {rng = 100}, addedBloodForce)\n\9\9\9\9end\n\9\9\9end\n\n\9\9end\n\9end\n\n\9this.reset = function(this)\n\9\9local _, posY = this:getPos()\n\9\9\n\9\9this.life = 100\n\9\9this.charge = 0\n\9\9this.actualSpeed = this.speed\n\n\9\9this.bloodJet.smokeRate = 0\n\n\9\9if this.head.posY > 1000 then\n\9\9\9this.head:move(0, -1000)\n\9\9end\n\9\9if this.hat and this.hat.posY > 1000 then\n\9\9\9this.hat:move(0, -1000)\n\9\9end\n\9\9\n\9\9if this.playerID == 1 then\n\9\9\9this:moveTo(10, posY)\n\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm:move(2, 0)\n\9\9\9end\n\n\9\9\9this.lookingLeft = false\n\9\9else\n\9\9\9this:moveTo(130, posY)\n\n\9\9\9if not this.lookingLeft then\n\9\9\9\9this.arm:move(-2, 0)\n\9\9\9end\n\n\9\9\9this.lookingLeft = true\n\9\9end\n\9end\n\n\n\9this.ctrl_player1_left_key_pressed = function()\n\9\9if this.playerID == 1 then\n\9\9\9this:left()\n\9\9end\n\9end\n\9this.ctrl_player1_right_key_pressed = function()\n\9\9if this.playerID == 1 then\n\9\9\9this:right()\n\9\9end\n\9end\n\n\9this.ctrl_player1_punch_key_down = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\9\9\n\9\9if this.playerID == 1 then\n\9\9\9this:startCharging()\n\9\9end\n\9end\n\9this.ctrl_player1_punch_key_up = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\n\9\9if this.playerID == 1 then\n\9\9\9this:punch()\n\9\9end\n\9end\n\n\9this.ctrl_player2_left_key_pressed = function()\n\9\9if this.playerID == 2 then\n\9\9\9this:left()\n\9\9end\n\9end\n\9this.ctrl_player2_right_key_pressed = function()\n\9\9if this.playerID == 2 then\n\9\9\9this:right()\n\9\9end\n\9end\n\n\9this.ctrl_player2_punch_key_down = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\n\9\9if this.playerID == 2 then\n\9\9\9this:startCharging()\n\9\9end\n\9end\n\9this.ctrl_player2_punch_key_up = function()\n\9\9if this.life <= 0 then\n\9\9\9return true\n\9\9end\n\9\9\n\9\9if this.playerID == 2 then\n\9\9\9this:punch()\n\9\9end\n\9end\n\n\9this.ctrl_reset_key_down = function()\n\9\9this:reset()\n\9end\n\n\9\n\9--===== default functions =====--\n\9--Called when this GameObject is added to a RenderArea.\n\9this.start = function(this) \n\9\9\n\9end\n\9\n\9--Called up to once a frame.\n\9this.update = function(this, dt, ra) \n\9\9--global.log(args.name, this.charge)\n\n\9\9if this.life <= 0 and uptime() - this.bloodJetStartTime > this.bloodJetTime then\n\9\9\9this.legs:stop(1)\n\9\9end\n\n\9\9if this.life <= 0 and uptime() - this.deathTime > this.headLooseDelay then\n\9\9\9local timeSinceJetStart = uptime() - this.bloodJetStartTime\n\9\9\9local bloodMultiplier = (this.bloodJetTime - timeSinceJetStart) / this.bloodJetTime\n\n\9\9\9if this.head.posY < 1000 then\n\9\9\9\9this.head:move(0, 1000)\n\9\9\9\9if this.hat then\n\9\9\9\9\9this.hat:move(0, 1000)\n\9\9\9\9end\n\9\9\9\9this.bloodJetStartTime = uptime()\n\9\9\9end\n\n\9\9\9this.bloodJet.smokeRate = math.max(this.bloodJetMultiplier * bloodMultiplier, 0)\n\9\9\9this.bloodJet.upForce = math.max(this.bloodJetForce * bloodMultiplier, 0)\n\9\9\9this.bloodJet.sideForceRange = math.max(this.sideForceRange * bloodMultiplier, 0)\n\9\9\9this.bloodJet.upForceRange = math.max(this.upForceRange * bloodMultiplier, 0)\n\n\9\9\9this.actualSpeed = this.speed * bloodMultiplier\n\9\9end\n\n\9\9if select(1, this:getLastPos()) == select(1, this:getPos()) then\n\9\9\9this.legs:stop()\n\9\9end\n\n\9\9if this.punchStatus == 2 and uptime() - this.punchTime > this.punchArmTime then\n\9\9\9this.punchStatus = 0\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm:move(10, 0)\n\9\9\9end\n\9\9\9this.charge = 0\n\9\9end\n\9\9if this.punchStatus == 1 then\n\9\9\9this.charge = math.min(this.charge + this.chargePerSecond * global.dt, this.maxCharge)\n\9\9end\n\9\9if this.punchStatus == 1 and this.charge >= this.maxCharge then\n\9\9\9this:punch()\n\9\9end\n\n\9\9if this.punchStatus == 0 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm.texture = global.texture.player.arm1_flipped\n\9\9\9else\n\9\9\9\9this.arm.texture = global.texture.player.arm1\n\9\9\9end\n\9\9elseif this.punchStatus == 1 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm.texture = global.texture.player.arm2_flipped\n\9\9\9else\n\9\9\9\9this.arm.texture = global.texture.player.arm2\n\9\9\9end\n\9\9elseif this.punchStatus == 2 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.arm.texture = global.texture.player.arm3_flipped\n\9\9\9else\n\9\9\9\9this.arm.texture = global.texture.player.arm3\n\9\9\9end\n\9\9end\n\n\9\9if this.life > 0 then\n\9\9\9if uptime() - this.lastHitTime > this.hitFaceTime then\n\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9this.head.texture = global.texture.player.head1_flipped\n\9\9\9\9else\n\9\9\9\9\9this.head.texture = global.texture.player.head1\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9if this.lookingLeft then\n\9\9\9\9\9this.head.texture = global.texture.player.head2_flipped\n\9\9\9\9else\n\9\9\9\9\9this.head.texture = global.texture.player.head2\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9if this.life > 0 and this.playerID == 2 then\n\9\9\9if this.lookingLeft then\n\9\9\9\9this.hat.texture = global.texture.player.hat_flipped\n\9\9\9else\n\9\9\9\9this.hat.texture = global.texture.player.hat\n\9\9\9end\n\9\9end\n\9end\n\9\n\9--[[Called every time the GameObject is drawed. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.draw = function(this) \n\9\9\n\9end\n\9\n\9--[[Called every time the GameObject graphics are removed from the screen. \n\9\9That can happen multiple times a frame if the GameObject is visible in multiple RenderAreas.\n\9]]\n\9this.clear = function(this, acctual) \n\9\9\n\9end\n\9\n\9--Called when this GameObject is removed from a RenderArea.\n\9this.stop = function(this) \n\9end\n\9\n\9return this\nend\n\nreturn GameObjectsTemplate\n",["./data/gameObjects/"] = 0,["./data/sp1/startGame.lua"] = "local shell = require(\"shell\")\nlocal currentWorkingDir = shell.getWorkingDirectory()\nshell.setWorkingDirectory(currentWorkingDir .. \"/data\")\n\n_G.gpuProxy = loadfile(\"libs/dbgpu_api.lua\")({directDraw = false})\nlocal suc, err = xpcall(loadfile(\"game.lua\"), debug.traceback, true)\n\nif not suc then\n    print(err, debug.traceback())\nend\n\nshell.setWorkingDirectory(currentWorkingDir)",["./data/sp1/controls.ini"] = "# StreetFucker controls.\n# Only one key per action supported.\n\n[game]\nreset=r\nquit=q\n\n[player1]\nleft=a\nright=d\npunch= \n\n[player2]\nleft=j\nright=l\npunch=0",["./data/sp1/data/player.lua"] = "local Player = {}\13\n\13\nPlayer.left = nil\13\nPlayer.right = nil\13\nPlayer.punch = nil\13\n\13\nPlayer.posX = 0\13\nPlayer.posY = 13\13\n\13\nPlayer.life = 32\13\nPlayer.maxLife = 32\13\nPlayer.charge = 0\13\nPlayer.maxCharge = 32\13\n\13\nPlayer.oldPosX = Player.posX\13\nPlayer.oldPosY = Player.posY\13\n\13\nPlayer.keyboard = require(\"keyboard\")\13\n\13\nPlayer.looksLeft = false\13\nPlayer.isPunching = false\13\nPlayer.isCharging = false\13\n\13\nPlayer.face = 10\13\nPlayer.punchTime = 2\13\nPlayer.punchCount = 0\13\n\13\nPlayer.clearArm2 = false\13\nPlayer.clearArm3 = false\13\n\13\nfunction Player:Start()\13\n\13\nend\13\n\13\nfunction Player:Update()\13\n\9Player.oldPosX = Player.posX\13\n\9Player.oldPosX = Player.posX\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.right) and Player.isPunching == false then\13\n\9\9Player.posX = Player.posX +1\13\n\9\9Player.TurnAround(false)\13\n\9end\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.left) and Player.isPunching == false then\13\n\9\9Player.posX = Player.posX -1\13\n\9\9Player.TurnAround(true)\13\n\9end\13\n\9\13\n\9if Player.keyboard.isKeyDown(Player.punch) and Player.isPunching == false and Player.charge < Player.maxCharge then --Charge\13\n\9\9Player.isCharging = true\13\n\9\9if Player.charge < Player.maxCharge then\13\n\9\9\9Player.charge = Player.charge +2\13\n\9\9end\13\n\9elseif Player.isCharging then --Activate punch\13\n\9\9Player.isCharging = false\13\n\9\9Player.clearArm2 = true\13\n\9\9Player.isPunching = true\13\n\9end\13\n\9\13\n\9if Player.isPunching and Player.punchCount == Player.punchTime then --Reset punch\13\n\9\9Player.isPunching = false\13\n\9\9Player.clearArm3 = true\13\n\9\9Player.punchCount = 0\13\n\9\9Player.charge = 0\13\n\9elseif Player.isPunching then\13\n\9\9Player.punchCount = Player.punchCount +1\13\n\9end\13\n\13\n\9if Player.posX < 0 or Player.posX > 80 then\13\n\9\9os.exit()\13\n\9end\13\nend\13\n\13\nfunction Player.TurnAround(lookLeft) \13\n\9if lookLeft then\13\n\9\9Player.looksLeft = true\13\n\9\9\13\n\9\9Player.body.aSet[Player.face][3] = \"o  \"\13\n\9\9Player.arm1.aSet = {\13\n\9\9\9[1] = {2, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9\9Player.arm2.aSet = {\13\n\9\9\9[1] = {4, 4, \"B\", 0x000000, 0xbbbb00},\13\n\9\9\9[2] = {6, 4, \"  \", 0x000000, 0x0000ff},\13\n\9\9}\13\n\9\9Player.arm3.aSet = {\13\n\9\9\9[2] = {-4, 3, \"     \", 0x000000, 0x0000ff},\13\n\9\9\9[3] = {-5, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9else\13\n\9\9Player.looksLeft = false\13\n\9\9\13\n\9\9Player.body.aSet[Player.face][3] = \"  o\"\13\n\9\9Player.arm1.aSet = {\13\n\9\9\9[1] = {4, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9\9Player.arm2.aSet = {\13\n\9\9\9[1] = {2, 4, \"B\", 0x000000, 0xbbbb00},\13\n\9\9\9[2] = {-1, 4, \"  \", 0x000000, 0x0000ff},\13\n\9\9}\13\n\9\9Player.arm3.aSet = {\13\n\9\9\9[2] = {6, 3, \"     \", 0x000000, 0x0000ff},\13\n\9\9\9[3] = {11, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9\9}\13\n\9end\13\nend\13\n\13\nPlayer.body = {\13\n\9fillSize = 100,\13\n\9aFill = {\13\n\9\9[1] = {1, 3, 5, 3, \" \", 0x000000, 0x0000ff}, --Body\13\n\9\9\13\n\9\9[2] = {2, 7, 1, 3, \" \", 0x000000, 0x00aa00}, --Legs\13\n\9\9[3] = {4, 7, 1, 3, \" \"},\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 100,\13\n\9aSet = {\13\n\9\9[1] = {2, 1, \"   \", 0x000000, 0x7f2f11}, --Head\13\n\9\9--[2] = {} Payer2\13\n\9\9\13\n\9\9[10] = {2, 2, \"  o\", 0x000000, 0xbbbb00}, --Face\13\n\9\9\13\n\9\9[3] = {1, 6, \"     \", 0x000000, 0x00aa00}, --Leg\13\n\9\9\13\n\9\9[11] = {2, 9, \" \", 0x000000, 0x4f1f01}, --Shoe\13\n\9\9[12] = {4, 9, \" \"}, --Shoe\13\n\9\9\13\n\9},\13\n}\13\n\13\nPlayer.arm1 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 1,\13\n\9aSet = {\13\n\9\9[1] = {4, 6, \"B\", 0x000000, 0xbbbb00},\13\n\9},\13\n}\13\n\13\nPlayer.arm2 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 2,\13\n\9aSet = {\13\n\9\9\13\n\9},\13\n}\13\n\13\nPlayer.arm3 = {\13\n\9fillSize = 1,\13\n\9aFill = {\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 3,\13\n\9aSet = {\13\n\9\9[2] = {6, 3, \"    \", 0x000000, 0x0000ff},\13\n\9\9[3] = {10, 3, \"B\", 0x000000, 0xbbbb00},\13\n\9},\13\n}\13\n\13\n\13\nreturn Player\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n",["./data/sp1/data/background.lua"] = "local b = {}--Backgound\13\n\13\nb.street = {\13\n\9fillSize = 100,\13\n\9aFill = {\13\n\9\9[1] = {0, -17, 80, 25, \" \", 0x000000, 0x00509f},\13\n\9\9[2] = {0, 1, 80, 7, \" \", 0x000000, 0x666666},\13\n\9\9\13\n\9\9\13\n\9\9[9] = {5, -7, 7, 8, \" \", 0x00ff00, 0x777788},\13\n\9\9\13\n\9\9[11] = {22, -8, 2, 8, \" \", 0x00ff00, 0x878798},\13\n\9\9[12] = {39, -8, 2, 8, \" \"},\13\n\9\9[13] = {22, -9, 19, 7, \" \"},\13\n\9\9\13\n\9\9[14] = {24, -8, 15, 5, \"#\", 0xffe900, 0xdf00af},\13\n\9\9[15] = {6, -6, 5, 4, \"#\", 0x00dd00, 0xee0000},\13\n\9\9\13\n\9\9[16] = {46, -8, 1, 8, \" \", 0x00ff00, 0xb1bcdb},\13\n\9\9\13\n\9\9[17] = {53, -8, 2, 8, \"|\", 0x989bae, 0x9daac1},\13\n\9\9[18] = {55, -8, 27, 8, \" \", 0x989bae, 0x3581aa},\13\n\9\9[19] = {70, -8, 1, 8, \"|\", 0x989bae, 0x9daac1},\13\n\9\9\13\n\9\9\13\n\9},\13\n\9\13\n\9setSize = 40,\13\n\9aSet = {\13\n\9\9--[10] = {0, -1, \"    |         |         |         |         |         |         |         |     \", 0x434343, 0x444444},\13\n\9\9[11] = {0, 8, \"       |         |         |         |         |         |         |         |  \", 0x434343, 0x444444},\13\n\9\9[12] = {0, 0, \"    |         |         |         |         |         |         |         |     \", 0x333333, 0x404040},\13\n\9\9[2] = {3, 4, \"        \", 0x000000, 0xbbbbbb},\13\n\9\9[3] = {22, 4, \"        \"},\13\n\9\9[4] = {41, 4, \"        \"},\13\n\9\9[5] = {60, 4, \"        \"},\13\n\9\9[6] = {79, 4, \" \"},\13\n\9\9\13\n\9\9[20] = {14, -3, \"\\\\    /\", 0x3f3f3f, 0x555555},\13\n\9\9[21] = {15, -2, \"IHHI\"},\13\n\9\9[22] = {15, -1, \"IHHI\"},\13\n\9\9\13\n\9\9[23] = {45, -9, \" # \", 0xaaaaaa, 0xcc2222},\13\n\9\9[24] = {44, -8, \" ### \", 0x555555, 0xdddddd},\13\n\9\9[25] = {45, -7, \" # \", 0xaaaaaa, 0x4455dd},\13\n\9\9\13\n\9\9[26] = {51, -9, \"/=vv===============v==========\", 0x989bae, 0x9daac1},\13\n\9\9\13\n\9\9[27] = {59, -2, \"                  \", 0x989bae, 0x4d310c},\13\n\9\9\13\n\9\9[28] = {61, -1, \" \", 0x989bae, 0x4c1501},\13\n\9\9[29] = {74, -1, \" \"},\13\n\9\9\13\n\9},\13\n}\13\n\13\nreturn b",["./data/sp1/data/deltaTime.lua"] = "local Delta = {}\13\nlocal computer = require(\"computer\")\13\n\13\nDelta.time = 0\13\nDelta.previousDeltaTime = 0\13\n\13\nfunction Delta:Set() \13\n\9Delta.time = os.difftime(computer.uptime(), Delta.previousDeltaTime)\13\n\9Delta.time = Delta.time / 70 * 1000\13\n\9Delta.previousDeltaTime = computer.uptime()\13\nend\13\n\13\n\13\nreturn Delta",["./data/sp1/data/libs/UT.lua"] = "--[[\13\n    UT Copyright (C) 2019-2020 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[UsefullThings libary\13\n\9\13\n]]\13\nlocal UT = {version = \"v0.7.2\"}\13\n\13\nfunction UT.parseArgs(...) --returns the first non nil parameter.\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction UT.seperatePath(path) --seperates a data path [\"./DIR/FILE.ENDING\"] into the dir path [\"./DIR/\"], the file name [\"FILE\"], and the file ending [\".ENDING\" or nil]\13\n\9if string.sub(path, #path) == \"/\" then\13\n\9\9return path\13\n\9end\13\n\9\13\n\9local dir, fileName, fileEnd = \"\", \"\", nil\13\n\9local tmpLatest = \"\"\13\n\9for s in string.gmatch(tostring(path), \"[^/]+\") do\13\n\9\9tmpLatest = s\13\n\9end\13\n\9dir = string.sub(path, 0, #path -#tmpLatest)\13\n\9for s in string.gmatch(tostring(tmpLatest), \"[^.]+\") do\13\n\9\9fileName = fileName .. s\13\n\9\9tmpLatest = s\13\n\9end\13\n\9if fileName == tmpLatest then\13\n\9\9fileName = tmpLatest\13\n\9else\13\n\9\9fileEnd = \".\" .. tmpLatest\13\n\9\9fileName = string.sub(fileName, 0, #fileName - #fileEnd +1)\13\n\9end\13\n\9\13\n\9return dir, fileName, fileEnd\13\nend\13\n\13\nfunction UT.getChars(s) --returns a array with the chars of the string.\13\n\9local chars = {}\13\n\9for c = 1, #s do\13\n\9\9chars[c] = string.sub(s, c, c)\13\n\9end\13\n\9return chars\13\nend\13\n\13\nfunction UT.makeString(c) --genetares a string from and array of chars/strings.\13\n\9local s = \"\"\13\n\9for c, v in ipairs(c) do\13\n\9\9s = s ..v\13\n\9end\13\n\9return s\13\nend\13\n\13\nfunction UT.inputCheck(m, c) --checks if a array (m) contains a value (c).\13\n\9for _, v in pairs(m) do\13\n\9\9if v == c then\13\n\9\9\9return true\13\n\9\9end\13\n\9end\13\n\9return false\13\nend\13\n\13\nfunction UT.fillString(s, amout, c) --fills a string (s) up with a (amout) of chars/strings (c).\13\n\9local s2 = s\13\n\9for c2 = 1, amout, 1 do\13\n\9\9s2 = s2 .. c\13\n\9end\13\n\9return s2\13\nend\13\n\13\n--[[Converts a table or an other variable type to a readable stirng.\13\n\9This is a modified \"Universal tostring\" routine from \"lua-users.org\".\13\n\9Original source code: <http://lua-users.org/wiki/TableSerialization>\13\n]]\13\nfunction UT.tostring(var, lineBreak, indent, done, internalRun) \13\n\9if internalRun == false or internalRun == nil then\13\n\9\9if type(var) == \"table\" then\13\n\9\9\9UT.tostring(var, lineBreak, indent, done, true)\13\n\9\9else\13\n\9\9\9return tostring(var)\13\n\9\9end\13\n\9end\13\n\9\13\n\9done = done or {}\13\n\9indent = indent or 2\13\n\9local lbString\13\n\9if lineBreak or lineBreak == nil then\13\n\9\9lbString = \"\\n\"\13\n\9\9lineBreak = true\13\n\9else\13\n\9\9lbString = \" \"\13\n\9end\13\n\9if type(var) == \"table\" then\13\n\9\9local sb = {}\13\n\9\9if not internalRun then\13\n\9\9\9table.insert(sb, \"{\" .. lbString)\13\n\9\9end\13\n\9\9for key, value in pairs (var) do\13\n\9\9\9if lineBreak then\13\n\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9end\13\n\9\9\9if type (value) == \"table\" and not done [value] then\13\n\9\9\9\9done [value] = true\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, \"[\" .. key .. \"] = {\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"[\" .. key .. \"] = {\");\13\n\9\9\9\9end\13\n\9\9\9\9table.insert(sb, UT.tostring(value, lineBreak, indent + 2, done, true))\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9\9\9table.insert(sb, \"},\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"},\");\13\n\9\9\9\9end\13\n\9\9\9elseif \"number\" == type(key) then\13\n\9\9\9\9table.insert(sb, string.format(\"[%s] = \", tostring(key)))\13\n\9\9\9\9table.insert(sb, string.format(\"\\\"%s\\\",\" .. lbString, tostring(value)))\13\n\9\9\9else\13\n\9\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9\9table.insert(sb, \" \")\13\n\9\9\9\9end\13\n\9\9\9\9table.insert(sb, string.format(\"%s = \\\"%s\\\",\" .. lbString, \"[\" .. tostring (key) .. \"]\", tostring(value)))\13\n\9\9\9end\13\n\9\9end\13\n\9\9if not internalRun then\13\n\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9table.insert(sb, \" }\")\13\n\9\9\9else\13\n\9\9\9\9table.insert(sb, \"}\")\13\n\9\9\9end\13\n\9\9end\13\n\9\9return table.concat(sb)\13\n\9else\13\n\9\9return var .. lbString\13\n\9end\13\nend\13\n\13\nreturn UT",["./data/sp1/data/libs/dbgpu_api.lua"] = "--[[\13\n\9!The api is not complete yet!\13\n\9\13\n\9This is a little api to make the DoubleBuffering libarry by IgorTimofeev acting like a normal OC gpu.\13\n\9\13\n\9With the default settings it is acting (nearly) exacly like a normal OC gpu (so its basicly useless).\13\n\9To get the full effect of the DoubleBuffering you should deactivate directDraw but then you manually need to use the drawChanges function.\13\n\9\13\n\9DoubleBuffering source: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n\9DoubleBuffering Copyright (c) 2018 Igor Timofeev\13\n\9\13\n\9dbgpu_api Copyright (c) 2019 NosPo Studio\13\n\9\13\n    dbgpu_api is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    dbgpu_api is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with dbgpu_api.  If not, see <https://www.gnu.org/licenses/>.\9\13\n]]\13\n\13\nlocal version = \"v0.3.1\"\13\n\13\nlocal args = ...\13\nlocal path = args.path or \"\"\13\n\13\nlocal buffer = require(path .. \"libs/DoubleBuffering\")\13\nlocal gpu = require(\"component\").gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal ut = require(\"libs/UT\")\13\n\13\nlocal lastBackground = gpu.getBackground()\13\nlocal lastForeground = gpu.getForeground()\13\n\13\nlocal currentVBuffer = 0\13\nlocal cpuBuffers = {}\13\n\13\nif gpu.getActiveBuffer then\13\n\9currentVBuffer = gpu.getActiveBuffer()\13\nend\13\n\13\nlocal function flushBuffer(id, w, h)\13\n\9cpuBuffers[id] = {\13\n\9\9drawLimit = {1, 1, w, h},\13\n\9\9current = {{}, {}, {}, w, h},\13\n\9\9new = {{}, {}, {}, w, h},\13\n\9}\13\n\9\13\n\9for y = 1, h do\13\n\9\9for x = 1, w do\13\n\9\9\9table.insert(cpuBuffers[id].current[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].current[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].current[3], \" \")\13\n\9\13\n\9\9\9table.insert(cpuBuffers[id].new[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].new[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].new[3], \" \")\13\n\9\9end\13\n\9end\13\nend\13\nlocal function setBuffer(id)\13\n\9cpuBuffers[currentVBuffer].drawLimit = {buffer.getDrawLimit()}\13\n\9\13\n\9buffer.setCurrentFrameTables(cpuBuffers[id].current[1], cpuBuffers[id].current[2], cpuBuffers[id].current[3], cpuBuffers[id].current[4], cpuBuffers[id].current[5])\13\n\9buffer.setNewFrameTables(cpuBuffers[id].new[1], cpuBuffers[id].new[2], cpuBuffers[id].new[3], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9buffer.setDrawLimit(cpuBuffers[id].drawLimit[1], cpuBuffers[id].drawLimit[2], cpuBuffers[id].drawLimit[3], cpuBuffers[id].drawLimit[4])\13\n\9\13\n\9currentVBuffer = id\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function getSubFunc(s)\13\n\9if #s ~= unicode.len(s) then\13\n\9\9return unicode.sub\13\n\9else\13\n\9\9return string.sub\13\n\9end\13\nend\13\n\13\nlocal dbgpu = {\13\n\9directDraw = parseArgs(args.directDraw, true),\13\n\9forceDraw = parseArgs(args.forceDraw, false),\13\n\9rawCopy = parseArgs(args.rawCopy, false),\13\n\9actualRawCopy = parseArgs(args.actualRawCopy, args.rawCopy),\13\n\9version = version,\13\n\9buffer = buffer,\13\n}\13\n\13\nlocal function draw()\13\n\9if dbgpu.directDraw then\13\n\9\9buffer.drawChanges(dbgpu.forceDraw)\13\n\9end\13\nend\13\n\13\nfunction dbgpu.set(x, y, s, v)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9if v then\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x, y +i -1, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9else\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x +i -1, y, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9end\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.fill(x, y, sx, sy, s)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9sx = math.floor(sx)\13\n\9sy = math.floor(sy)\13\n\9s = sub(s, 0, 1)\13\n\9buffer.drawRectangle(x, y, sx, sy, lastBackground, lastForeground, s)\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.copy(x, y, sx, sy, tx, ty)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9tx = math.floor(tx)\13\n\9ty = math.floor(ty)\13\n\9\13\n\9if sx * sy > 3200 then\13\n\9\9buffer.directCopy(x, y, sx, sy, tx +x, ty +y, dbgpu.rawCopy)\13\n\9else\13\n\9\9local data, rawData = buffer.copy(x, y, sx, sy, dbgpu.rawCopy)\13\n\9\9buffer.paste(tx +x, ty +y, data, rawData)\13\n\9end\13\n\9\13\n\9if dbgpu.rawCopy and dbgpu.actualRawCopy then\9\9\13\n\9\9gpu.copy(x, y, sx, sy, tx, ty)\13\n\9end\9\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.getBackground()\13\n\9return lastBackground\13\nend\13\nfunction dbgpu.getForeground()\13\n\9return lastForeground\13\nend\13\n\13\nfunction dbgpu.setBackground(c)\13\n\9lastBackground = c\13\n\9--return gpu.setBackground(c)\13\nend\13\nfunction dbgpu.setForeground(c)\13\n\9lastForeground = c\13\n\9--return gpu.setForeground(c)\13\nend\13\n\13\nfunction dbgpu.setResolution(x, y)\13\n\9buffer.setResolution(x, y)\13\nend\13\nfunction dbgpu.getResolution()\13\n\9return buffer.getResolution()\13\nend\13\n\13\nfunction dbgpu.drawChanges(f)\13\n\9buffer.drawChanges(f)\13\nend\13\n\13\nfunction dbgpu.drawImage(x, y, image)\13\n\9buffer.drawImage(x, y, image)\13\nend\13\n\13\nfunction dbgpu.getActiveBuffer()\13\n\9return currentVBuffer\13\nend\13\nfunction dbgpu.setActiveBuffer(id, force)\13\n\9if id == currentVBuffer or force then\13\n\9\9return false, \"Buffer is set already\"\13\n\9else\13\n\9\9local suc = gpu.setActiveBuffer(id)\13\n\9\9\13\n\9\9if suc ~= nil then\13\n\9\9\9\13\n\9\9\9setBuffer(id)\13\n\9\9\9\13\n\9\9\9do\13\n\9\9\9\9local b = buffer.getNewFrameTables()\13\n\9\9\9\9local b2 = cpuBuffers[id].new[1]\13\n\9\9\9\9\13\n\9\9\9\9--print(b, b2, b == b2)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9--print(\"T\", id)\13\n\9\9\9--print(cpuBuffers[0], cpuBuffers[1])\13\n\9\9\9--print(#cpuBuffers[0].new[1], #cpuBuffers[1].new[1], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9\9end\13\n\9\9return id\13\n\9end\13\nend\13\n--debug/dbgpuVBufferTest.lua > logs/test.log\13\nfunction dbgpu.allocateBuffer(w, h)\13\n\9local id = gpu.allocateBuffer(w, h)\13\n\9if type(id) == \"number\" then\13\n\9\9flushBuffer(id, w, h)\13\n\9end\13\n\9return id\13\nend\13\nfunction dbgpu.freeBuffer(id)\13\n\9cpuBuffers[id] = nil\13\n\9return gpu.freeBuffer(id)\13\nend\13\nfunction dbgpu.bitblt(...)\13\n\9return gpu.bitblt(...)\13\nend\13\nfunction dbgpu.freeAllBuffers()\13\n\9currentVBuffer = 0\13\n\9return gpu.freeAllBuffers()\13\nend\13\n\13\n--===== init =====--\13\nlocal resX, resY = gpu.getResolution()\13\nflushBuffer(0, resX, resY)\13\nsetBuffer(0)\13\n\13\n--dbgpu = setmetatable(dbgpu, {__index = gpu})\13\n--maxResolution\13\n--maxResolution\13\n\13\nreturn dbgpu",["./data/sp1/data/libs/LIP.lua"] = "--[[\13\n\9Copyright (c) 2012 Carreras Nicolas\13\n\9\13\n\9Permission is hereby granted, free of charge, to any person obtaining a copy\13\n\9of this software and associated documentation files (the \"Software\"), to deal\13\n\9in the Software without restriction, including without limitation the rights\13\n\9to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\n\9copies of the Software, and to permit persons to whom the Software is\13\n\9furnished to do so, subject to the following conditions:\13\n\9\13\n\9The above copyright notice and this permission notice shall be included in all\13\n\9copies or substantial portions of the Software.\13\n\9\13\n\9THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\n\9IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\n\9FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\n\9AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\n\9LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\n\9OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\n\9SOFTWARE.\13\n--]]\13\n--- Lua INI Parser.\13\n-- It has never been that simple to use INI files with Lua.\13\n--@author Dynodzzo\13\n\13\nlocal LIP = {};\13\n\13\n--- Returns a table containing all the data from the INI file.\13\n--@param fileName The name of the INI file to parse. [string]\13\n--@return The table containing all data from the INI file. [table]\13\nfunction LIP.load(fileName)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9local file = assert(io.open(fileName, 'r'), 'Error loading file : ' .. fileName);\13\n\9local data = {};\13\n\9local section;\13\n\9for line in file:lines() do\13\n\9\9local tempSection = line:match('^%[([^%[%]]+)%]$');\13\n\9\9if(tempSection)then\13\n\9\9\9section = tonumber(tempSection) and tonumber(tempSection) or tempSection;\13\n\9\9\9data[section] = data[section] or {};\13\n\9\9end\13\n\9\9local param, value = line:match('^([%w|_]+)%s-=%s-(.+)$');\13\n\9\9if(param and value ~= nil)then\13\n\9\9\9if(tonumber(value))then\13\n\9\9\9\9value = tonumber(value);\13\n\9\9\9elseif(value == 'true')then\13\n\9\9\9\9value = true;\13\n\9\9\9elseif(value == 'false')then\13\n\9\9\9\9value = false;\13\n\9\9\9end\13\n\9\9\9if(tonumber(param))then\13\n\9\9\9\9param = tonumber(param);\13\n\9\9\9end\13\n\9\9\9data[section][param] = value;\13\n\9\9end\13\n\9end\13\n\9file:close();\13\n\9return data;\13\nend\13\n\13\n--- Saves all the data from a table to an INI file.\13\n--@param fileName The name of the INI file to fill. [string]\13\n--@param data The table containing all the data to store. [table]\13\nfunction LIP.save(fileName, data)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9assert(type(data) == 'table', 'Parameter \"data\" must be a table.');\13\n\9local file = assert(io.open(fileName, 'w+b'), 'Error loading file :' .. fileName);\13\n\9local contents = '';\13\n\9for section, param in pairs(data) do\13\n\9\9contents = contents .. ('[%s]\\n'):format(section);\13\n\9\9for key, value in pairs(param) do\13\n\9\9\9contents = contents .. ('%s=%s\\n'):format(key, tostring(value));\13\n\9\9end\13\n\9\9contents = contents .. '\\n';\13\n\9end\13\n\9file:write(contents);\13\n\9file:close();\13\nend\13\n\13\nreturn LIP;",["./data/sp1/data/libs/DoubleBuffering.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are made some changes to provide the best possible performance in combination with the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (NosPo version) Copyright (c) 2019-2020 NosPo Studio\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\nlocal version = \"v0.8\" --NosPo version.\13\n\13\nlocal component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\nlocal color = require(\"libs/color\")\13\n--local image = require(\"libs/image\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal bufferWidth, bufferHeight\13\nlocal currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nlocal drawLimitX1, drawLimitX2, drawLimitY1, drawLimitY2\13\nlocal GPUProxy, GPUProxyGetResolution, GPUProxySetResolution, GPUProxyBind, GPUProxyGetBackground, GPUProxyGetForeground, GPUProxySetBackground, GPUProxySetForeground, GPUProxyGet, GPUProxySet, GPUProxyFill\13\n\13\nlocal mathCeil, mathFloor, mathModf, mathAbs = math.ceil, math.floor, math.modf, math.abs\13\nlocal tableInsert, tableConcat = table.insert, table.concat\13\nlocal colorBlend = color.blend\13\nlocal unicodeLen, unicodeSub = unicode.len, unicode.sub\13\n\13\nlocal drawAreas, nonDrawAreas = {}, {} --drawAreas == pixelWhiteList, nonDrawAreas == pixelBlackList\13\nlocal drawAreasAreWhitelist = true\13\nlocal drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nlocal bufferOnly = false\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getIndex(x, y)\13\n\9return bufferWidth * (y - 1) + x\13\nend\13\nlocal function getCoordinates(index)\13\n\9return index % bufferWidth, math.floor(index / bufferWidth) +1\13\nend\13\n\13\nlocal function getCurrentFrameTables()\13\n\9return currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function getNewFrameTables()\13\n\9return newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function setCurrentFrameTables(b, f, s, w, h)\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\nlocal function setNewFrameTables(b, f, s, w, h)\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\n\13\nlocal function setBufferOnly(b)\13\n\9bufferOnly = b\13\nend\13\nlocal function getBufferOnly()\13\n\9return bufferOnly\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function setDrawLimit(x1, y1, x2, y2)\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = x1, y1, x2, y2\13\nend\13\n\13\nlocal function resetDrawLimit()\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = 1, 1, bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getDrawLimit()\13\n\9return drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2\13\nend\13\n\13\nlocal function setDrawAreas(areas)\13\n\9drawAreas = areas\13\nend\13\nlocal function resetDrawAreas()\13\n\9drawAreas = {}\13\nend\13\nlocal function getDrawAreas()\13\n\9return drawAreas\13\nend\13\nlocal function setNonDrawAreas(areas)\13\n\9nonDrawAreas = areas\13\nend\13\nlocal function resetNonDrawAreas()\13\n\9nonDrawAreas = {}\13\nend\13\nlocal function getNonDrawAreas()\13\n\9return nonDrawAreas\13\nend\13\n\13\nlocal function setDrawAreaOffset(x, y)\13\n\9drawAreaOffsetX = x or drawAreaOffsetX\13\n\9drawAreaOffsetY = y or drawAreaOffsetY\13\n\9\13\nend\13\nlocal function getDrawAreaOffset()\13\n\9return drawAreaOffsetX, drawAreaOffsetY\13\nend\13\nlocal function resetDrawAreaOffset()\13\n\9drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nend\13\n\13\nlocal function isDrawable(x, y)\13\n\9local drawable = true\13\n\9\13\n\9if #drawAreas == 0 and #nonDrawAreas == 0 then\13\n\9\9--return true\13\n\9end\13\n\9\13\n\9for _, a in pairs(drawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = true\13\n\9\9\9break\13\n\9\9end\13\n\9\9drawable = false\13\n\9end\13\n\9for _, a in pairs(nonDrawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = false\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9return drawable\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function flush(width, height)\13\n\9if not width or not height then\13\n\9\9width, height = GPUProxyGetResolution()\13\n\9end\13\n\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = {}, {}, {}, {}, {}, {}\13\n\9bufferWidth = width\13\n\9bufferHeight = height\13\n\9resetDrawLimit()\13\n\13\n\9for y = 1, bufferHeight do\13\n\9\9for x = 1, bufferWidth do\13\n\9\9\9tableInsert(currentFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(currentFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(currentFrameSymbols, \" \")\13\n\13\n\9\9\9tableInsert(newFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(newFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(newFrameSymbols, \" \")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function setResolution(width, height)\13\n\9GPUProxySetResolution(width, height)\13\n\9flush(width, height)\13\nend\13\n\13\nlocal function getResolution()\13\n\9return bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getWidth()\13\n\9return bufferWidth\13\nend\13\n\13\nlocal function getHeight()\13\n\9return bufferHeight\13\nend\13\n\13\nlocal function bindScreen(...)\13\n\9GPUProxyBind(...)\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\nlocal function getGPUProxy()\13\n\9return GPUProxy\13\nend\13\n\13\nlocal function updateGPUProxyMethods()\13\n\9GPUProxyGet = GPUProxy.get\13\n\9GPUProxyGetResolution = GPUProxy.getResolution\13\n\9GPUProxyGetBackground = GPUProxy.getBackground\13\n\9GPUProxyGetForeground = GPUProxy.getForeground\13\n\13\n\9GPUProxySet = GPUProxy.set\13\n\9GPUProxySetResolution = GPUProxy.setResolution\13\n\9GPUProxySetBackground = GPUProxy.setBackground\13\n\9GPUProxySetForeground = GPUProxy.setForeground\13\n\13\n\9GPUProxyBind = GPUProxy.bind\13\n\9GPUProxyFill = GPUProxy.fill\13\nend\13\n\13\nlocal function bindGPU(address)\13\n\9GPUProxy = component.proxy(address)\13\n\9updateGPUProxyMethods()\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function rawSet(index, background, foreground, symbol)\13\n\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9if bufferOnly then\13\n\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9end\13\nend\13\n\13\nlocal function rawGet(index)\13\n\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\nend\13\n\13\nlocal function get(x, y)\13\n\9if x >= 1 and y >= 1 and x <= bufferWidth and y <= bufferHeight then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9else\13\n\9\9return 0x000000, 0x000000, \" \"\13\n\9end\13\nend\13\n\13\nlocal function set(x, y, background, foreground, symbol)\13\n\9if x >= drawLimitX1 and y >= drawLimitY1 and x <= drawLimitX2 and y <= drawLimitY2 and isDrawable(x, y) then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9if bufferOnly then\13\n\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawRectangle(x, y, width, height, background, foreground, symbol, transparency) \13\n\9local index, indexStepOnReachOfSquareWidth = bufferWidth * (y - 1) + x, bufferWidth - width\13\n\9for j = y, y + height - 1 do\13\n\9\9if j >= drawLimitY1 and j <= drawLimitY2 then\13\n\9\9\9for i = x, x + width - 1 do\13\n\9\9\9\9if i >= drawLimitX1 and i <= drawLimitX2 and isDrawable(i, j) then\13\n\9\9\9\9\9if transparency then\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9colorBlend(newFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9colorBlend(newFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9index = index + 1\13\n\9\9\9end\13\n\13\n\9\9\9index = index + indexStepOnReachOfSquareWidth\13\n\9\9else\13\n\9\9\9index = index + bufferWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clear(color, transparency)\13\n\9drawRectangle(1, 1, bufferWidth, bufferHeight, color or 0x0, 0x000000, \" \", transparency)\13\nend\13\n\13\nlocal function copy(x, y, width, height, current)\13\n\9local copyArray, index = { width, height }\13\n\9local rawCopyArray = { width, height }\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, newFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameSymbols[index])\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameForegrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameSymbols[index])\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, \" \")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return copyArray, rawCopyArray\13\nend\13\n\13\nlocal function paste(startX, startY, picture, currentPicture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\9\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9newFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9\9if currentPicture ~= nil then\13\n\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = currentPicture[pictureIndex]\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = currentPicture[pictureIndex + 1]\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = currentPicture[pictureIndex + 2]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function copyCurrent(x, y, width, height)\13\n\9local copyArray, index = { width, height }\13\n\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameSymbols[index])\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return copyArray\13\nend\13\n\13\nlocal function pasteCurrent(startX, startY, picture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9currentFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function directCopy(x, y, width, height, tx, ty, current, actualBuffer)\13\n\9local index\13\n\9local imageWidth = width\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (ty - 1) + tx, 3, bufferWidth - imageWidth\13\n\9\13\n\9local newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols\13\n\9\13\n\9if actualBuffer then\13\n\9\9newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9else\13\n\9\9newBackgrounds, newForegrounds, newSymbols = {table.unpack(newFrameBackgrounds)}, {table.unpack(newFrameForegrounds)}, {table.unpack(newFrameSymbols)}\13\n\9\13\n\9\13\n\9\9if current or bufferOnly then\13\n\9\9\9currentBackgrounds, currentForegrounds, currentSymbols = {table.unpack(currentFrameBackgrounds)}, {table.unpack(currentFrameForegrounds)}, {table.unpack(currentFrameSymbols)}\13\n\9\9end\13\n\9end\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9local newX, newY = getCoordinates(bufferIndex)\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(ewX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9newForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9newSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = currentFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = currentFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = currentFrameSymbols[index]\13\n\9\9\9\9\9\9--[[\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\9]]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(newX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9--[[\13\n\9\9\9\9\9newBackgrounds[newIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[newIndex] = 0x0\13\n\9\9\9\9\9newSymbols[newIndex] = \" \"\13\n\9\9\9\9\9]]\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9end\13\n\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9end\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = newBackgrounds, newForegrounds, newSymbols\13\n\9if current or bufferOnly then\13\n\9\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols = currentBackgrounds, currentForegrounds, currentSymbols\13\n\9end\13\nend\13\n\13\nlocal function rasterizeLine(x1, y1, x2, y2, method)\13\n\9local inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = x1, x2, y1, y2, false, mathAbs(x2 - x1), mathAbs(y2 - y1)\13\n\9if inLoopValueDelta < outLoopValueDelta then\13\n\9\9inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = y1, y2, x1, x2, true, outLoopValueDelta, inLoopValueDelta\13\n\9end\13\n\13\n\9if outLoopValueFrom > outLoopValueTo then\13\n\9\9outLoopValueFrom, outLoopValueTo = outLoopValueTo, outLoopValueFrom\13\n\9\9inLoopValueFrom, inLoopValueTo = inLoopValueTo, inLoopValueFrom\13\n\9end\13\n\13\n\9local outLoopValue, outLoopValueCounter, outLoopValueTriggerIncrement = outLoopValueFrom, 1, inLoopValueDelta / outLoopValueDelta\13\n\9local outLoopValueTrigger = outLoopValueTriggerIncrement\13\n\9for inLoopValue = inLoopValueFrom, inLoopValueTo, inLoopValueFrom < inLoopValueTo and 1 or -1 do\13\n\9\9if isReversed then\13\n\9\9\9method(outLoopValue, inLoopValue)\13\n\9\9else\13\n\9\9\9method(inLoopValue, outLoopValue)\13\n\9\9end\13\n\13\n\9\9outLoopValueCounter = outLoopValueCounter + 1\13\n\9\9if outLoopValueCounter > outLoopValueTrigger then\13\n\9\9\9outLoopValue, outLoopValueTrigger = outLoopValue + 1, outLoopValueTrigger + outLoopValueTriggerIncrement\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function rasterizeEllipse(centerX, centerY, radiusX, radiusY, method)\13\n\9local function rasterizeEllipsePoints(XP, YP)\13\n\9\9method(centerX + XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY - YP)\13\n\9\9method(centerX + XP, centerY - YP) \13\n\9end\13\n\13\n\9local x, y, changeX, changeY, ellipseError, twoASquare, twoBSquare = radiusX, 0, radiusY * radiusY * (1 - 2 * radiusX), radiusX * radiusX, 0, 2 * radiusX * radiusX, 2 * radiusY * radiusY\13\n\9local stoppingX, stoppingY = twoBSquare * radiusX, 0\13\n\13\n\9while stoppingX >= stoppingY do\13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9y, stoppingY, ellipseError = y + 1, stoppingY + twoASquare, ellipseError + changeY\13\n\9\9changeY = changeY + twoASquare\13\n\13\n\9\9if (2 * ellipseError + changeX) > 0 then\13\n\9\9\9x, stoppingX, ellipseError = x - 1, stoppingX - twoBSquare, ellipseError + changeX\13\n\9\9\9changeX = changeX + twoBSquare\13\n\9\9end\13\n\9end\13\n\13\n\9x, y, changeX, changeY, ellipseError, stoppingX, stoppingY = 0, radiusY, radiusY * radiusY, radiusX * radiusX * (1 - 2 * radiusY), 0, 0, twoASquare * radiusY\13\n\13\n\9while stoppingX <= stoppingY do \13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9x, stoppingX, ellipseError = x + 1, stoppingX + twoBSquare, ellipseError + changeX\13\n\9\9changeX = changeX + twoBSquare\13\n\9\9\13\n\9\9if (2 * ellipseError + changeY) > 0 then\13\n\9\9\9y, stoppingY, ellipseError = y - 1, stoppingY - twoASquare, ellipseError + changeY\13\n\9\9\9changeY = changeY + twoASquare\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawLine(x1, y1, x2, y2, background, foreground, symbol)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawEllipse(centerX, centerY, radiusX, radiusY, background, foreground, symbol)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawText(x, y, textColor, data, transparency)\13\n\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9local charIndex, bufferIndex = 1, bufferWidth * (y - 1) + x\13\n\9\9\13\n\9\9for charIndex = 1, unicodeLen(data) do\13\n\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9if transparency then\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9end\13\n\9\9\9\9else\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9newFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\13\n\9\9\9x, bufferIndex = x + 1, bufferIndex + 1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawImage(startX, startY, picture, blendForeground)\13\n\9local bufferIndex, pictureIndex, imageWidth, backgrounds, foregrounds, alphas, symbols = bufferWidth * (startY - 1) + startX, 1, picture[1], picture[3], picture[4], picture[5], picture[6]\13\n\9local bufferIndexStepOnReachOfImageWidth = bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9if alphas[pictureIndex] == 0 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex], newFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex], currentFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] > 0 and alphas[pictureIndex] < 1 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if blendForeground then\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] == 1 and symbols[pictureIndex] ~= \" \" then\13\n\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 1\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(x, y, width, height, color)\13\n\9local stringUp, stringDown, x2 = \"\" .. string.rep(\"\", width - 2) .. \"\", \"\" .. string.rep(\"\", width - 2) .. \"\", x + width - 1\13\n\9\13\n\9drawText(x, y, color, stringUp); y = y + 1\13\n\9for i = 1, height - 2 do\13\n\9\9drawText(x, y, color, \"\")\13\n\9\9drawText(x2, y, color, \"\")\13\n\9\9y = y + 1\13\n\9end\13\n\9drawText(x, y, color, stringDown)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function semiPixelRawSet(index, color, yPercentTwoEqualsZero, internalRun) --ToDo\13\n\9local upperPixel, lowerPixel, bothPixel = \"\", \"\", \" \"\13\n\9local backgroundBuffer, foregroundBuffer, symbolBuffer = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\n\9\13\n\9if internalRun then\13\n\9\9backgroundBuffer, foregroundBuffer, symbolBuffer = currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9end\13\n\9\13\n\9local background, foreground, symbol = backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index]\13\n\13\n\9if yPercentTwoEqualsZero then\13\n\9\9if symbol == upperPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9end\13\n\9else\13\n\9\9if symbol == lowerPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9end\13\n\9end\13\n\9\13\n\9if bufferOnly and not internalRun then\13\n\9\9semiPixelRawSet(index, color, yPercentTwoEqualsZero, true)\13\n\9end\13\nend\13\n\13\nlocal function semiPixelSet(x, y, color)\13\n\9local yFixed = mathCeil(y / 2)\13\n\9if x >= drawLimitX1 and yFixed >= drawLimitY1 and x <= drawLimitX2 and yFixed <= drawLimitY2 and isDrawable(x, yFixed) then\13\n\9\9semiPixelRawSet(bufferWidth * (yFixed - 1) + x, color, y % 2 == 0)\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelRectangle(x, y, width, height, color)\13\n\9local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = bufferWidth * (mathCeil(y / 2) - 1) + x, (bufferWidth - width), width\13\n\9for j = y, y + height - 1 do\13\n\9\9jPercentTwoEqualsZero = j % 2 == 0\13\n\9\9\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9jFixed = mathCeil(j / 2)\13\n\9\9\9semiPixelRawSet(index, color, jPercentTwoEqualsZero)\13\n\9\9\9index = index + 1\13\n\9\9end\13\n\13\n\9\9if jPercentTwoEqualsZero then\13\n\9\9\9index = index + indexStepForward\13\n\9\9else\13\n\9\9\9index = index - indexStepBackward\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelLine(x1, y1, x2, y2, color)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\nlocal function drawSemiPixelEllipse(centerX, centerY, radiusX, radiusY, color)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getPointTimedPosition(firstPoint, secondPoint, time)\13\n\9return {\13\n\9\9x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,\13\n\9\9y = firstPoint.y + (secondPoint.y - firstPoint.y) * time\13\n\9}\13\nend\13\n\13\nlocal function getConnectionPoints(points, time)\13\n\9local connectionPoints = {}\13\n\9for point = 1, #points - 1 do\13\n\9\9tableInsert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))\13\n\9end\13\n\9return connectionPoints\13\nend\13\n\13\nlocal function getMainPointPosition(points, time)\13\n\9if #points > 1 then\13\n\9\9return getMainPointPosition(getConnectionPoints(points, time), time)\13\n\9else\13\n\9\9return points[1]\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelCurve(points, color, precision)\13\n\9local linePoints = {}\13\n\9for time = 0, 1, precision or 0.01 do\13\n\9\9tableInsert(linePoints, getMainPointPosition(points, time))\13\n\9end\13\n\9\13\n\9for point = 1, #linePoints - 1 do\13\n\9\9drawSemiPixelLine(mathFloor(linePoints[point].x), mathFloor(linePoints[point].y), mathFloor(linePoints[point + 1].x), mathFloor(linePoints[point + 1].y), color)\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function drawChanges(force)\13\n\9local index, indexStepOnEveryLine, changes = bufferWidth * (drawLimitY1 - 1) + drawLimitX1, (bufferWidth - drawLimitX2 + drawLimitX1 - 1), {}\13\n\9local x, equalChars, equalCharsIndex, charX, charIndex, currentForeground\13\n\9local currentFrameBackground, currentFrameForeground, currentFrameSymbol, changesCurrentFrameBackground, changesCurrentFrameBackgroundCurrentFrameForeground\13\n\13\n\9local changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\13\n\9for y = drawLimitY1, drawLimitY2 do\13\n\9\9x = drawLimitX1\13\n\9\9while x <= drawLimitX2 do\9\9\9\13\n\9\9\9-- Determine if some pixel data was changed (or if <force> argument was passed)\13\n\9\9\9if\13\n\9\9\9\9currentFrameBackgrounds[index] ~= newFrameBackgrounds[index] or\13\n\9\9\9\9currentFrameForegrounds[index] ~= newFrameForegrounds[index] or\13\n\9\9\9\9currentFrameSymbols[index] ~= newFrameSymbols[index] or\13\n\9\9\9\9force\13\n\9\9\9then\13\n\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9currentFrameBackground, currentFrameForeground, currentFrameSymbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9\9\9\9currentFrameBackgrounds[index] = currentFrameBackground\13\n\9\9\9\9currentFrameForegrounds[index] = currentFrameForeground\13\n\9\9\9\9currentFrameSymbols[index] = currentFrameSymbol\13\n\13\n\9\9\9\9-- Look for pixels with equal chars from right of current pixel\13\n\9\9\9\9equalChars, equalCharsIndex, charX, charIndex = {currentFrameSymbol}, 2, x + 1, index + 1\13\n\9\9\9\9while charX <= drawLimitX2 do\13\n\9\9\9\9\9-- Pixels becomes equal only if they have same background and (whitespace char or same foreground)\13\n\9\9\9\9\9if\9\13\n\9\9\9\9\9\9currentFrameBackground == newFrameBackgrounds[charIndex] and\13\n\9\9\9\9\9\9(\13\n\9\9\9\9\9\9\9newFrameSymbols[charIndex] == \" \" or\13\n\9\9\9\9\9\9\9currentFrameForeground == newFrameForegrounds[charIndex]\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9\9 \9currentFrameBackgrounds[charIndex] = newFrameBackgrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameForegrounds[charIndex] = newFrameForegrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameSymbols[charIndex] = newFrameSymbols[charIndex]\13\n\13\n\9\9\9\9\9 \9equalChars[equalCharsIndex], equalCharsIndex = currentFrameSymbols[charIndex], equalCharsIndex + 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9charX, charIndex = charX + 1, charIndex + 1\13\n\9\9\9\9end\13\n\13\n\9\9\9\9-- Group pixels that need to be drawn by background and foreground\13\n\9\9\9\9changes[currentFrameBackground] = changes[currentFrameBackground] or {}\13\n\9\9\9\9changesCurrentFrameBackground = changes[currentFrameBackground]\13\n\9\9\9\9changesCurrentFrameBackground[currentFrameForeground] = changesCurrentFrameBackground[currentFrameForeground] or {index = 1}\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground = changesCurrentFrameBackground[currentFrameForeground]\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForegroundIndex = changesCurrentFrameBackgroundCurrentFrameForeground.index\13\n\9\9\9\9\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = x, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = y, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = tableConcat(equalChars), changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9\13\n\9\9\9\9x, index, changesCurrentFrameBackgroundCurrentFrameForeground.index = x + equalCharsIndex - 2, index + equalCharsIndex - 2, changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\9\9\9end\13\n\13\n\9\9\9x, index = x + 1, index + 1\13\n\9\9end\13\n\13\n\9\9index = index + indexStepOnEveryLine\13\n\9end\13\n\9\13\n\9-- Draw grouped pixels on screen\13\n\9for background, foregrounds in pairs(changes) do\13\n\9\9GPUProxySetBackground(background)\13\n\13\n\9\9for foreground, pixels in pairs(foregrounds) do\13\n\9\9\9if currentForeground ~= foreground then\13\n\9\9\9\9GPUProxySetForeground(foreground)\13\n\9\9\9\9currentForeground = foreground\13\n\9\9\9end\13\n\13\n\9\9\9for i = 1, #pixels, 3 do\13\n\9\9\9\9GPUProxySet(pixels[i], pixels[i + 1], pixels[i + 2])\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9changes = nil\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nbindGPU(component.getPrimary(\"gpu\").address)\13\n\13\nreturn {\13\n\9getCoordinates = getCoordinates,\13\n\9getIndex = getIndex,\13\n\9setDrawLimit = setDrawLimit,\13\n\9resetDrawLimit = resetDrawLimit,\13\n\9getDrawLimit = getDrawLimit,\13\n\9flush = flush,\13\n\9setResolution = setResolution,\13\n\9bindScreen = bindScreen,\13\n\9bindGPU = bindGPU,\13\n\9getGPUProxy = getGPUProxy,\13\n\9getResolution = getResolution,\13\n\9getWidth = getWidth,\13\n\9getHeight = getHeight,\13\n\9getCurrentFrameTables = getCurrentFrameTables,\13\n\9getNewFrameTables = getNewFrameTables,\13\n\9setCurrentFrameTables = setCurrentFrameTables,\13\n\9setNewFrameTables = setNewFrameTables,\13\n\9setBufferOnly = setBufferOnly,\13\n\9getBufferOnly = getBufferOnly,\13\n\13\n\9rawSet = rawSet,\13\n\9rawGet = rawGet,\13\n\9get = get,\13\n\9set = set,\13\n\9clear = clear,\13\n\9copy = copy,\13\n\9paste = paste,\13\n\9directCopy = directCopy,\13\n\9copyCurrent = copyCurrent,\13\n\9pasteCurrent = pasteCurrent,\13\n\9rasterizeLine = rasterizeLine,\13\n\9rasterizeEllipse = rasterizeEllipse,\13\n\9semiPixelRawSet = semiPixelRawSet,\13\n\9semiPixelSet = semiPixelSet,\13\n\9drawChanges = drawChanges,\13\n\13\n\9drawRectangle = drawRectangle,\13\n\9drawLine = drawLine,\13\n\9drawEllipse = drawEllipse,\13\n\9drawText = drawText,\13\n\9drawImage = drawImage,\13\n\9drawFrame = drawFrame,\13\n\13\n\9drawSemiPixelRectangle = drawSemiPixelRectangle,\13\n\9drawSemiPixelLine = drawSemiPixelLine,\13\n\9drawSemiPixelEllipse = drawSemiPixelEllipse,\13\n\9drawSemiPixelCurve = drawSemiPixelCurve,\13\n\9\13\n\9setDrawAreas = setDrawAreas,\13\n\9resetDrawAreas = resetDrawAreas,\13\n\9getDrawAreas = getDrawAreas,\13\n\9setNonDrawAreas = setNonDrawAreas,\13\n\9resetNonDrawAreas = resetNonDrawAreas,\13\n\9getNonDrawAreas = getNonDrawAreas,\13\n\9\13\n\9setDrawAreaOffset = setDrawAreaOffset,\13\n\9getDrawAreaOffset = getDrawAreaOffset,\13\n\9resetDrawAreaOffset = resetDrawAreaOffset,\13\n}",["./data/sp1/data/libs/color.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are possibly made some changes if needed to fit in to the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/Color>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\ncolor Copyright (c) 2018 \13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\n\13\nlocal computer = require(\"computer\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal palette = {0x000000, 0x000040, 0x000080, 0x0000BF, 0x0000FF, 0x002400, 0x002440, 0x002480, 0x0024BF, 0x0024FF, 0x004900, 0x004940, 0x004980, 0x0049BF, 0x0049FF, 0x006D00, 0x006D40, 0x006D80, 0x006DBF, 0x006DFF, 0x009200, 0x009240, 0x009280, 0x0092BF, 0x0092FF, 0x00B600, 0x00B640, 0x00B680, 0x00B6BF, 0x00B6FF, 0x00DB00, 0x00DB40, 0x00DB80, 0x00DBBF, 0x00DBFF, 0x00FF00, 0x00FF40, 0x00FF80, 0x00FFBF, 0x00FFFF, 0x0F0F0F, 0x1E1E1E, 0x2D2D2D, 0x330000, 0x330040, 0x330080, 0x3300BF, 0x3300FF, 0x332400, 0x332440, 0x332480, 0x3324BF, 0x3324FF, 0x334900, 0x334940, 0x334980, 0x3349BF, 0x3349FF, 0x336D00, 0x336D40, 0x336D80, 0x336DBF, 0x336DFF, 0x339200, 0x339240, 0x339280, 0x3392BF, 0x3392FF, 0x33B600, 0x33B640, 0x33B680, 0x33B6BF, 0x33B6FF, 0x33DB00, 0x33DB40, 0x33DB80, 0x33DBBF, 0x33DBFF, 0x33FF00, 0x33FF40, 0x33FF80, 0x33FFBF, 0x33FFFF, 0x3C3C3C, 0x4B4B4B, 0x5A5A5A, 0x660000, 0x660040, 0x660080, 0x6600BF, 0x6600FF, 0x662400, 0x662440, 0x662480, 0x6624BF, 0x6624FF, 0x664900, 0x664940, 0x664980, 0x6649BF, 0x6649FF, 0x666D00, 0x666D40, 0x666D80, 0x666DBF, 0x666DFF, 0x669200, 0x669240, 0x669280, 0x6692BF, 0x6692FF, 0x66B600, 0x66B640, 0x66B680, 0x66B6BF, 0x66B6FF, 0x66DB00, 0x66DB40, 0x66DB80, 0x66DBBF, 0x66DBFF, 0x66FF00, 0x66FF40, 0x66FF80, 0x66FFBF, 0x66FFFF, 0x696969, 0x787878, 0x878787, 0x969696, 0x990000, 0x990040, 0x990080, 0x9900BF, 0x9900FF, 0x992400, 0x992440, 0x992480, 0x9924BF, 0x9924FF, 0x994900, 0x994940, 0x994980, 0x9949BF, 0x9949FF, 0x996D00, 0x996D40, 0x996D80, 0x996DBF, 0x996DFF, 0x999200, 0x999240, 0x999280, 0x9992BF, 0x9992FF, 0x99B600, 0x99B640, 0x99B680, 0x99B6BF, 0x99B6FF, 0x99DB00, 0x99DB40, 0x99DB80, 0x99DBBF, 0x99DBFF, 0x99FF00, 0x99FF40, 0x99FF80, 0x99FFBF, 0x99FFFF, 0xA5A5A5, 0xB4B4B4, 0xC3C3C3, 0xCC0000, 0xCC0040, 0xCC0080, 0xCC00BF, 0xCC00FF, 0xCC2400, 0xCC2440, 0xCC2480, 0xCC24BF, 0xCC24FF, 0xCC4900, 0xCC4940, 0xCC4980, 0xCC49BF, 0xCC49FF, 0xCC6D00, 0xCC6D40, 0xCC6D80, 0xCC6DBF, 0xCC6DFF, 0xCC9200, 0xCC9240, 0xCC9280, 0xCC92BF, 0xCC92FF, 0xCCB600, 0xCCB640, 0xCCB680, 0xCCB6BF, 0xCCB6FF, 0xCCDB00, 0xCCDB40, 0xCCDB80, 0xCCDBBF, 0xCCDBFF, 0xCCFF00, 0xCCFF40, 0xCCFF80, 0xCCFFBF, 0xCCFFFF, 0xD2D2D2, 0xE1E1E1, 0xF0F0F0, 0xFF0000, 0xFF0040, 0xFF0080, 0xFF00BF, 0xFF00FF, 0xFF2400, 0xFF2440, 0xFF2480, 0xFF24BF, 0xFF24FF, 0xFF4900, 0xFF4940, 0xFF4980, 0xFF49BF, 0xFF49FF, 0xFF6D00, 0xFF6D40, 0xFF6D80, 0xFF6DBF, 0xFF6DFF, 0xFF9200, 0xFF9240, 0xFF9280, 0xFF92BF, 0xFF92FF, 0xFFB600, 0xFFB640, 0xFFB680, 0xFFB6BF, 0xFFB6FF, 0xFFDB00, 0xFFDB40, 0xFFDB80, 0xFFDBBF, 0xFFDBFF, 0xFFFF00, 0xFFFF40, 0xFFFF80, 0xFFFFBF, 0xFFFFFF}\13\nlocal mathFloor, mathMax, mathMin, mathModf = math.floor, math.max, math.min, math.modf\13\nlocal integerToRGB, RGBToInteger, blend, transition, to8Bit\13\n\13\nlocal color = {}\13\n\13\n--------------------------------------------------------------------------------\13\n\13\n-- Optimized Lua 5.3 bitwise support\13\nif computer.getArchitecture and computer.getArchitecture() == \"Lua 5.3\" then\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9return integerColor >> 16, integerColor >> 8 & 0xFF, integerColor & 0xFF\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r << 16 | g << 8 | b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9return\13\n\9\9\9\9\9((color2 >> 16) * invertedTransparency + (color1 >> 16) * transparency) // 1 << 16 |\13\n\9\9\9\9\9((color2 >> 8 & 0xFF) * invertedTransparency + (color1 >> 8 & 0xFF) * transparency) // 1 << 8 |\13\n\9\9\9\9\9((color2 & 0xFF) * invertedTransparency + (color1 & 0xFF) * transparency) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1, g1, b1 = color1 >> 16, color1 >> 8 & 0xFF, color1 & 0xFF\13\n\9\9\9\9return\13\n\9\9\9\9\9(r1 + ((color2 >> 16) - r1) * position) // 1 << 16 |\13\n\9\9\9\9\9(g1 + ((color2 >> 8 & 0xFF) - g1) * position) // 1 << 8 |\13\n\9\9\9\9\9(b1 + ((color2 & 0xFF) - b1) * position) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local r, g, b, closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = color24Bit >> 16, color24Bit >> 8 & 0xFF, color24Bit & 0xFF, mathHuge, 1\13\n\13\n\9\9\9\9for i = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[i]\13\n\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return i - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR, paletteG, paletteB = paletteColor >> 16, paletteColor >> 8 & 0xFF, paletteColor & 0xFF\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, i\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nelse\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9local r = integerColor / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (integerColor - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\13\n\9\9\9\9return r, g, integerColor - r * 65536 - g * 256\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r * 65536 + g * 256 + b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r2 * invertedTransparency + r1 * transparency,\13\n\9\9\9\9\9g2 * invertedTransparency + g1 * transparency,\13\n\9\9\9\9\9(color2 - r2 * 65536 - g2 * 256) * invertedTransparency + (color1 - r1 * 65536 - g1 * 256) * transparency\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\9\9\9\9local b1 = color1 - r1 * 65536 - g1 * 256\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r1 + (r2 - r1) * position,\13\n\9\9\9\9\9g1 + (g2 - g1) * position,\13\n\9\9\9\9\9b1 + (color2 - r2 * 65536 - g2 * 256 - b1) * position\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = mathHuge, 1\13\n\13\n\9\9\9\9local r = color24Bit / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (color24Bit - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\9\9\9\9local b = color24Bit - r * 65536 - g * 256\13\n\13\n\9\9\9\9for index = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[index]\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return index - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR = paletteColor / 65536\13\n\9\9\9\9\9\9paletteR = paletteR - paletteR % 1\13\n\9\9\9\9\9\9paletteG = (paletteColor - paletteR * 65536) / 256\13\n\9\9\9\9\9\9paletteG = paletteG - paletteG % 1\13\n\9\9\9\9\9\9paletteB = paletteColor - paletteR * 65536 - paletteG * 256\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, index\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function RGBToHSB(r, g, b)\13\n\9local max, min = mathMax(r, g, b), mathMin(r, g, b)\13\n\13\n\9if max == min then\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g >= b then\13\n\9\9return 60 * (g - b) / (max - min), max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g < b then\13\n\9\9return 60 * (g - b) / (max - min) + 360, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == g then\13\n\9\9return 60 * (b - r) / (max - min) + 120, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == b then\13\n\9\9return 60 * (r - g) / (max - min) + 240, max == 0 and 0 or (1 - min / max), max / 255\13\n\9else\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9end\13\nend\13\n\13\nlocal function HSBToRGB(h, s, b)\13\n\9local integer, fractional = mathModf(h / 60)\9\13\n\9local p, q, t = b * (1 - s), b * (1 - s * fractional), b * (1 - (1 - fractional) * s)\13\n\13\n\9if integer == 0 then\13\n\9\9return mathFloor(b * 255), mathFloor(t * 255), mathFloor(p * 255)\13\n\9elseif integer == 1 then\13\n\9\9return mathFloor(q * 255), mathFloor(b * 255), mathFloor(p * 255)\13\n\9elseif integer == 2 then\13\n\9\9return mathFloor(p * 255), mathFloor(b * 255), mathFloor(t * 255)\13\n\9elseif integer == 3 then\13\n\9\9return mathFloor(p * 255), mathFloor(q * 255), mathFloor(b * 255)\13\n\9elseif integer == 4 then\13\n\9\9return mathFloor(t * 255), mathFloor(p * 255), mathFloor(b * 255)\13\n\9else\13\n\9\9return mathFloor(b * 255), mathFloor(p * 255), mathFloor(q * 255)\13\n\9end\13\nend\13\n\13\nlocal function integerToHSB(integerColor)\13\n\9return RGBToHSB(integerToRGB(integerColor))\13\nend\13\n\13\nlocal function HSBToInteger(h, s, b)\13\n\9return RGBToInteger(HSBToRGB(h, s, b))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function to24Bit(color8Bit)\13\n\9return palette[color8Bit + 1]\13\nend\13\n\13\nlocal function optimize(color24Bit)\13\n\9return to24Bit(to8Bit(color24Bit))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nreturn {\13\n\9RGBToInteger = RGBToInteger,\13\n\9integerToRGB = integerToRGB,\13\n\9RGBToHSB = RGBToHSB,\13\n\9HSBToRGB = HSBToRGB,\13\n\9integerToHSB = integerToHSB,\13\n\9HSBToInteger = HSBToInteger,\13\n\9blend = blend,\13\n\9transition = transition,\13\n\9to8Bit = to8Bit,\13\n\9to24Bit = to24Bit,\13\n\9optimize = optimize,\13\n}",["./data/sp1/data/libs/"] = 0,["./data/sp1/data/game.lua"] = "local usesDoubleBuffer = ...\13\n\13\nlocal version = \"v1.1.2c\"\13\nlocal isDevVersion = false\13\n\13\nlocal component = require(\"component\")\13\nlocal computer = require(\"computer\")\13\nlocal system = require(\"os\")\13\nlocal term = require(\"term\")\13\nlocal keyboard = require(\"keyboard\")\13\nlocal gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\npackage.loaded.player = nil\13\nlocal player = require(\"player\")\13\npackage.loaded.player = nil\13\nlocal player2 = require(\"player\")\13\n\13\npackage.loaded.graphic = nil\13\nrequire(\"graphic\")\13\n\13\npackage.loaded.deltaTime = nil\13\nlocal delta = require(\"deltaTime\")\13\n\13\npackage.loaded.background = nil\13\nlocal background = require(\"background\")\13\n\13\nlocal deltaTime = 0\13\nlocal previousDeltaTime = 0\13\n\13\nlocal fpsCheckInterval = 20\13\nlocal deltaTimeTable = {}\13\nlocal fps = 0\13\nlocal frameCounter = 0\13\nlocal realDeltaTime = 0\13\n\13\nlocal lastBlinkTime = computer.uptime()\13\nlocal blinkState = true\13\nlocal lastLooser\13\n\13\nlocal gameIsRunning = true\13\n\13\n--==========--\13\nlocal blinkDelay = 1\13\n\13\nlocal resX = 80\13\nlocal resY = 25\13\n\13\nlocal sleepTime = 1 --caps it to about 20 fps\13\n\13\nlocal controls = require(\"libs/LIP\").load(\"../controls.ini\")\13\n\13\n--===== init =====--\13\nif usesDoubleBuffer then\13\n\9gpu = gpuProxy\13\nelse\13\n\9gpu = component.gpu\13\nend\13\n\13\n--=============== Functions ===============--\13\n\13\nfunction Start()\13\n\9player.Start()\13\n\9player2.Start()\13\n\13\n\9player.right = tostring(controls.player1.right)\13\n\9player.left = tostring(controls.player1.left)\13\n\9player.punch = tostring(controls.player1.punch)\13\n\9\13\n\9player2.right = tostring(controls.player2.right)\13\n\9player2.left = tostring(controls.player2.left)\13\n\9player2.punch = tostring(controls.player2.punch)\13\n\9\13\n\9player2.body.aSet[1] = {2, 1, \"   \", 0x000000, 0xbf2f11}\13\n\9player2.body.aSet[2] = {3, 0, \" \"}\13\n\9\13\n\9Reset()\13\nend\13\n\13\nfunction Update()\13\n\9if gameIsRunning then\13\n\9\9player.Update()\13\n\9\9player2.Update()\13\n\9\9\13\n\9\9Draw()\13\n\9\9\13\n\9\9if HitCheck(player, player2) then\13\n\9\9\9player2.life = player2.life - (player.charge /2)\13\n\9\9\9player.charge = 0\13\n\9\9end\13\n\9\9if HitCheck(player2, player) then\13\n\9\9\9player.life = player.life - (player2.charge /2)\13\n\9\9\9player2.charge = 0\13\n\9\9end\13\n\9\9\13\n\9\9if player2.life <= 0 and player.life <= 0 then\13\n\9\9\9GameOver(0)\13\n\9\9else\13\n\9\9\9if player.life <= 0 then\13\n\9\9\9\9GameOver(\"Player2\")\13\n\9\9\9elseif player2.life <= 0 then\13\n\9\9\9\9GameOver(\"Player1\")\13\n\9\9\9end\13\n\9\9end\13\n\9else\13\n\9\9if computer.uptime() - lastBlinkTime > blinkDelay then\13\n\9\9\9if blinkState then\13\n\9\9\9\9DrawResetText()\13\n\9\9\9\9blinkState = false\13\n\9\9\9else\13\n\9\9\9\9Draw()\13\n\9\9\9\9GameOver(lastLooser)\13\n\9\9\9\9blinkState = true\13\n\9\9\9end\13\n\9\9\9lastBlinkTime = computer.uptime()\13\n\9\9end\13\n\9end\13\nend\13\n\13\n\13\nfunction Draw()\13\n\9--gpu.fill(1, 1, resX, resY, \" \")\13\n\9--DrawAt(testTexture, 0, 0, gpu)\13\n\9\13\n\9ClearAt(player2.body, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player.body, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player.arm2, player.oldPosX, player.oldPosY, gpu)\13\n\9ClearAt(player.arm3, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player2.arm2, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player2.arm3, player2.oldPosX, player2.oldPosY, gpu)\13\n\9\13\n\9--Background\13\n\9DrawAt(background.street, 1, 17, gpu)\13\n\9\13\n\9--Player\13\n\9\13\n\9DrawAt(player.body, player.posX, player.posY, gpu)\13\n\9DrawAt(player2.body, player2.posX, player2.posY, gpu)\13\n\9\13\n\9DrawArms(player)\13\n\9DrawArms(player2)\13\n\9\13\n\9LifeGui()\13\nend\13\n\13\nfunction LifeGui() \13\n\9DrawAt({\13\n\9\9fillSize = 4,\13\n\9\9aFill = {\13\n\9\9\9[1] = {2, 1, 36, 5, \" \", 0x000000, 0xaaaaaa},\13\n\9\9\9[2] = {42, 1, 36, 5, \" \", 0x000000, 0xaaaaaa},\13\n\9\9\9\13\n\9\9},\13\n\9\9\13\n\9\9setSize = 2,\13\n\9\9aSet = {\13\n\9\9\9\13\n\9\9},\13\n\9}, 1, 1, gpu)\13\n\9gpu.setBackground(0x000000)\13\n\9gpu.set(5, 3, \"                                \")\13\n\9gpu.set(45, 3, \"                                \")\13\n\9gpu.set(5, 5, \"                                \")\13\n\9gpu.set(45, 5, \"                                \")\13\n\9gpu.setBackground(0x00aa00)\13\n\9gpu.fill(5, 3, player.life, 1, \" \")\13\n\9gpu.fill(45, 3, player2.life, 1, \" \")\13\n\9gpu.setBackground(0x000000ff)\13\n\9gpu.fill(5, 5, player.charge, 1, \" \")\13\n\9gpu.fill(45, 5, player2.charge, 1, \" \")\13\n\9\13\n\9gpu.setForeground(0xaaaaaa)\13\n\9gpu.setBackground(0x00509f)\13\n\9gpu.set(resX / 2 - unicode.len(version) / 2 + 1, 1, version)\13\nend\13\n\13\nfunction HitCheck(p1, p2)\13\n\9if p1.looksLeft then\13\n\9\9if p1.isPunching then\13\n\9\9\9if p1.posX <= p2.posX + 10 and p1.posX > p2.posX + 5 then\13\n\9\9\9\9return true\13\n\9\9\9end\13\n\9\9end\13\n\9elseif p1.looksLeft == false then\13\n\9\9if p1.isPunching then\13\n\9\9\9if p1.posX + 10 >= p2.posX and p1.posX + 5 < p2.posX then\13\n\9\9\9\9return true\13\n\9\9\9end\13\n\9\9end\13\n\9else\13\n\9\9return false\13\n\9end\13\nend\13\n\13\nfunction DrawArms(player)\9\13\n\9if player.isCharging then\13\n\9\9DrawAt(player.arm2, player.posX, player.posY, gpu)\13\n\9elseif player.isPunching then\13\n\9\9DrawAt(player.arm3, player.posX, player.posY, gpu)\13\n\9else\13\n\9\9DrawAt(player.arm1, player.posX, player.posY, gpu)\13\n\9end\13\nend\13\n\13\nfunction GameOver(name)\13\n\9LifeGui()\13\n\9\13\n\9if name ~= 0 then\13\n\9\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 4,\13\n\9\9aSet = {\13\n\9\9\9[1] = {28, 6, \"########################\", 0x500000, 0xba0000},\13\n\9\9\9[2] = {28, 7, \"##     GameOver!      ##\", 0x500000, 0xba0000},\13\n\9\9\9[3] = {28, 8, \"##  \" .. name .. \" has won!  ##\"},\13\n\9\9\9[4] = {28, 9, \"########################\", 0x500000, 0xba0000},\13\n\9\9}}, 1, 1, gpu)\13\n\9else\13\n\9\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 4,\13\n\9\9aSet = {\13\n\9\9\9[1] = {28, 6, \"########################\", 0x500000, 0xba0000},\13\n\9\9\9[2] = {28, 7, \"##     GameOver!      ##\", 0x500000, 0xba0000},\13\n\9\9\9[3] = {28, 8, \"##       Tie!         ##\"},\13\n\9\9\9[4] = {28, 9, \"########################\", 0x500000, 0xba0000},\13\n\9\9}}, 1, 1, gpu)\13\n\9end\13\n\13\n\9if blinkState then\13\n\9\9DrawResetText()\13\n\9end\13\n\9\13\n\9gameIsRunning = false\13\n\9lastLooser = name\13\nend\13\n\13\nfunction DrawResetText()\13\n\9DrawAt({\13\n\9\9fillSize = 1, aFill = {},\13\n\9\9setSize = 1,\13\n\9\9aSet = {\13\n\9\9\9[1] = {30, 12, \" Press \" .. unicode.upper(controls.game.reset) .. \" to restart \", 0x705000, 0xee6000},\13\n\9}}, 1, 9, gpu)\13\nend\13\n\13\nfunction Reset() \13\n\9player.posX = 5\13\n\9player.life = player.maxLife\13\n\9player.charge = 0\13\n\9player.TurnAround(false)\13\n\9\13\n\9player2.posX = 70\13\n\9player2.life = player2.maxLife\13\n\9player2.charge = 0\13\n\9player2.TurnAround(true)\13\n\9\13\n\9gameIsRunning = true\13\n\9\13\n\9blinkState = true\13\n\9\13\n\9ClearAt(player2.body, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player.body, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player.arm2, player.oldPosX, player.oldPosY, gpu)\13\n\9ClearAt(player.arm3, player.oldPosX, player.oldPosY, gpu)\13\n\9\13\n\9ClearAt(player2.arm2, player2.oldPosX, player2.oldPosY, gpu)\13\n\9ClearAt(player2.arm3, player2.oldPosX, player2.oldPosY, gpu)\13\n\9\13\nend\13\n\13\nfunction Reload() --For DEV\13\n\9ClearAt(background.street, 1, 17, gpu)\13\n\9package.loaded.background = nil\13\n\9background = require(\"background\")\13\nend\13\nlocal devCount = 0\13\n\13\n--=============== Main while ===============--\13\nterm.clear()\13\ngpu.setResolution(resX, resY)\13\n\13\n\13\nStart()\13\nwhile true do\13\n\9Update()\13\n\9--system.sleep(0.001)\13\n\9deltaTime = (computer.uptime() - previousDeltaTime) * 100 / 7\13\n\9realDeltaTime = computer.uptime() - previousDeltaTime\13\n\9previousDeltaTime = computer.uptime()\13\n\9\13\n\9if isDevVersion then\13\n\9\9if frameCounter >= fpsCheckInterval then\13\n\9\9\9frameCounter = 0\13\n\9\9end\13\n\9\9deltaTimeTable[frameCounter] = realDeltaTime\13\n\9\9local frameTimes = 0\13\n\9\9for i, c in pairs(deltaTimeTable) do\13\n\9\9\9frameTimes = frameTimes + c\13\n\9\9end\13\n\9\9frameCounter = frameCounter +1\13\n\9\9fps = 1 / (frameTimes / #deltaTimeTable)\13\n\13\n\9\9gpu.setForeground(0xaaaaaa)\13\n\9\9gpu.setBackground(0x000000)\13\n\9\9gpu.set(1, 1, \"                              \")\13\n\9\9delta.Set()\13\n\9\9--gpu.set(1, 1, \"Delta time: \" .. deltaTime .. \" | \" .. (sleepTime - deltaTime) / 1000 .. \" | \" )\13\n\9\9gpu.set(1, 1, \"FPS: \" .. fps)\13\n\9end\13\n\13\n\9if usesDoubleBuffer then\13\n\9\9gpu.drawChanges()\13\n\9end\13\n\9\13\n\9if keyboard.isKeyDown(controls.game.quit) then\13\n\9\9gpu.setForeground(0xaaaaaa)\13\n\9\9gpu.setBackground(0x000000)\13\n\9\9--print(\"BREAK                       \")\13\n\9\9break\13\n\9elseif keyboard.isKeyDown(controls.game.reset) then\13\n\9\9Reset()\13\n\9end\13\n\9if keyboard.isKeyDown('t') then\13\n\9\9Reload()\13\n\9\9devCount = 0\13\n\9end\13\n\13\n\9os.sleep((sleepTime - deltaTime) / 1000)\13\nend\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n\13\n",["./data/sp1/data/graphic.lua"] = "--GraphicLib v0.1\13\n\13\nfunction ClearAt(t, posX, posY, gpu)\13\n\9AddToTexture(t, posX, posY)\13\n\9ClearTexture(t, gpu)\13\n\9AddToTexture(t, -posX, -posY)\13\nend\13\n\13\nfunction ClearTexture(t, gpu) \13\n\9gpu.setBackground(0x000000)\13\n\9for c = 1, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9if t.aFill[c][5] ~= nil then\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], \" \")\13\n\9\9\9end\9\9\13\n\9\9end\13\n\9end\13\n\13\n\9for c = 1, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9if t.aSet[c][3] ~= nil then\13\n\9\9\9\9gpu.fill(t.aSet[c][1], t.aSet[c][2], string.len(t.aSet[c][3]), 1, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction DrawAt(t, posX, posY, gpu)\13\n\9AddToTexture(t, posX, posY)\13\n\9DrawTexture(t, gpu)\13\n\9AddToTexture(t, -posX, -posY)\13\nend\13\n\13\nfunction DrawTexture(t, gpu) \13\n\9local previousForeground = gpu.getForeground()\13\n\9local previousBackground = gpu.getBackground()\13\n\9for c = 1, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9if t.aFill[c][6] ~= nil then\13\n\9\9\9\9if previousForeground ~= t.aFill[c][6] then\13\n\9\9\9\9\9gpu.setForeground(t.aFill[c][6])\13\n\9\9\9\9\9previousForeground = t.aFill[c][6]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aFill[c][7] then\13\n\9\9\9\9\9gpu.setBackground(t.aFill[c][7])\13\n\9\9\9\9\9previousBackground = t.aFill[c][7]\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], t.aFill[c][5])\13\n\9\9\9elseif #t.aFill[c] == 2 then\13\n\9\9\9\9if previousForeground ~= t.aFill[c][1] then\13\n\9\9\9\9\9gpu.setForeground(t.aFill[c][1])\13\n\9\9\9\9\9previousForeground = t.aFill[c][1]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aFill[c][2] then\13\n\9\9\9\9\9gpu.setBackground(t.aFill[c][2])\13\n\9\9\9\9\9previousBackground = t.aFill[c][2]\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9gpu.fill(t.aFill[c][1], t.aFill[c][2], t.aFill[c][3], t.aFill[c][4], t.aFill[c][5])\13\n\9\9\9end\13\n\9\9\9\13\n\9\9end\13\n\9end\13\n\13\n\9for c = 1, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9if t.aSet[c][4] ~= nil then\13\n\9\9\9\9if previousForeground ~= t.aSet[c][4] then\13\n\9\9\9\9\9gpu.setForeground(t.aSet[c][4])\13\n\9\9\9\9\9previousForeground = t.aSet[c][4]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aSet[c][5] then\13\n\9\9\9\9\9gpu.setBackground(t.aSet[c][5])\13\n\9\9\9\9\9previousBackground = t.aSet[c][5]\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9gpu.set(t.aSet[c][1], t.aSet[c][2], t.aSet[c][3])\13\n\9\9\9elseif #t.aSet[c] == 2 then\13\n\9\9\9\9if previousForeground ~= t.aSet[c][1] then\13\n\9\9\9\9\9gpu.setForeground(t.aSet[c][1])\13\n\9\9\9\9\9previousForeground = t.aSet[c][1]\13\n\9\9\9\9end\13\n\9\9\9\9if previousBackground ~= t.aSet[c][2] then\13\n\9\9\9\9\9gpu.setBackground(t.aSet[c][2])\13\n\9\9\9\9\9previousBackground = t.aSet[c][2]\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9gpu.set(t.aSet[c][1], t.aSet[c][2], t.aSet[c][3])\13\n\9\9\9end\13\n\9\9\9\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction AddToTexture(t, x, y)\13\n\9for c = 0, t.fillSize, 1 do\13\n\9\9if t.aFill[c] ~= nil then\13\n\9\9\9t.aFill[c][1] = t.aFill[c][1] + x\13\n\9\9\9t.aFill[c][2] = t.aFill[c][2] + y\13\n\9\9end\13\n\9end\13\n\9for c = 0, t.setSize, 1 do\13\n\9\9if t.aSet[c] ~= nil then\13\n\9\9\9t.aSet[c][1] = t.aSet[c][1] + x\13\n\9\9\9t.aSet[c][2] = t.aSet[c][2] + y\13\n\9\9end\13\n\9end\13\nend",["./data/sp1/data/"] = 0,["./data/sp1/"] = 0,["./data/parents/nge/UiContainer.lua"] = "--[[\n    This file is part of the NosGa Engine.\n\9\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\n\n    The NosGa Engine is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The NosGa Engine is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\n]]\n\nUiContainer = {}\nUiContainer.__index = UiContainer\n\nfunction UiContainer.init(this) \n\9\nend\n\nfunction UiContainer.new(args) \n\9local pa = global.ut.parseArgs\n\9\n\9args = args or {} \n\9args.isParent = true\n\9\n\9--===== default stuff =====--\n\9local this = global.newGameObject(args)\n\9\n\9--===== init =====--\n\9this.name = args.name\n\9this.type = args.type\n\9\n\9--===== custom functions =====--\n\9\n\9--===== default functions =====--\n\9this.pStart = function(this) \n\9\9global.run(this.start, this)\n\9end\n\9\n\9this.pUpdate = function(this, dt, ra, gameObjects, ocgfGameObjects) \n\9\9global.run(this.update, this, dt, ra, this.particles, particleGameObjects)\n\9end\n\9\n\9this.pDraw = function(this, renderArea) \n\9\9global.run(this.draw, this, renderArea)\n\9end\n\9\n\9this.pSUpdate = function(this, dt, ra)\n\9\9global.run(this.sUpdate, this)\n\9end\n\9\n\9this.pClear = function(this, acctual) \n\9\9global.run(this.clear, this)\n\9end\n\9\n\9this.pStop = function(this) \n\9\9global.run(this.stop, this)\n\9end\n\9\n\9return this\nend\n\nreturn UiContainer",["./data/parents/nge/Particle.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal global = ...\13\n\13\nParticle = {}\13\nParticle.__index = Particle\13\n\13\nfunction Particle.init(this) \13\n\9\13\nend\13\n\13\nfunction Particle.new(args) \13\n\9local pa = global.ut.parseArgs\13\n\9--===== default stuff =====--\13\n\9local this = {}\13\n\9this = setmetatable(this, Particle) \13\n\9\13\n\9--===== init =====--\13\n\9this.name = args.name\13\n\9this.color = pa(args.color, 0xFF69B4)\13\n\9this.maxLifeTime = pa(args.pt, args.lifeTime, args.maxLifeTime, -1)\13\n\9\13\n\9this.container = args.container\13\n\9this.lifeTime = pa(args.clt, args.currentLifeTime, 0)\13\n\9\13\n\9this.gameObject = global.ocgf.GameObject.new(global.ocgf, {\13\n\9\9dc = global.conf.debug.drawCollider,\13\n\9\9dt = global.conf.debug.drawTrigger,\13\n\9\9logFunc = global.log,\13\n\9\9posX = pa(args.x, args.posX),\13\n\9\9posY = pa(args.y, args.posY),\13\n\9\9parent = this,\13\n\9})\13\n\9\13\n\9--===== custom functions =====--\13\n\9\13\n\9--===== default functions =====--\13\n\9this.pStart = function(this) \13\n\9\9global.run(this.start, this)\13\n\9end\13\n\9\13\n\9this.pUpdate = function(this, dt, ra, particles, particleGameObjects) \13\n\9\9\13\n\9\9\13\n\9\9this.lifeTime = this.lifeTime +dt\13\n\9\9if this.maxLifeTime ~= -1 and this.lifeTime > this.maxLifeTime then\13\n\9\9\9this:destroy()\13\n\9\9end\13\n\9\9\13\n\9\9--global.log(this.lifeTime)\13\n\9\9\13\n\9\9this.gameObject:updatePhx(particleGameObjects, dt)\13\n\9\9this.gameObject:update(particleGameObjects)\13\n\9\9\13\n\9\9global.run(this.update, this, dt, ra, particles, particleGameObjects)\13\n\9\9\13\n\9\9local x, y = this.gameObject:getPos()\13\n\9\9local lx, ly = this.gameObject:getLastPos()\13\n\9\9\13\n\9\9return this.gameObject:getPos()\13\n\9end\13\n\9\13\n\9this.pDraw = function(this, renderArea, offsetX, offsetY, type) \13\n\9\9\13\n\9\9if global.conf.useDoubleBuffering then\13\n\9\9\9local x1, y1, x2, y2 = renderArea:getRealFOV()\13\n\9\9\9\13\n\9\9\9global.db.setDrawLimit(x1, x2, y1, y2)\13\n\9\9\9\13\n\9\9\9if type == 1 then\13\n\9\9\9\9local x, y = this.gameObject:getPos()\13\n\9\9\9\9x = math.floor(x +offsetX +.5)\13\n\9\9\9\9y = math.floor((y +offsetY) *2 +.5)\13\n\9\9\9\9global.db.semiPixelSet(x, y, this.color)\13\n\9\9\9elseif type == 2 then\13\n\9\9\9\9local x, y = this.gameObject:getPos()\13\n\9\9\9\9x = math.floor(x +offsetX +.5)\13\n\9\9\9\9y = math.floor(y +offsetY +.5)\13\n\9\9\9\9global.db.set(x, y, this.color, 0x000000, \" \")\13\n\9\9\9elseif type == 3 then\13\n\9\9\9\9local x, y = this.gameObject:getPos()\13\n\9\9\9\9x = math.floor(x +offsetX +.5)\13\n\9\9\9\9y = math.floor(y +offsetY +.5)\13\n\9\9\9\9global.db.set(x, y, this.color, 0x000000, \" \")\13\n\9\9\9\9global.db.set(x +1, y, this.color, 0x000000, \" \")\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9global.db.resetDrawLimit()\13\n\9\9end\13\n\9\9\13\n\9\9global.run(this.draw, this, renderArea, offsetX, offsetY)\13\n\9end\13\n\9\13\n\9this.pClear = function(this, acctual) \13\n\9\9global.run(this.clear, this)\13\n\9end\13\n\9\13\n\9this.pStop = function(this) \13\n\9\9global.run(this.stop, this)\13\n\9end\13\n\9\13\n\9this.destroy = function(this)\13\n\9\9this.container:remParticle(this)\13\n\9end\13\n\9\13\n\9return this\13\nend\13\n\13\nreturn Particle\13\n",["./data/parents/nge/ParticleContainer.lua"] = "--[[\13\n    This file is part of the NosGa Engine.\13\n\9\13\n\9NosGa Engine Copyright (c) 2019-2020 NosPo Studio\13\n\13\n    The NosGa Engine is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    The NosGa Engine is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with the NosGa Engine.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[\13\nToDo:\13\n\9Add braille char support (doubleing the particle resolution) (https://en.wikipedia.org/wiki/Braille_Patterns).\13\n\9\13\n]]\13\n\13\nlocal global = ...\13\n\13\nlocal function print(...)\13\n\9if global.conf.debug.pcDebug then\13\n\9\9global.debug(...)\13\n\9end\13\nend\13\n\13\nlocal function addRenderMapEntry(map, x, y, entry)\13\n\9if map[x] == nil then\13\n\9\9map[x] = {}\13\n\9end\13\n\9map[x][y] = entry\13\nend\13\n\13\nlocal function move(this, x, y, sx, sy)\13\n\9--this:move(x, y)\13\n\9this:moveTo(x, y)\13\n\9this.ngeAttributes.sizeX = sx\13\n\9this.ngeAttributes.sizeY = sy\13\n\9this.ngeAttributes.clearAreas[1].sizeX = sx\13\n\9this.ngeAttributes.clearAreas[1].sizeY = sy\13\n\9this.hasMoved = true\13\nend\13\n\13\nParticleContainer = {}\13\nParticleContainer.__index = ParticleContainer\13\n\13\nfunction ParticleContainer.init(this) \13\n\9\13\nend\13\n\13\nfunction ParticleContainer.new(args) \13\n\9local pa = global.ut.parseArgs\13\n\9\13\n\9args = args or {} \13\n\9args.isParent = true\13\n\9args.useAnimation = true\13\n\9args.sizeX = 1\13\n\9args.sizeY = 1\13\n\9args.solid = false\13\n\9\13\n\9args.components = {\13\n\9\9{\"Sprite\", posX = 0, posY = 0, texture = global.oclrl.generateTexture({})},\13\n\9}\13\n\9\13\n\9--===== default stuff =====--\13\n\9local this = global.core.GameObject.new(args) \13\n\9this = setmetatable(this, ParticleContainer) \13\n\9\13\n\9--===== init =====--\13\n\9\13\n\9this.name = args.name\13\n\9this.type = args.type\13\n\9this.useCollision = pa(args.uc, args.useCollision, false)\13\n\9this.particleSizeX = 1\13\n\9\13\n\9if this.type == 2 then\13\n\9\9this.particleSizeX = 2\13\n\9end\13\n\9\13\n\9this.particles = {}\13\n\9this.moveToX, this.moveToY, this.newSizeX, this.newSizeY = 0, 0, this.ngeAttributes.sizeX, this.ngeAttributes.sizeY\13\n\9this.hasMoved = false\13\n\9this.lastMaxX = -2^32\13\n\9this.lastMaxY = -2^32\9\13\n\9\13\n\9--===== custom functions =====--\13\n\9this.addParticle = function(this, particle, x, y, args)\13\n\9\9args = args or {}\13\n\9\9print(\"[PC][\" .. tostring(this.name) .. \"]: Creating particle, F: \" .. tostring(global.currentFrame))\13\n\9\9\13\n\9\9local posX, posY = this:getPos()\13\n\9\9args.x = x\13\n\9\9args.y = y\13\n\9\9args.container = this\13\n\9\9\13\n\9\9if type(particle) == \"string\" then\13\n\9\9\9particle = global.gameObject[particle]\13\n\9\9end\13\n\9\9particle = particle.new(args)\13\n\9\9\13\n\9\9print(\"[PC][\" .. tostring(this.name) .. \"]: Adding particle: \" .. tostring(particle.name) .. \", X: \" ..tostring(x) .. \", Y: \" .. tostring(y) .. \", F: \" .. tostring(global.currentFrame))\13\n\9\9\13\n\9\9this.particles[particle] = true\13\n\9\9\13\n\9\9return particle\13\n\9end\13\n\9\13\n\9this.remParticle = function(this, particle)\13\n\9\9this.particles[particle] = nil\13\n\9\9particle = nil\13\n\9end\13\n\9\13\n\9--===== default functions =====--\13\n\9this.pStart = function(this) \13\n\9\9global.run(this.start, this)\13\n\9end\13\n\9\13\n\9this.pUpdate = function(this, dt, ra, gameObjects, ocgfGameObjects) \13\n\9\9local offsetX, offsetY = this:getOffset(ra)\13\n\9\9local particleGameObjects = {}\13\n\9\9local particlePositions = {}\13\n\9\9local renderMap = {}\13\n\9\9local toRender = {}\13\n\9\9local posX, posY = this:getPos()\13\n\9\9local minX, maxX, minY, maxY = 2^32, -2^32, 2^32, -2^32\13\n\9\9local particleCount = 0\13\n\9\9local isVisible = false\13\n\9\9\13\n\9\9if this.useCollision then\13\n\9\9\9for p, c in pairs(this.particles) do\13\n\9\9\9\9table.insert(particleGameObjects, p.gameObject)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9if ocgfGameObjects ~= nil then\13\n\9\9\9\9for i, go in pairs(ocgfGameObjects) do\13\n\9\9\9\9\9table.insert(particleGameObjects, go)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9for p, c in pairs(this.particles) do\13\n\9\9\9local x, y = p:pUpdate(dt, ra, this.particles, particleGameObjects)\13\n\9\9\9\13\n\9\9\9minX = math.min(x, minX)\13\n\9\9\9minY = math.min(y, minY)\13\n\9\9\9maxX = math.max(x, maxX)\13\n\9\9\9maxY = math.max(y, maxY)\13\n\9\9\9\13\n\9\9\9if this.type == 1 then\13\n\9\9\9\9addRenderMapEntry(renderMap, math.floor(x - posX), math.floor((y - posY) *2 +.5), true)\13\n\9\9\9end\13\n\9\9\9particleCount = particleCount +1\13\n\9\9end\13\n\9\9\13\n\9\9if particleCount > 0 then\13\n\9\9\9this.hasMoved = false\13\n\9\9\9\13\n\9\9\9this.moveToX, this.moveToY = math.floor(minX), math.floor(minY)\13\n\9\9\9\13\n\9\9\9local sx, sy = 0, 0\13\n\9\9\9\13\n\9\9\9if maxX > this.lastMaxX then\13\n\9\9\9\9sx = maxX - this.moveToX\13\n\9\9\9else\13\n\9\9\9\9sx = this.lastMaxX - this.moveToX\13\n\9\9\9end\13\n\9\9\9if maxY > this.lastMaxY then\13\n\9\9\9\9sy = maxY - this.moveToY\13\n\9\9\9else\13\n\9\9\9\9sy = this.lastMaxY - this.moveToY\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9this.newSizeX = sx +2 +this.particleSizeX\13\n\9\9\9this.newSizeY = sy +2\13\n\9\9\9this.lastMaxX = maxX\13\n\9\9\9this.lastMaxY = maxY\13\n\9\9else\13\n\9\9\9this.newSizeX, this.newSizeY, this.lastMaxX, this.lastMaxY = 1, 1, 1, 1\13\n\9\9\9move(this, this.moveToX, this.moveToY, this.newSizeX, this.newSizeY)\13\n\9\9end\13\n\9\9\13\n\9\9for ra, s in pairs(this.ngeAttributes.isVisibleIn) do\13\n\9\9\9this:ngeClear(ra)\13\n\9\9\9\13\n\9\9\9isVisible = true\13\n\9\9\9--break\13\n\9\9end\13\n\9\9if not isVisible then\13\n\9\9\9move(this, this.moveToX, this.moveToY, this.newSizeX, this.newSizeY)\13\n\9\9end\13\n\9\9\13\n\9\9global.run(this.update, this, dt, ra, this.particles, particleGameObjects)\13\n\9\9\13\n\9\9this.ngeAttributes.clearedAlready = true\13\n\9\9--move(this, this.moveToX, this.moveToY, this.newSizeX, this.newSizeY)\13\n\9end\13\n\9\13\n\9this.pDraw = function(this, renderArea) \13\n\9\9local offsetX, offsetY = this:getOffset(renderArea)\13\n\9\9\13\n\9\9if this.hasMoved == false then\9\13\n\9\9\9--global.log(this.moveToX, this.moveToY, this.newSizeX, this.newSizeY)\13\n\9\9\9\13\n\9\9\9move(this, this.moveToX, this.moveToY, this.newSizeX, this.newSizeY)\13\n\9\9\9this.hasMoved = true\13\n\9\9end\13\n\9\9\13\n\9\9global.run(this.draw, this, renderArea)\13\n\9\9\13\n\9\9for p, c in pairs(this.particles) do\13\n\9\9\9p:pDraw(renderArea, offsetX, offsetY, this.type)\13\n\9\9end\13\n\9\9\13\n\9\9this.isUpdated = false\13\n\9end\13\n\9\13\n\9this.pSUpdate = function(this, dt, ra)\13\n\9\9--move(this, this.moveToX, this.moveToY, this.newSizeX, this.newSizeY)\13\n\9end\13\n\9\13\n\9this.pClear = function(this, acctual) \13\n\9\9global.run(this.clear, this)\13\n\9end\13\n\9\13\n\9this.pStop = function(this) \13\n\9\9global.run(this.stop, this)\13\n\9end\13\n\9\13\n\9return this\13\nend\13\n\13\nreturn ParticleContainer",["./data/parents/nge/"] = 0,["./data/parents/"] = 0,["./data/"] = 0,["./texturePacks/default/animations/legs/frames/1.pic"] = "OCIF\6\n\4\1\0\0\1\3@\1@\3\1\4\3\4\7\8\2\4\3\4\7\8\3\4\3\4\7\8'\2'\4\1\6\1\2\5\6\9\n\2\6\1\2\5\6\9\n\3\6\1\2\5\6\9\n\4\4\1\2\6\n[\1\4\2\5\9[\1[\1\4\4\3\4\7\8",["./texturePacks/default/animations/legs/frames/2.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\6\7[\1\3\2\4\5'\2'\4\1\6\1\2\3\8\9\n\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n[\1\4\1\8[\2'\1\4\2\4\5[\1\4\2\6\7",["./texturePacks/default/animations/legs/frames/3.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\2\1\2\5\6\2\2\5\6[\1\3\2\5\6'\1'\4\1\8\1\2\3\4\7\8\9\n\2\8\1\2\3\4\7\8\9\n\3\8\1\2\3\4\7\8\9\n\4\7\1\2\3\4\8\9\n[\1[\1\4\3\5\6\7",["./texturePacks/default/animations/legs/frames/4.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\4\5[\1\3\2\6\7'\1'\4\1\6\1\2\3\8\9\n\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n[\2'\1\4\2\7\8[\1\4\3\4\5\6",["./texturePacks/default/animations/legs/frames/"] = 0,["./texturePacks/default/animations/legs/info.lua"] = "local info = {\n\9format = \"pan\",\n\9version = \"v0.1\",\n\9frameTime = .1,\n}\n\nreturn info",["./texturePacks/default/animations/legs/"] = 0,["./texturePacks/default/animations/"] = 0,["./texturePacks/default/textures/player.org/head1.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\2\0\1\3\2\5\7\1\4\1\6\3\0\1\2\1\6\4\2\3\5\7\8\3\4\3\4\6\8\4\5\2\3\4\5\7\5\4\3\4\5\6'\1\4\2\1\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player.org/hat.pic"] = "OCIF\6\8\5\1\0\0\1\3\1\2\1\2\4\5\2\6\2\3\4\5\6\7\2\2\3\4\1\2\3\4\4\2\1\2'\1\4\1\3'\2\2\1\2\3\6\2\2\1\8'\4\1\4\1\2\7\8\3\4\5\6\7\8\4\5\4\5\6\7\8\5\8\1\2\3\4\5\6\7\8",["./texturePacks/default/textures/player.org/arm3.pic"] = "OCIF\6\20\17\1\0\0\1\3\1\1\7\2\19\20'\2\1\6\1\19'\17\1\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\2\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\3\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\4\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\5\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\6\19\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\20\7\7\1\2\3\4\5\6\7\8\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\9\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\n\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\11\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\12\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\13\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\14\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\15\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\16\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\17\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\13\1\13\1\7\11\8\9\n\11\12\13\14\15\16\17\18",["./texturePacks/default/textures/player.org/head2.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\2\0\1\3\1\6\1\3\2\5\7\3\0\1\2\1\6\4\2\3\5\7\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6'\1\4\2\1\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player.org/body.pic"] = "OCIF\6\20\17\1\0\0\1\3@\2@\1\13\n\3\4\5\6\7\8\9\n\11\12'\1\14\8\4\5\6\7\8\9\n\0113\0013\6\7\8\4\5\6\7\8\9\n\11\8\n\3\4\5\6\7\8\9\n\11\12\9\n\3\4\5\6\7\8\9\n\11\12\n\n\3\4\5\6\7\8\9\n\11\12\11\n\3\4\5\6\7\8\9\n\11\12\12\n\3\4\5\6\7\8\9\n\11\12'\0023\1\7\2\3\12'\17\1\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\2\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\3\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\4\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\5\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\6\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\7\n\1\2\13\14\15\16\17\18\19\20\8\n\1\2\13\14\15\16\17\18\19\20\9\n\1\2\13\14\15\16\17\18\19\20\n\n\1\2\13\14\15\16\17\18\19\20\11\n\1\2\13\14\15\16\17\18\19\20\12\n\1\2\13\14\15\16\17\18\19\20\13\n\1\2\13\14\15\16\17\18\19\20\14\12\1\2\3\12\13\14\15\16\17\18\19\20\15\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\16\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\17\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20",["./texturePacks/default/textures/player.org/legs/1.pic"] = "OCIF\6\n\4\2\0\0\1\2@\1@\3\1\4\3\4\7\8\2\4\3\4\7\8\3\4\3\4\7\8[\1[\1\4\4\3\4\7\8\0\3\1'\1'\1\1\2\1\n \1\0\1\0\4\1\4\2\5\6\9\2\6\1\2\5\6\9\n\3\6\1\2\5\6\9\n\4\4\1\2\6\n\1\0\1[\1\4\2\5\9",["./texturePacks/default/textures/player.org/legs/2.pic"] = "OCIF\6\n\4\2\0\0\1\2@\2@\3\1\1\4\2\4\4\5\6\7\3\2\6\7[\1\3\2\4\5[\1[\1\4\2\6\7\0\3 \1\0\1\0\4\1\3\2\8\9\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n\2@\1@\1\1\1\3[\1[\1\4\2\4\5\1\0\3@\1\1\3\5\6\7'\1\1\2\1\n[\1\4\1\8",["./texturePacks/default/textures/player.org/legs/3.pic"] = "OCIF\6\n\5\2\0\0\1\2@\1@\3\1\2\5\6\2\2\5\6\3\2\5\6[\1[\2\4\2\5\6\5\2\5\6\0\3 \1\0\1\0\5\1\8\1\2\3\4\7\8\9\n\2\6\2\3\4\7\8\9\3\8\1\2\3\4\7\8\9\n\4\7\1\2\3\4\8\9\n\5\7\1\2\3\4\8\9\n\1'\1'\1\2\2\1\n\1\0\1[\2\4\1\7\5\1\7",["./texturePacks/default/textures/player.org/legs/4.pic"] = "OCIF\6\n\4\2\0\0\1\2@\2@\3\1\2\6\7\2\4\4\5\6\7\3\2\4\5[\1\3\2\6\7[\1[\1\4\3\4\5\6\0\3 \1\0\1\0\4\1\4\2\3\8\9\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n\1[\1[\1\4\2\7\8\1\0\2@\1\1\2\4\5'\1\1\2\1\n",["./texturePacks/default/textures/player.org/legs/"] = 0,["./texturePacks/default/textures/player.org/arm1.pic"] = "OCIF\6\20\17\1\0\0\1\3\2\1\13\2\8\9'\1\13\1\n'\1'\17\1\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\2\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\3\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\4\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\5\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\6\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\7\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\8\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\9\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\n\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\11\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\12\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\13\17\1\2\3\4\5\6\7\11\12\13\14\15\16\17\18\19\20\14\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\15\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\16\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\17\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\13\1\13\6\7\2\8\9\8\2\8\9\9\2\8\9\n\2\8\9\11\2\8\9\12\2\8\9",["./texturePacks/default/textures/player.org/arm2.pic"] = "OCIF\6\20\17\1\0\0\1\3\1\2\8\1\7\9\2\7\8'\3\1\8\1\8'\17\1\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\2\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\3\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\4\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\5\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\6\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\7\11\n\11\12\13\14\15\16\17\18\19\20\8\12\9\n\11\12\13\14\15\16\17\18\19\20\9\13\1\9\n\11\12\13\14\15\16\17\18\19\20\n\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\11\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\12\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\13\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\14\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\15\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\16\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\17\20\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\13\2\7\1\1\8\3\4\5\6\13\1\13\3\7\8\2\3\4\5\6\7\8\9\8\3\1\2\3\9\5\2\3\4\5\6",["./texturePacks/default/textures/player.org/head3.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\1\1\3\1\6\3\0\2\2\2\5\7\3\2\5\7\4\2\2\6\8\3\3\3\4\8\4\5\2\3\4\5\6\5\4\3\4\5\6'\1\4\3\1\7\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player.org/"] = 0,["./texturePacks/default/textures/arm1.pic"] = "OCIF\6\20\7\2\0\0\1\2\1\1\7\2\8\9\13\1\13\5\2\2\8\9\3\2\8\9\4\2\8\9\5\2\8\9\6\2\8\9\0\3\2\1\1\7\1\n'\1'\1\1\2\1\20 \1\0\1\0\7\1\16\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\2\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\3\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\4\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\5\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\6\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\7\17\1\2\3\4\5\6\7\11\12\13\14\15\16\17\18\19\20\1\0\1\13\1\1\2\8\9",["./texturePacks/default/textures/player/head1.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\2\0\1\3\2\5\7\1\4\1\6\3\0\1\2\1\6\4\2\3\5\7\8\3\4\3\4\6\8\4\5\2\3\4\5\7\5\4\3\4\5\6'\1\4\2\1\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player/hat.pic"] = "OCIF\6\8\4\1\0\0\1\3\1\2\1\2\4\5\2\6\2\3\4\5\6\7\2\2\3\4\1\2\3\4\4\2\1\2'\1\4\1\3'\2\2\1\2\3\6\2\2\1\8'\3\1\4\1\2\7\8\3\4\5\6\7\8\4\5\4\5\6\7\8",["./texturePacks/default/textures/player/arm3.pic"] = "OCIF\6\13\2\1\0\0\1\3\1\2\1\1\12\2\2\12\13'\2\1\1\1\13\13\1\1\11\1\2\3\4\5\6\7\8\9\n\11\13\1\13\1\2\11\1\2\3\4\5\6\7\8\9\n\11",["./texturePacks/default/textures/player/head2.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\2\0\1\3\1\6\1\3\2\5\7\3\0\1\2\1\6\4\2\3\5\7\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6'\1\4\2\1\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player/body.pic"] = "OCIF\6\n\7\1\0\0\1\3@\2@\1\7\8\2\3\4\5\6\7\8\9'\1\7\2\1\n3\2@\1\6\n\1\2\3\4\5\6\7\8\9\n3\5\1\8\2\3\4\5\6\7\8\9\2\n\1\2\3\4\5\6\7\8\9\n\3\n\1\2\3\4\5\6\7\8\9\n\4\n\1\2\3\4\5\6\7\8\9\n\5\n\1\2\3\4\5\6\7\8\9\n'\0013\1\1\2\1\n",["./texturePacks/default/textures/player/legs/1.pic"] = "OCIF\6\n\4\1\0\0\1\3@\1@\3\1\4\3\4\7\8\2\4\3\4\7\8\3\4\3\4\7\8'\2'\4\1\6\1\2\5\6\9\n\2\6\1\2\5\6\9\n\3\6\1\2\5\6\9\n\4\4\1\2\6\n[\1\4\2\5\9[\1[\1\4\4\3\4\7\8",["./texturePacks/default/textures/player/legs/2.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\6\7[\1\3\2\4\5'\2'\4\1\6\1\2\3\8\9\n\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n[\1\4\1\8[\2'\1\4\2\4\5[\1\4\2\6\7",["./texturePacks/default/textures/player/legs/3.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\2\1\2\5\6\2\2\5\6[\1\3\2\5\6'\1'\4\1\8\1\2\3\4\7\8\9\n\2\8\1\2\3\4\7\8\9\n\3\8\1\2\3\4\7\8\9\n\4\7\1\2\3\4\8\9\n[\1[\1\4\3\5\6\7",["./texturePacks/default/textures/player/legs/4.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\4\5[\1\3\2\6\7'\1'\4\1\6\1\2\3\8\9\n\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n[\2'\1\4\2\7\8[\1\4\3\4\5\6",["./texturePacks/default/textures/player/legs/"] = 0,["./texturePacks/default/textures/player/arm1.pic"] = "OCIF\6\3\7\1\0\0\1\3\2\1\7\2\1\2'\1\7\1\3'\2'\6\1\1\3\2\1\3\3\1\3\4\1\3\5\1\3\6\1\3\13\1\1\2\1\2\13\1\13\5\2\2\1\2\3\2\1\2\4\2\1\2\5\2\1\2\6\2\1\2",["./texturePacks/default/textures/player/arm2.pic"] = "OCIF\6\9\3\1\0\0\1\3\1\1\3\2\7\8'\2'\2\1\1\1\3\1\9\13\1\1\8\2\3\4\5\6\7\8\9\13\3\1\2\1\7'\2\2\5\4\5\6\8\9\3\1\1\13\2\2\3\1\2\3\3\5\2\3\4\5\6",["./texturePacks/default/textures/player/head3.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\1\1\3\1\6\3\0\2\2\2\5\7\3\2\5\7\4\2\2\6\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6'\1\4\2\1\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player/"] = 0,["./texturePacks/default/textures/background.pic"] = "OCIF\62\1\0\0\1\28\6\20 \1E\11\1d\12\4hk\13*,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQhk\14\12,-./NOPQhk\15\12,-./NOPQhk\16\12,-./NOPQhk\17\12,-./NOPQhk\18\12,-./NOPQhk\19\12,-./NOPQhk\20\12,-./NOPQhk\21\12,-./NOPQhk\22\12,-./NOPQhk\23\12,-./NOPQhk\24*,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQhk\25%,-./023456789:<=>?@ABCDEFHIJKLMOPhk\26\6,-.NOQ\27\7,/OPhk\28\4,OQk\29\1\1\n;fghijklmnopqrstuvwxyz{|}~\127\1\14\0300123456789:;<=>?@ABCDEFGHIJKLMU\4\24\1#\25\0021Q\27\1N\28\3.Ph\2\29\n\20\30<V`my|\31\8\11 -Qdet\127\8 \2;\25\1N\26\3/Pk\27\1Q\28\1\29\2>z\30\0014\31\1|\3\1\11:efghklmnopqrstuvwxyz{|}~\127\23\2\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\3\8\11\12MNST\4\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\5\8\11\12MNST\6\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\11\2ij\12\2ij\13\2ij\14\2ij\15\2ij\16\2ij\17\2ij\18\2ij\19\2ij\20\2ij\21\2ij\22\2ij\23\2ij\24\2ij\25\2ij\26\1i\27\1j\28\1i\127\1\27\1iB\3B\17\0123lmnopqrstuvwxyz{|}~\127\0133lmnopqrstuvwxyz{|}~\127\0143lmnopqrstuvwxyz{|}~\127\0153lmnopqrstuvwxyz{|}~\127\0163lmnopqrstuvwxyz{|}~\127\0173lmnopqrstuvwxyz{|}~\127\0183lmnopqrstuvwxyz{|}~\127\0193lmnopqrstuvwxyz{|}~\127\0203lmnopqrstuvwxyz{|}~\127\0213lmnopqrstuvwxyz{|}~\127\0223lmnopqrstuvwxyz{|}~\127\0233lmnopqrstuvwxyz{|}~\127\0243lmnopqrstuvwxyz{|}~\127\0253lmnopqrstuvwxyz{|}~\127\26\11lmnopq\27)lmopqrstuwz{|}~\127\28\26lmoqtwz{|~l\2\27\1\28\4rvm\2\27\2\28\5p\127\12\3\2\n\1e\12&,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQ\2\12\5YZ[\\]\13\2W_\12\28\1\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\2\24\1\2\3\4\5\6\7\8\9\nOPQR\3\1\2\3\4\5\6\7\8\9\n\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLOPQRUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\4\24\1\2\3\4\5\6\7\8\9\nOPQR\5\1\2\3\4\5\6\7\8\9\n\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLOPQRUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\6\24\1\2\3\4\5\6\7\8\9\nOPQR\7\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\8\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\9\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127\nd\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcd\11c\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abc\12<\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWX^_`abcdefg\0138\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUV`abcdefg\0148\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUV`abcdefg\0158\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUV`abcdefg\16:\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVW_`abcdefg\0172\1\2\3\4\5\6\7\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWXYZ\\]^_`abcdefg\0182\1\2\3\4\5\6\7\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWXYZ\\]^_`abcdefg\0192\1\2\3\4\5\6\7\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWXYZ\\]^_`abcdefg\0202\1\2\3\4\5\6\7\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWXYZ\\]^_`abcdefg\0212\1\2\3\4\5\6\7\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWXYZ\\]^_`abcdefg\0222\1\2\3\4\5\6\7\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWXYZ\\]^_`abcdefg\0232\1\2\3\4\5\6\7\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+RSTUVWXYZ\\]^_`abcdefg\24%\1\2\3\4\5\6\7\22\23\24\25'()*+RSTUVWXYZ\\]^_`abcdefg\25'\1\2\3\4\5\6\7\22\23\24\25\26&'()*+RSTUVWXYZ\\]^_`abcdefg\26G\1\2\3\4\5\6\7\22\23\24\25\26\27%&'()*+0123456789:;<=>?@ABCDEFGHIJKLMRSTUVWXYZ\\]^_`abcdefg\27G\1\2\3\4\5\6\7\22\23\24\25\26\27%&'()*+0123456789:;<=>?@ABCDEFGHIJKLMRSTUVWXYZ\\]^_`abcdefg\28G\1\2\3\4\5\6\7\22\23\24\25\26\27%&'()*+0123456789:;<=>?@ABCDEFGHIJKLMRSTUVWXYZ\\]^_`abcdefgS\3S\14#\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127$\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuwxyz{|}~\127%\1\2\3\4\5\6\8\9\n\11\12\14\15\16\17\18\19\20\21\22\24\25\26\27\28\29\30 !\"#$%&'(),-./012345789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXY^_`abcdghijklmnoqrstuwxyz&\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !$%&'()*+,-./0123456789:;<=>FGHIJKLMPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx{|}~\127'\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\19\20\21\22\23\25\26\27\28\29\30\31 !\"#%&'()*+,-./0123456789<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdgklmnopqrstuvwxyz{|}~\127(\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./012345678;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127)S\6\7\8\9\n\11\16\17\18\19\20\26\27\28\29\30$%&'(./01289:;<BCDEFLMNOPVWXYZ`abcdjklmntuvwx~\127*\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127+\1\2\3\4\5\6\7\8\9\n\11\12\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#%&'()*+,-./012345689:;<=>?@ABCDEIKLMNOPQRSTUVWXYZ[\\]^_`abcefghimnopqrstuvwxyz{|}~\127,\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?EFGHIJKLMNOPQRTUVWXYZ[\\]^_`abcefghijklmnopqrsvwxyz{|~\127-\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\21\22\23\24\25\26\29\30\31 !\"#$%&'()*+,-/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|.\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !#$%&'()*+,/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\]^_`abcdefghijklmpqrstuvxyz{|}~/\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !$%&'()*+,-./03456789;<=>?@ABCEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcfghijklmnopqrstuvxyz{~\1270\1\2\3\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABDEFGHIJKLNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127U\n$\6\18\19Pv%\7\7\\]ef&\7\"#?@ANO'\5\18:;ef+\5\0137Fd\28\1\31,\3@A-\5\9.}~\127.\6\"w/\0061:Mde\0011\1\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\127T\3S\1\28\2\29!T\3\25\4\29\31!#\26\4\29\31!#\27\4\29\31!#U\1\28\1#\4\1\13\2Z\\S\1\14\5XY[\\^\1\14\4WZ]_8\2\16\3Z[\\\15\9WXYZ[\\]^_U\7\3\25\1G\26\1h\28\3$/S\n0\3\4CM%\13\13\23*6Zpv{|}~&\5CDEyz'\7\24$hij(\4\16\0179:+\7$GHJjk,\7BCDdtu-\7\19\27\28ST.\8-.[no\127/\9\"#w|}T\2\24\3\31!$\28\1\"U\0122\1\2\3\4\5\6\7\9\n\11\12\13\14\15\16\17\19\20\21\22\23\24\25\26\27\29\30\31 !\"#$%'()*+,-./123456789;<=>?@ABCEFGHIJKLMOPQRSTUVWYZ[\\]^_`abcdefghijkmnopqrstuwxyz{|}~\127%\4\31+[\127&\1B\24\5\26\27\29 %\25\5\28\30 \"$\26\5\28\30 \"$\27\6\28\30 \"$-+\1l\28\2\30 ,\2S}-\2\8\20/\0022D\12\1\25\2\27%\127\3\24\1\30\26\1\21\28\3\12\16j\1\"\1\3\4\5\6\7\8\9\n\11\13\14\15\16\17\18\19\20\21\23\24\25\26\27\28\29\30\31!\"#$%&'()+,-./012356789:;<=?@ABCDEFGIJKLMNOPQSTUVWXYZ[]^_`abcdeghijklmnoqrstuvwxy{|}~\127V\1[\1\26\7tx\2U\1!\1y\2 \4B~\127\30\8\11\25\30!-\1S\1)\1A[\2V\1\26\8{|\127[\1\26\27rsuvwyz}~*\0010\1\28\1x\3U\1!\2?D\1\30\2BG\1\30\1=\6U\1!l\1\3\5\6\7\8\n\11\13\15\16\17\18\20\21\23\25\26\27\28\30\31!#$%&()+-./0235789:<=ABCFGIKLMNPQSUVWXZ[]_`abdegijklnoqstuvx{}~\127\2 \8\16\0318Vk\30\3&F[\2\25\1[\26\1[\11 n\1\2\3\5\6\7\8\n\11\12\13\15\17\18\20\21\22\23\25\26\28\30 !#&()*+-./0234579:<=>?ACDFGHIKLMNPQRSUWXZ[\\]_`abdefgijlnopqtuvxyz{}\17\1[\18\1[\19\1[\20\1[\21\1[\22\1[\23\1[\24\1[\27\1[\30k\1\3\4\5\6\8\9\n\13\14\15\16\18\19\20\21\24\26\28\29\31\"$'(+,.0135678:;<?@ADEIJKLNOPQSTUVXYZ]^_`bcdeghijlmnoqstvxy{|}~\2 \2%s\30\2\23)~\1!\16\2\12\22 *4>HR\\fpzl\1B\2\27\2v\28\7nu\3U\1!\1\2 \3\27$\30\5#2rw\1 \1\2\8\18\5\n\12\13\16\19\19\5\n\13\16\17\19\20\5\n\12\14\17\19\21\4\n\14\17\19\22\7\n\12\13\15\16\18\19\23\4\n\12\16\19\24\6\n\12\14\15\18\19\25\7\n\12\13\15\16\17\19?\7\18\5\11\14\15\17\18\19\1\15\20\5\11\13\15\16\18\21\1\12\22\3\11\14\17\23\1\14\24\4\11\13\16\17m\1B\2\27\1n\28\5s}0\0020\2\27\3xy\28\2y*\2\27\1\28\1\2\4\17\0046;AH\19\008257>@DHL\21\00415=@\15\00625:FHL\9\16\013269;>ABCEFHIL\17\008139=@DEK\18\n357:>@BEIK\19\n139:;=AFIK\20\0111369:;=BEIL\21\00923679:DGK\22\0111237:=ADGHL\23\01613458:<=@ACEFGIK\15\008137=?AEI\1\1\13\5XY[]^\2\3\17\0042>FL\21\6;>BEIL\15\00569>BJ\9\16\0170134578:<=?@DGJKM\17\01404578:<?BCGIJM\18\0200124689;<=?ACDFGHJLM\19\0120468<?BCEGJM\20\019024578<>?@ACDFGHJKM\21\011048<?ACFHJM\22\019045689;<>?@BCEFIJKM\23\01402679;>?BDHJLM\15\011048;<@CDGKM8\0028\1\16\2Y]\12\1\16\2X^~\3~\0022\15\8\18\28&0:DNXlv\28\1\n\127\1\28\3\13\15\18\1\"\16\2\12\22 *4>HR\\fpz\127\n\5 \4\0091w\27\2.\28\1-\30\2\17%\31\1\4\1\26\1jT\1\24\1\28U\5! \4\9\14\19\24\29\"',16;@EJOTY^chmrw|\24\2\"&\26\2\11\17\27\1\19\28\4\8\17\28N\1\29\3'\1\29\2=B\3\28\1[\29n\1\3\4\5\6\8\9\n\11\13\14\15\16\18\19\21\23\25\26\29\31!\"#$&()+,-.01235678:;?@ADEFGIJKLNOPQSTUXYZ[]^_bcdeghijlnoqrstvwx{}~\31w\1\2\3\5\6\7\8\n\12\13\15\16\17\18\20\21\22\23\25\26\27\28\31!#$%&()*+./02345789:<=>?ABCDFGHIKLMNPRSUVWXZ[\\]_`abfgijklnopqsuvxyz{}~\127\2\29\3\24\28\31\1\30~\2\27\3\9\15\18\28\1\20\127\16 \25\4\14\19\24\29\"',6@JOTY^chmr|\17\14\8\9\n\11\12\13\14\15\16\17\18\19\20\21\18\4\8\9\20\21\19\4\8\9\20\21\20\4\8\9\20\21\21\4\8\9\20\21\22\4\8\9\20\21\23\4\8\9\20\21\24\4\8\9\20\21\25\5\8\9\20\21;\26\11\8\9\n\12\13\14\15\16\18\19\20\27\n\8\n\11\12\13\14\16\17\20\21\28\5\9\11\14\19\21\29\29\2\7\12\17\22\27 %*/49CHMRW\\afkpu\127\30\29\2\7\12\22\27 */9>CHMRW\\afkpuz\127\31\30\9\14\19\24\29\"',16;@EJOTY^chmrw?\2\4\19\1\12\21\3\11\13\16\23\3\13\15\18\25\3\11\14\18?\3\19\3\11\14\18\21\2\15\18\23\2\11\17\1S\1)L\1\2\3\4\5\12\13\14\15\21\22\23\24\25\31 !\"#)*+,-34567=>?@GHIJKQRSTU[\\]^_efghiopqrsyz{|}",["./texturePacks/default/textures/player1_trans/head1.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\2\0\1\3\2\5\7\1\4\1\6\3\0\1\2\1\6\4\2\3\5\7\8\3\4\3\4\6\8\4\5\2\3\4\5\7\5\4\3\4\5\6'\1\4\2\1\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player1_trans/hat.pic"] = "OCIF\6\8\5\1\0\0\1\3\1\2\1\2\4\5\2\6\2\3\4\5\6\7\2\1\3\3\1\2\3'\2\3\1\4\4\3\1\2\3'\2\2\1\2\3\6\2\2\1\8'\4\1\4\1\2\7\8\3\4\5\6\7\8\4\5\4\5\6\7\8\5\8\1\2\3\4\5\6\7\8",["./texturePacks/default/textures/player1_trans/arm3.pic"] = "OCIF\6\20\2\2\0\0\1\3\1\2\1\1\19\2\2\19\20'\1\1\1\1\20\13\1\13\1\2\11\8\9\n\11\12\13\14\15\16\17\18\0\3\1'\1'\1\1\1\1 \1\0\1\0\2\1\6\2\3\4\5\6\7\2\7\1\2\3\4\5\6\7\1\0\1\13\1\1\11\8\9\n\11\12\13\14\15\16\17\18",["./texturePacks/default/textures/player1_trans/head2.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\2\0\1\3\1\6\1\3\2\5\7\3\0\1\2\1\6\4\2\3\5\7\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6'\1\4\2\1\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player1_trans/body.pic"] = "OCIF\6\n\7\2\0\0\1\2@\1@\1\7\8\2\3\4\5\6\7\8\0093\2@\1\6\n\1\2\3\4\5\6\7\8\9\n3\5\1\8\2\3\4\5\6\7\8\9\2\n\1\2\3\4\5\6\7\8\9\n\3\n\1\2\3\4\5\6\7\8\9\n\4\n\1\2\3\4\5\6\7\8\9\n\5\n\1\2\3\4\5\6\7\8\9\n\0\2\1@\1@\1\7\2\1\n\1\0\0013\1\1\2\1\n",["./texturePacks/default/textures/player1_trans/legs/1.pic"] = "OCIF\6\n\4\1\0\0\1\3@\1@\3\1\4\3\4\7\8\2\4\3\4\7\8\3\4\3\4\7\8'\2'\4\1\6\1\2\5\6\9\n\2\6\1\2\5\6\9\n\3\6\1\2\5\6\9\n\4\4\1\2\6\n[\1\4\2\5\9[\1[\1\4\4\3\4\7\8",["./texturePacks/default/textures/player1_trans/legs/2.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\6\7[\1\3\2\4\5'\2'\4\1\6\1\2\3\8\9\n\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n[\1\4\1\8[\2'\1\4\2\4\5[\1\4\2\6\7",["./texturePacks/default/textures/player1_trans/legs/3.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\2\1\2\5\6\2\2\5\6[\1\3\2\5\6'\1'\4\1\8\1\2\3\4\7\8\9\n\2\8\1\2\3\4\7\8\9\n\3\8\1\2\3\4\7\8\9\n\4\7\1\2\3\4\8\9\n[\1[\1\4\3\5\6\7",["./texturePacks/default/textures/player1_trans/legs/4.pic"] = "OCIF\6\n\4\1\0\0\1\3@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\4\5[\1\3\2\6\7'\1'\4\1\6\1\2\3\8\9\n\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n[\2'\1\4\2\7\8[\1\4\3\4\5\6",["./texturePacks/default/textures/player1_trans/legs/"] = 0,["./texturePacks/default/textures/player1_trans/arm1.pic"] = "OCIF\6\20\7\2\0\0\1\2\1\1\7\2\8\9\13\1\13\5\2\2\8\9\3\2\8\9\4\2\8\9\5\2\8\9\6\2\8\9\0\3\2\1\1\7\1\n'\1'\1\1\2\1\20 \1\0\1\0\7\1\16\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\2\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\3\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\4\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\5\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\6\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\7\17\1\2\3\4\5\6\7\11\12\13\14\15\16\17\18\19\20\1\0\1\13\1\1\2\8\9",["./texturePacks/default/textures/player1_trans/arm2.pic"] = "OCIF\6\20\3\2\0\0\1\2\1\1\3\2\7\8\13\2\1\2\1\7\13\2\2\3\1\2\3\3\5\2\3\4\5\6\0\3\2'\1'\1\1\2\1\20\13\1\13\2\2\5\4\5\6\8\9\3\1\1 \1\0\1\0\3\1\n\n\11\12\13\14\15\16\17\18\19\2\11\n\11\12\13\14\15\16\17\18\19\20\3\12\9\n\11\12\13\14\15\16\17\18\19\20\1\0\1\13\1\1\8\2\3\4\5\6\7\8\9",["./texturePacks/default/textures/player1_trans/head3.pic"] = "OCIF\6\8\5\1\0\0\1\4\0\1\1\3\1\6\3\0\2\2\2\5\7\3\2\5\7\4\2\2\6\8\3\3\3\4\8\4\5\2\3\4\5\6\5\4\3\4\5\6'\1\4\3\1\7\8V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3'\2V\1\1\2\2\7'\2\1\2\1\8\5\4\1\2\7\8",["./texturePacks/default/textures/player1_trans/"] = 0,["./texturePacks/default/textures/player1/head-hit.pic"] = "OCIF\6\8\5\2\0\0\1\3\0\2\0\1\3\1\6\1\3\2\5\7\2\0\1\2\1\6\4\2\3\5\7\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3\0\3 \1\0\1\0\2\1\2\1\8\5\4\1\2\7\8\1\1\1\4\2\1\8\1\0\1V\1\1\2\2\7",["./texturePacks/default/textures/player1/arm1.pic"] = "OCIF\6\20\17\2\0\0\1\3\1\2\16\3\8\9\n\17\2\8\9'\1'\1\1\2\1\20\13\2\1\15\2\8\9\13\13\2\2\8\9\3\2\8\9\4\2\8\9\5\2\8\9\6\2\8\9\7\2\8\9\8\2\8\9\9\2\8\9\n\2\8\9\11\2\8\9\12\2\8\9\13\2\8\9\14\2\8\9\0\2 \1\0\1\0\17\1\18\2\3\4\5\6\7\8\9\n\11\12\13\14\15\16\17\18\19\2\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\3\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\4\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\5\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\6\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\7\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\8\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\9\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\n\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\11\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\12\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\13\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\14\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\15\17\1\2\3\4\5\6\7\11\12\13\14\15\16\17\18\19\20\16\17\1\2\3\4\5\6\7\11\12\13\14\15\16\17\18\19\20\17\18\1\2\3\4\5\6\7\n\11\12\13\14\15\16\17\18\19\20\1\0\1\1\15\1\n",["./texturePacks/default/textures/player1/hat.pic"] = "OCIF\6\8\4\2\0\0\1\2\2\2\1\2\4\5\2\6\2\3\4\5\6\7\1\3\4\1\2\3\4\1\1\4\3\1\2\3\0\3 \1\0\1\0\2\1\4\1\2\7\8\4\5\4\5\6\7\8\1\1\1\3\4\5\6\7\8\1\0\1\2\1\2\3\6\2\2\1\8",["./texturePacks/default/textures/player1/arm3.pic"] = "OCIF\6\20\2\2\0\0\1\3\1\2\1\1\19\2\2\19\20'\1\1\1\1\20\13\1\13\1\2\11\8\9\n\11\12\13\14\15\16\17\18\0\3\1'\1'\1\1\1\1 \1\0\1\0\2\1\6\2\3\4\5\6\7\2\7\1\2\3\4\5\6\7\1\0\1\13\1\1\11\8\9\n\11\12\13\14\15\16\17\18",["./texturePacks/default/textures/player1/head-dead.pic"] = "OCIF\6\8\5\2\0\0\1\3\0\1\1\3\1\6\2\0\2\2\2\5\7\3\2\5\7\4\2\2\6\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3\0\3 \1\0\1\0\2\1\2\1\8\5\4\1\2\7\8\1\1\1\4\2\1\8\1\0\1V\1\1\2\2\7",["./texturePacks/default/textures/player1/legs/1.pic"] = "OCIF\6\n\4\2\0\0\1\2@\1@\3\1\4\3\4\7\8\2\4\3\4\7\8\3\4\3\4\7\8[\1[\1\4\4\3\4\7\8\0\3\1'\1'\1\1\2\1\n \1\0\1\0\4\1\4\2\5\6\9\2\6\1\2\5\6\9\n\3\6\1\2\5\6\9\n\4\4\1\2\6\n\1\0\1[\1\4\2\5\9",["./texturePacks/default/textures/player1/legs/2.pic"] = "OCIF\6\n\4\2\0\0\1\2@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\6\7[\1\3\2\4\5[\1[\1\4\2\6\7\0\3\2'\1'\1\1\2\1\n[\1[\1\4\2\4\5 \1\0\1\0\4\1\4\2\3\8\9\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n\1\0\1[\1\4\1\8",["./texturePacks/default/textures/player1/legs/3.pic"] = "OCIF\6\n\4\2\0\0\1\2@\2@\1\1\2\5\6[\1\2\2\5\6[\1[\2\3\2\5\6\4\2\5\6\0\3\1'\1'\1\1\2\1\n \1\0\1\0\4\1\6\2\3\4\7\8\9\2\8\1\2\3\4\7\8\9\n\3\7\1\2\3\4\8\9\n\4\7\1\2\3\4\8\9\n\1\0\1[\2\3\1\7\4\1\7",["./texturePacks/default/textures/player1/legs/4.pic"] = "OCIF\6\n\4\2\0\0\1\2@\2@\3\1\4\4\5\6\7\2\4\4\5\6\7\3\2\4\5[\1\3\2\6\7[\1[\1\4\3\4\5\6\0\2\2'\1'\1\1\2\1\n[\1[\1\4\2\7\8 \1\0\1\0\4\1\4\2\3\8\9\2\6\1\2\3\8\9\n\3\6\1\2\3\8\9\n\4\5\1\2\3\9\n",["./texturePacks/default/textures/player1/legs/"] = 0,["./texturePacks/default/textures/player1/head2.pic"] = "OCIF\6\8\5\2\0\0\1\3\0\2\0\1\3\1\6\1\3\2\5\7\2\0\1\2\1\6\4\2\3\5\7\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3\0\3 \1\0\1\0\2\1\2\1\8\5\4\1\2\7\8\1\1\1\4\2\1\8\1\0\1V\1\1\2\2\7",["./texturePacks/default/textures/player1/body.pic"] = "OCIF\6\n\7\2\0\0\1\2@\1@\1\7\8\2\3\4\5\6\7\8\0093\2@\1\6\n\1\2\3\4\5\6\7\8\9\n3\5\1\8\2\3\4\5\6\7\8\9\2\n\1\2\3\4\5\6\7\8\9\n\3\n\1\2\3\4\5\6\7\8\9\n\4\n\1\2\3\4\5\6\7\8\9\n\5\n\1\2\3\4\5\6\7\8\9\n\0\2\1@\1@\1\7\2\1\n\1\0\0013\1\1\2\1\n",["./texturePacks/default/textures/player1/head-normal.pic"] = "OCIF\6\8\5\2\0\0\1\3\0\2\0\1\3\2\5\7\1\4\1\6\2\0\1\2\1\6\4\2\3\5\7\8\3\4\3\4\6\8\4\5\2\3\4\5\7\5\4\3\4\5\6V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3\0\3 \1\0\1\0\2\1\2\1\8\5\4\1\2\7\8\1\1\1\4\2\1\8\1\0\1V\1\1\2\2\7",["./texturePacks/default/textures/player1/arm2.pic"] = "OCIF\6\20\3\2\0\0\1\2\1\1\3\2\7\8\13\2\1\2\1\7\13\2\2\3\1\2\3\3\5\2\3\4\5\6\0\3\2'\1'\1\1\2\1\20\13\1\13\2\2\5\4\5\6\8\9\3\1\1 \1\0\1\0\3\1\n\n\11\12\13\14\15\16\17\18\19\2\11\n\11\12\13\14\15\16\17\18\19\20\3\12\9\n\11\12\13\14\15\16\17\18\19\20\1\0\1\13\1\1\8\2\3\4\5\6\7\8\9",["./texturePacks/default/textures/player1/head1.pic"] = "OCIF\6\8\5\2\0\0\1\3\0\2\0\1\3\2\5\7\1\4\1\6\2\0\1\2\1\6\4\2\3\5\7\8\3\4\3\4\6\8\4\5\2\3\4\5\7\5\4\3\4\5\6V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3\0\3 \1\0\1\0\2\1\2\1\8\5\4\1\2\7\8\1\1\1\4\2\1\8\1\0\1V\1\1\2\2\7",["./texturePacks/default/textures/player1/head3.pic"] = "OCIF\6\8\5\2\0\0\1\3\0\1\1\3\1\6\2\0\2\2\2\5\7\3\2\5\7\4\2\2\6\8\3\3\3\4\8\4\6\2\3\4\5\6\7\5\4\3\4\5\6V\2\2\2\1\4\3\2\1\2V\2\1\4\3\4\5\6\2\3\1\2\3\0\3 \1\0\1\0\2\1\2\1\8\5\4\1\2\7\8\1\1\1\4\2\1\8\1\0\1V\1\1\2\2\7",["./texturePacks/default/textures/player1/"] = 0,["./texturePacks/default/textures/"] = 0,["./texturePacks/default/"] = 0,["./texturePacks/example/info.lua"] = "local info = {\13\n\9useBufferWhitelist = false,\13\n\9\13\n\9bufferBlacklist = {\13\n\9\9[\"debug_blacklist\"] = true,\13\n\9\9[\"human\"] = true,\13\n\9},\13\n\9\13\n\9bufferWhitelist = {\13\n\9\9\13\n\9},\13\n}\13\n\13\nreturn info",["./texturePacks/example/"] = 0,["./texturePacks/"] = 0,["./logs/nosGa.log"] = "[INFO]  [GE]: Change state to: \"game\". \n[INFO]  [game]: Start init. \n[INFO]  [DL]: Loading data groups: gameObjects, globalStructured, animations, textures, parents. \n[INFO]  [DL]: Data group already loaded: globalStructured. \n[INFO]  [DL]: Loading data group: textures. \n[INFO]  [DL]: Loading data group: animations. \n[INFO]  [DL]: Loading data group: parents. \n[INFO]  [DL]: Loading data group: gameObjects. \n[INFO]  true \n",["./logs/"] = 0,["./nosGaConf.lua"] = "--Setting in here can be overwritten by the conf.lua settings.\13\n\13\nlocal nosGaConf = {\13\n\9--=== startup ===--\13\n\9defaultState = \"game\",\13\n\13\n\9--=== general ===--\13\n\9targetFramerate = -1, --default is \"20\". set to \"-1\" for unlimited framerate (can cause in graphical issures).\13\n\9maxTickTime = 1, --if a tick need more as the maxTickTime the engine will handle the tick like it had need exacly the maxTickTime.\13\n\9fpsCheckInterval = 30, --defines what amout of frames the engine use to calculate the avg. fps.\13\n\9\13\n\9queueSignals = false, --[[\13\n\9\9if true the enigne only processes one incomming signal per frame. this can cause delayed sinal processing.\13\n\9\9e.g. if you keep pressing a key for some time and then let it go, the release will get processed delayed.\13\n\9\9also the press of new keys or incomming network messages etc. gets delayed.\13\n\13\n\9\9if false the performance can go real bad at many incomming signals, like pressing a key for some time.\13\n\9\9it is recommended to use the keyboard library instead of unqueued signals to process payer inputs.\13\n\9]]\13\n\9\13\n\9preferModTextures = true, --if true mods can overwrite texturePack textures.\13\n\9\13\n\9\13\n\9--=== render engine ===--\13\n\9renderLayerAmount = 10,\13\n\9useDoubleBuffering = true, --[[ Use the third party doubleBuffering method by IgorTimofeev.\13\n\9\9In the most cases using it causes in a big graphic performance boost but on cost of the memory usage.\13\n\9\9More informations on github.\13\n\9]]\13\n\9transparencyColor = 0x00ffff, --this color will be made transparent. if false auto transparency is disabled. works only for .pic textures.\13\n\13\n\9useSmartMove = true,\13\n\9useSmartCameraMove = false, --recommended in any render mode.\13\n\9useSmartOverlap = true, --[[at overlapping it only renders pixels that are overlapping. \13\n\9\9this is not always usefull, only if there are a lot of overlaping sprites.\13\n\9\9may cause some graphical glitches sometimes. \13\n\9\9can always be deactivated.\13\n\9]]\13\n\9\13\n\9forceSmartMove = false, --forces the SmartMove in linear render mode (for render engine debugging purpose).\13\n\9\13\n\9useExperimentalRenderEngine = false, --a new render engine using the VRAM. not working properly yet.\13\n\9bufferTexturesOnInit = true, --If true the engine buffers all textures on init.\13\n\9useGlobalBackBuffer = false,\13\n\9\13\n\13\n\9--=== game object behavor ===--\13\n\9narrowUpdateExpansion = false, --{0, 0, 0, 0}, \13\n\9--[[ Defines the distance a gameObject can be away from any renderArea but will still updated.\13\n\9\9If it is set to false any gameObject will be updated independent from its position.\13\n\9\9Can be changed in source for any renderArea independently.\13\n\9\9\13\n\9\9{left, right, top, bottom}\13\n\9]]\13\n\13\n\9calcSUpdate = false, --defines if the sUpdate functionality is enabbled or not. causes performance hit.\13\n\13\n\13\n\9--=== debug ===--\9\13\n\9showConsole = false, --can be changes ingame by pressing f1 by default.\13\n\9showDebug = false, --can be changes ingame by pressing f3 by default.\13\n\9consoleSizeY = 5, --the height of the console.\13\n\9directConsoleDraw = false, --instant drawing console outputs instead of waiting til new frame (has only an affect if doubleBuffering used) (only if isDev).\13\n\13\n\9debug = { --these options are for developers.\13\n\9\9isDev = false, --activates debug outputs (strongly recommended if you want to mod the game in any way or something goes wrong and you need a detailed log).\13\n\9\9\13\n\9\9dlDebug = true, --print dataLoading debug (only if isDev).\13\n\9\9reDebug = false, --print renderEngine debug (only if isDev).\13\n\9\9raDebug = false, --print renderArea debug (only if isDev).\13\n\9\9uhDebug = false, --print updateHandler debug (only if isDev).\13\n\9\9goDebug = false, --print gameObject management debug (only if isDev).\13\n\9\9ehDebug = false, --print eventHandler debug (only if isDev).\13\n\9\9pcDebug = false, --print ParticleContainer debug (only if isDev).\13\n\9\9whDebug = false, --print worldHandler debug (only if isDev).\13\n\9\9\13\n\9\9drawCollider = false,\13\n\9\9drawTrigger = false,\13\n\9\9drawGameObjectBorders = false,\13\n\9\9\13\n\9\9onReload = { --defined what data/libs are reloaded at state reload. Press ctrl meanwhine to reload anything independent from this settings.\13\n\9\9\9conf = true, --should be always true.\13\n\9\9\9\13\n\9\9\9--=== core ===--\13\n\9\9\9dbgpu = false,\13\n\9\9\9re = false, \13\n\9\9\9uh = false,\13\n\9\9\9eh = true,\13\n\9\9\9GameObject = false,\13\n\9\9\9RenderArea = false,\13\n\9\9\9Sprite = false,\13\n\9\9\9uiHandler = false,\13\n\9\9\9\13\n\9\9\9--=== data groups ===--\13\n\9\9\9global = true, --global dir.\13\n\9\9\9structuredGlobal = false,\13\n\9\9\9states = false,\13\n\9\9\9textures = false,\13\n\9\9\9animations = false,\13\n\9\9\9parents = false,\13\n\9\9\9gameObjects = true,\13\n\9\9\9structuredGameObjects = false,\13\n\9\9\9\13\n\9\9\9mods = false, --just reloads the activated data groups of the mods (if only onReload.blocks = true he only also reloads the blocks from mods). should be always true.\13\n\9\9},\13\n\9\9\13\n\9\9debugKeys = {\13\n\9\9\9showConsole = 59, --default: 59 (f1)\13\n\9\9\9writeInConsole = 61, --default: 60 (f2)\13\n\9\9\9showDebug = 62, --default: 61 (f3)\13\n\9\9\9reloadState = 63, --reloadrs the current state and all data groups defined in the config. default: 63 (f5)\13\n\9\9\9rerenderScreen = 64, --rerenders the screen (removes graphic errors). default: 64 (f6)\13\n\9\9},\13\n\9},\13\n}\13\n\13\nreturn nosGaConf\13\n",["./libs/UT.lua"] = "--[[\13\n    UT Copyright (C) 2019-2020 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[UsefullThings libary\13\n\9\13\n]]\13\nlocal UT = {version = \"v0.8.6\"}\13\n\13\nfunction UT.getVersion()\13\n\9return UT.version\13\nend\13\n\13\nfunction UT.parseArgs(...) --returns the first non nil parameter.\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction UT.seperatePath(path) --seperates a data path [\"./DIR/FILE.ENDING\"] into the dir path [\"./DIR/\"], the file name [\"FILE\"], and the file ending [\".ENDING\" or nil]\13\n\9if string.sub(path, #path) == \"/\" then\13\n\9\9return path\13\n\9end\13\n\9\13\n\9local dir, fileName, fileEnd = \"\", \"\", nil\13\n\9local tmpLatest = \"\"\13\n\9for s in string.gmatch(tostring(path), \"[^/]+\") do\13\n\9\9tmpLatest = s\13\n\9end\13\n\9dir = string.sub(path, 0, #path -#tmpLatest)\13\n\9for s in string.gmatch(tostring(tmpLatest), \"[^.]+\") do\13\n\9\9fileName = fileName .. s\13\n\9\9tmpLatest = s\13\n\9end\13\n\9if fileName == tmpLatest then\13\n\9\9fileName = tmpLatest\13\n\9else\13\n\9\9fileEnd = \".\" .. tmpLatest\13\n\9\9fileName = string.sub(fileName, 0, #fileName - #fileEnd +1)\13\n\9end\13\n\9\13\n\9return dir, fileName, fileEnd\13\nend\13\n\13\nfunction UT.getChars(s) --returns a array with the chars of the string.\13\n\9local chars = {}\13\n\9for c = 1, #s do\13\n\9\9chars[c] = string.sub(s, c, c)\13\n\9end\13\n\9return chars\13\nend\13\n\13\nfunction UT.makeString(c) --genetares a string from and array of chars/strings.\13\n\9local s = \"\"\13\n\9for c, v in ipairs(c) do\13\n\9\9s = s ..v\13\n\9end\13\n\9return s\13\nend\13\n\13\nfunction UT.inputCheck(m, c) --checks if a array (m) contains a value (c).\13\n\9for _, v in pairs(m) do\13\n\9\9if v == c then\13\n\9\9\9return true\13\n\9\9end\13\n\9end\13\n\9return false\13\nend\13\n\13\nfunction UT.fillString(s, amout, c) --fills a string (s) up with a (amout) of chars/strings (c).\13\n\9local s2 = s\13\n\9for c2 = 1, amout, 1 do\13\n\9\9s2 = s2 .. c\13\n\9end\13\n\9return s2\13\nend\13\n\13\n--[[Converts a table or an other variable type to a readable stirng.\13\n\9This is a modified \"Universal tostring\" routine from \"lua-users.org\".\13\n\9Original source code: <http://lua-users.org/wiki/TableSerialization>\13\n]]\13\nfunction UT.tostring(var, lineBreak, indent, done, internalRun) \13\n\9if internalRun == false or internalRun == nil then\13\n\9\9if type(var) == \"table\" then\13\n\9\9\9UT.tostring(var, lineBreak, indent, done, true)\13\n\9\9else\13\n\9\9\9return tostring(var)\13\n\9\9end\13\n\9end\13\n\9\13\n\9done = done or {}\13\n\9indent = indent or 2\13\n\9local lbString\13\n\9if lineBreak or lineBreak == nil then\13\n\9\9lbString = \"\\n\"\13\n\9\9lineBreak = true\13\n\9else\13\n\9\9lbString = \" \"\13\n\9end\13\n\9if type(var) == \"table\" then\13\n\9\9local sb = {}\13\n\9\9if not internalRun then\13\n\9\9\9table.insert(sb, \"{\" .. lbString)\13\n\9\9end\13\n\9\9for key, value in pairs (var) do\13\n\9\9\9if lineBreak then\13\n\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9end\13\n\9\9\9if type (value) == \"table\" and not done [value] then\13\n\9\9\9\9done [value] = true\13\n\9\9\9\9if type(key) == \"string\" then\13\n\9\9\9\9\9key = \"'\" .. key .. \"'\"\13\n\9\9\9\9end\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, \"[\" .. tostring(key) .. \"] = {\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"[\" .. tostring(key) .. \"] = {\");\13\n\9\9\9\9end\13\n\9\9\9\9table.insert(sb, UT.tostring(value, lineBreak, indent + 2, done, true))\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(sb, string.rep (\" \", indent)) -- indent it\13\n\9\9\9\9\9table.insert(sb, \"},\" .. lbString);\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, \"},\");\13\n\9\9\9\9end\13\n\9\9\9elseif \"number\" == type(key) then\13\n\9\9\9\9table.insert(sb, string.format(\"[%s] = \", tostring(key)))\13\n\9\9\9\9if type(value) ~= \"boolean\" and type(value) ~= \"number\" then\13\n\9\9\9\9\9table.insert(sb, string.format(\"\\\"%s\\\",\" .. lbString, tostring(value)))\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, string.format(\"%s,\" .. lbString, tostring(value)))\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9\9table.insert(sb, \" \")\13\n\9\9\9\9end\13\n\9\9\9\9if type(key) == \"string\" then\13\n\9\9\9\9\9key = \"'\" .. key .. \"'\"\13\n\9\9\9\9end\13\n\9\9\9\9if type(value) ~= \"boolean\" and type(value) ~= \"number\" then\13\n\9\9\9\9\9table.insert(sb, string.format(\"%s = \\\"%s\\\",\" .. lbString, \"[\" .. tostring (key) .. \"]\", tostring(value)))\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(sb, string.format(\"%s = %s,\" .. lbString, \"[\" .. tostring (key) .. \"]\", tostring(value)))\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9\9if not internalRun then\13\n\9\9\9if sb[#sb] == \"},\" then\13\n\9\9\9\9table.insert(sb, \" }\")\13\n\9\9\9else\13\n\9\9\9\9table.insert(sb, \"}\")\13\n\9\9\9end\13\n\9\9end\13\n\9\9return table.concat(sb)\13\n\9else\13\n\9\9return var .. lbString\13\n\9end\13\nend\13\n\13\nfunction UT.readFile(path)\13\n\9local file, err = io.open(path, \"rb\")\13\n\9\13\n\9if file == nil then \13\n\9\9return nil, err \13\n\9else\13\n\9\9local fileContent = file:read(\"*all\")\13\n\9\9file:close()\13\n\9\9return fileContent\13\n\9end\13\nend\13\n\13\ndo --randomString: Source: https://gist.github.com/haggen/2fd643ea9a261fea2094\13\n\9local charset = {}  do -- [0-9a-zA-Z]\13\n\9\9for c = 48, 57  do table.insert(charset, string.char(c)) end\13\n\9\9for c = 65, 90  do table.insert(charset, string.char(c)) end\13\n\9\9for c = 97, 122 do table.insert(charset, string.char(c)) end\13\n\9end\13\n\9local function randomString(length)\13\n\9\9if not length or length <= 0 then return '' end\13\n\9\9math.randomseed(os.clock()^5)\13\n\9\9return randomString(length - 1) .. charset[math.random(1, #charset)]\13\n\9end\13\n\9UT.randomString = randomString\13\nend\13\n\13\nreturn UT",["./libs/dbgpu_api.lua"] = "--[[\13\n\9!The api is not complete yet!\13\n\9\13\n\9This is a little api to make the DoubleBuffering libarry by IgorTimofeev acting like a normal OC gpu.\13\n\9\13\n\9With the default settings it is acting (nearly) exacly like a normal OC gpu (so its basicly useless).\13\n\9To get the full effect of the DoubleBuffering you should deactivate directDraw but then you manually need to use the drawChanges function.\13\n\9\13\n\9DoubleBuffering source: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n\9DoubleBuffering Copyright (c) 2018 Igor Timofeev\13\n\9\13\n\9dbgpu_api Copyright (c) 2019 NosPo Studio\13\n\9\13\n    dbgpu_api is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    dbgpu_api is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with dbgpu_api.  If not, see <https://www.gnu.org/licenses/>.\9\13\n]]\13\n\13\nlocal version = \"v0.3.1\"\13\n\13\nlocal args = ...\13\nlocal path = args.path or \"\"\13\n\13\nlocal buffer = require(path .. \"/DoubleBuffering\")\13\nlocal gpu = require(\"component\").gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal ut = require(\"libs/UT\")\13\n\13\nlocal lastBackground = gpu.getBackground()\13\nlocal lastForeground = gpu.getForeground()\13\n\13\nlocal currentVBuffer = 0\13\nlocal cpuBuffers = {}\13\n\13\nif gpu.getActiveBuffer then\13\n\9currentVBuffer = gpu.getActiveBuffer()\13\nend\13\n\13\nlocal function flushBuffer(id, w, h)\13\n\9cpuBuffers[id] = {\13\n\9\9drawLimit = {1, 1, w, h},\13\n\9\9current = {{}, {}, {}, w, h},\13\n\9\9new = {{}, {}, {}, w, h},\13\n\9}\13\n\9\13\n\9for y = 1, h do\13\n\9\9for x = 1, w do\13\n\9\9\9table.insert(cpuBuffers[id].current[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].current[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].current[3], \" \")\13\n\9\13\n\9\9\9table.insert(cpuBuffers[id].new[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].new[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].new[3], \" \")\13\n\9\9end\13\n\9end\13\nend\13\nlocal function setBuffer(id)\13\n\9cpuBuffers[currentVBuffer].drawLimit = {buffer.getDrawLimit()}\13\n\9\13\n\9buffer.setCurrentFrameTables(cpuBuffers[id].current[1], cpuBuffers[id].current[2], cpuBuffers[id].current[3], cpuBuffers[id].current[4], cpuBuffers[id].current[5])\13\n\9buffer.setNewFrameTables(cpuBuffers[id].new[1], cpuBuffers[id].new[2], cpuBuffers[id].new[3], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9buffer.setDrawLimit(cpuBuffers[id].drawLimit[1], cpuBuffers[id].drawLimit[2], cpuBuffers[id].drawLimit[3], cpuBuffers[id].drawLimit[4])\13\n\9\13\n\9currentVBuffer = id\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function getSubFunc(s)\13\n\9if #s ~= unicode.len(s) then\13\n\9\9return unicode.sub\13\n\9else\13\n\9\9return string.sub\13\n\9end\13\nend\13\n\13\nlocal dbgpu = {\13\n\9directDraw = parseArgs(args.directDraw, true),\13\n\9forceDraw = parseArgs(args.forceDraw, false),\13\n\9rawCopy = parseArgs(args.rawCopy, false),\13\n\9actualRawCopy = parseArgs(args.actualRawCopy, args.rawCopy),\13\n\9version = version,\13\n\9buffer = buffer,\13\n}\13\n\13\nlocal function draw()\13\n\9if dbgpu.directDraw then\13\n\9\9buffer.drawChanges(dbgpu.forceDraw)\13\n\9end\13\nend\13\n\13\nfunction dbgpu.set(x, y, s, v)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9if v then\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x, y +i -1, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9else\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x +i -1, y, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9end\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.fill(x, y, sx, sy, s)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9sx = math.floor(sx)\13\n\9sy = math.floor(sy)\13\n\9s = sub(s, 0, 1)\13\n\9buffer.drawRectangle(x, y, sx, sy, lastBackground, lastForeground, s)\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.copy(x, y, sx, sy, tx, ty)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9tx = math.floor(tx)\13\n\9ty = math.floor(ty)\13\n\9\13\n\9if sx * sy > 3200 then\13\n\9\9buffer.directCopy(x, y, sx, sy, tx +x, ty +y, dbgpu.rawCopy)\13\n\9else\13\n\9\9local data, rawData = buffer.copy(x, y, sx, sy, dbgpu.rawCopy)\13\n\9\9buffer.paste(tx +x, ty +y, data, rawData)\13\n\9end\13\n\9\13\n\9if dbgpu.rawCopy and dbgpu.actualRawCopy then\9\9\13\n\9\9gpu.copy(x, y, sx, sy, tx, ty)\13\n\9end\9\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.getBackground()\13\n\9return lastBackground\13\nend\13\nfunction dbgpu.getForeground()\13\n\9return lastForeground\13\nend\13\n\13\nfunction dbgpu.setBackground(c)\13\n\9lastBackground = c\13\n\9--return gpu.setBackground(c)\13\nend\13\nfunction dbgpu.setForeground(c)\13\n\9lastForeground = c\13\n\9--return gpu.setForeground(c)\13\nend\13\n\13\nfunction dbgpu.setResolution(x, y)\13\n\9buffer.setResolution(x, y)\13\nend\13\nfunction dbgpu.getResolution()\13\n\9return buffer.getResolution()\13\nend\13\n\13\nfunction dbgpu.drawChanges(f)\13\n\9buffer.drawChanges(f)\13\nend\13\n\13\nfunction dbgpu.drawImage(x, y, image)\13\n\9buffer.drawImage(x, y, image)\13\nend\13\n\13\nfunction dbgpu.getActiveBuffer()\13\n\9return currentVBuffer\13\nend\13\nfunction dbgpu.setActiveBuffer(id, force)\13\n\9if id == currentVBuffer or force then\13\n\9\9return false, \"Buffer is set already\"\13\n\9else\13\n\9\9local suc = gpu.setActiveBuffer(id)\13\n\9\9\13\n\9\9if suc ~= nil then\13\n\9\9\9\13\n\9\9\9setBuffer(id)\13\n\9\9\9\13\n\9\9\9do\13\n\9\9\9\9local b = buffer.getNewFrameTables()\13\n\9\9\9\9local b2 = cpuBuffers[id].new[1]\13\n\9\9\9\9\13\n\9\9\9\9--print(b, b2, b == b2)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9--print(\"T\", id)\13\n\9\9\9--print(cpuBuffers[0], cpuBuffers[1])\13\n\9\9\9--print(#cpuBuffers[0].new[1], #cpuBuffers[1].new[1], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9\9end\13\n\9\9return id\13\n\9end\13\nend\13\n--debug/dbgpuVBufferTest.lua > logs/test.log\13\nfunction dbgpu.allocateBuffer(w, h)\13\n\9local id = gpu.allocateBuffer(w, h)\13\n\9if type(id) == \"number\" then\13\n\9\9flushBuffer(id, w, h)\13\n\9end\13\n\9return id\13\nend\13\nfunction dbgpu.freeBuffer(id)\13\n\9cpuBuffers[id] = nil\13\n\9return gpu.freeBuffer(id)\13\nend\13\nfunction dbgpu.bitblt(...)\13\n\9return gpu.bitblt(...)\13\nend\13\nfunction dbgpu.freeAllBuffers()\13\n\9currentVBuffer = 0\13\n\9return gpu.freeAllBuffers()\13\nend\13\n\13\n--===== init =====--\13\nlocal resX, resY = gpu.getResolution()\13\nflushBuffer(0, resX, resY)\13\nsetBuffer(0)\13\n\13\n--dbgpu = setmetatable(dbgpu, {__index = gpu})\13\n--maxResolution\13\n--maxResolution\13\n\13\nreturn dbgpu",["./libs/oclrl - Copy.lua"] = "--[[\13\n\9OCLRL (OpenComputersLinearRenderLibarry) is a small libarry for linear rendering of textures.\13\n\9\13\n    oclrl Copyright (C) 2019-2020 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[ToDo:\13\n\9\13\n\9Bugs:\13\n\9\9Animation clear not working.\13\n\13\n]]\13\nlocal oclrl = {version = \"v1.4.3d\"} --! Not compatible to <= v1.4.3 !\13\noclrl.__index = oclrl\13\n\13\n\13\n--===== local vars =====--\13\nlocal tmpTexture = {\13\n\9textureFormat = \"OCGLT\",\13\n\9version = \"v0.2\",\13\n\9drawCalls = {},\13\n}\13\nlocal computer = require(\"computer\")\13\n\13\n--===== local functions =====--\13\nlocal function addFrameTime(this, dt, backwards)\13\n\9this.lastFrame = this.currentFrame\13\n\9this.currentFrame = (this.currentFrame + (dt * this.speed))\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function parseLink(this, posX, posY, v, func, ...)\13\n\9if #v == 1 then\13\n\9\9tmpTexture.drawCalls = v[1]\13\n\9\9func(this, posX, posY, tmpTexture, ...)\13\n\9else\13\n\9\9tmpTexture.drawCalls = v[3]\13\n\9\9func(this, posX + v[1], posY + v[2], tmpTexture, ...)\13\n\9end\13\n\9tmpTexture.drawCalls = {}\13\nend\13\n\13\nlocal function calculateSetRideOut(s, pos, from, to)\13\n\9local tmpString = s\13\n\9local offset = 0\13\n\9\13\n\9if pos +#s > to then\13\n\9\9tmpString = string.sub(tmpString, 0, math.floor(-(pos +#s - to) +.5))\13\n\9end\13\n\9if pos < from then\13\n\9\9offset = -(pos - from)\13\n\9\9tmpString = string.sub(tmpString, math.floor(offset +1 +.5))\13\n\9end\13\n\9\13\n\9return tmpString, offset\13\nend\13\n\13\n--===== global functions =====--\13\nfunction oclrl.initiate(gpu, args)\13\n\9local this = setmetatable({}, oclrl)\13\n\9args = args or {}\13\n\9\13\n\9this.gpu = gpu\13\n\9this.resX, this.resY = gpu.getResolution()\13\n\9this.pFColor, this.pBColor = gpu.getForeground(), gpu.getBackground()\13\n\9this.checkColor = args.checkColor\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction oclrl.draw(this, posX, posY, texture, checkColor, area, clear)\13\n\9checkColor = checkColor or this.checkColor\13\n\9if checkColor == nil or checkColor == true then\13\n\9\9this.pFColor, this.pBColor = this.gpu.getForeground(), this.gpu.getBackground()\13\n\9end\13\n\9\13\n\9local fromX, toX, fromY, toY = 0, this.resX, 0, this.resY\13\n\9if area ~= nil then\13\n\9\9fromX, toX, fromY, toY = area[1], area[2], area[3], area[4]\13\n\9end\13\n\9\13\n\9local posX, posY = math.floor(posX +.5), math.floor(posY +.5)\13\n\9\13\n\9--cprint(texture.test)\13\n\9\13\n\9--[[\13\n\9if texture.test then\13\n\9\9cprint(posX, \"|\", posY, \"|\", fromX, \"|\", toX, \"|\", fromY, \"|\", toY)\13\n\9\9\13\n\9\9posX = math.floor(posX +.5)\13\n\9\9\13\n\9\9cprint(posX, \"|\", posY, \"|\", fromX, \"|\", toX, \"|\", fromY, \"|\", toY, \"TTT\")\13\n\9end\13\n\9]]\13\n\9\13\n\9for c, v in ipairs(texture.drawCalls or texture) do \13\n\9\9if #v == 1 or type(v[3]) == \"table\" then --link\13\n\9\9\9parseLink(this, posX, posY, v, oclrl.draw, false, area, clear)\13\n\9\9elseif #v == 3 or #v == 4 then --set\13\n\9\9\9if v[1] +posX <= toX and v[2] +posY <= toY then\13\n\9\9\9\9if v[4] and v[1] +posX >= fromX and v[2] +posY +#v[3] >= fromY then\13\n\9\9\9\9\9if area ~= nil then\13\n\9\9\9\9\9\9local tmpString, offset = calculateSetRideOut(v[3], posY +v[2], fromY, toY)\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX, v[2] +posY +offset, tmpString, v[4])\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX, v[2] +posY, v[3], v[4])\13\n\9\9\9\9\9end\13\n\9\9\9\9elseif not v[4] and v[2] +posY >= fromY and v[1] +posX +#v[3] >= fromX then\13\n\9\9\9\9\9if area ~= nil  then\13\n\9\9\9\9\9\9local tmpString, offset = calculateSetRideOut(v[3], posX +v[1], area[1], area[2])\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX +offset, v[2] +posY, tmpString, v[4])\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX, v[2] +posY, v[3], v[4])\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9elseif #v == 5 then --fill\13\n\9\9\9if v[1] +posX <= toX and v[2] +posY <= toY and v[1] +v[3] +posX > fromX and v[2] +v[4] +posY > fromY then\13\n\9\9\9\9if area ~= nil then\13\n\9\9\9\9\9local fx, fy, sx, sy = v[1] +posX, v[2] +posY, v[3], v[4]\13\n\9\9\9\9\9local minusRideOutX, minusRideOutY, rideOutX, rideOutY = 0, 0, 0, 0\13\n\9\9\9\9\9\13\n\9\9\9\9\9if fx < fromX then\13\n\9\9\9\9\9\9minusRideOutX = minusRideOutX - (fx - fromX)\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if fy < fromY then\13\n\9\9\9\9\9\9minusRideOutY = minusRideOutY- (fy - fromY)\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if fx + sx > toX then\13\n\9\9\9\9\9\9sx = sx + 1 - (fx + sx - (toX - minusRideOutX))\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9sx = sx - minusRideOutX\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if fy + sy > toY then\13\n\9\9\9\9\9\9sy = sy + 1 - (fy + sy - (toY - minusRideOutY))\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9sy = sy - minusRideOutY\13\n\9\9\9\9\9end\13\n\9\9\9\9\9\13\n\9\9\9\9\9fx = fx + minusRideOutX\13\n\9\9\9\9\9fy = fy + minusRideOutY\13\n\9\9\9\9\9this.gpu.fill(fx, fy, sx, sy, v[5])\13\n\9\9\9\9else\13\n\9\9\9\9\9this.gpu.fill(v[1] +posX, v[2] +posY, v[3], v[4], v[5])\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9elseif clear ~= true then --color change\13\n\9\9\9if v[1] == \"b\" and v[2] ~= this.pBColor then\13\n\9\9\9\9this.gpu.setBackground(v[2])\13\n\9\9\9\9this.pBColor = v[2]\13\n\9\9\9elseif v[1] == \"f\" and v[2] ~= this.pFColor then\13\n\9\9\9\9this.gpu.setForeground(v[2])\13\n\9\9\9\9this.pFColor = v[2]\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction oclrl.clearBlack(this, posX, posY, texture, color, area)\13\n\9this.gpu.setBackground(color or 0x000000)\13\n\9this.gpu.setForeground(color or 0x000000)\13\n\9\13\n\9this:draw(posX, posY, texture, false, area, true)\13\nend\13\n\13\nfunction oclrl.generateTexture(...)\13\n\9local texture = {\13\n\9\9textureFormat = \"OCGLT\", \13\n\9\9version = \"v0.1\", \13\n\9\9drawCalls = {}\13\n\9}\13\n\9local t = {}\13\n\9if type(...) ~= \"table\" then\13\n\9\9t = {{...}}\13\n\9else\13\n\9\9t = ...\13\n\9end\13\n\9\13\n\9for i, c in pairs(t) do\13\n\9\9table.insert(texture.drawCalls, c)\13\n\9end\13\n\9\13\n\9return texture\13\nend\13\n\13\nfunction oclrl.getColors(t, n)\13\n\9local fColor, bColor = nil, nil\13\n\9for c = n, 1, -1 do\13\n\9\9if t.drawCalls[c][1] == \"f\" and fColor == nil then\13\n\9\9\9fColor = t.drawCalls[c][2]\13\n\9\9end\13\n\9\9if t.drawCalls[c][1] == \"b\" and bColor == nil then\13\n\9\9\9bColor = t.drawCalls[c][2]\13\n\9\9end\13\n\9end\13\n\9return {\"f\", fColor or 0x000000}, {\"b\", bColor or 0x000000}\13\nend\13\n\13\nfunction oclrl.clear(this, posX, posY, texture, backgroundTextures, checkOverlap) --ToDo: add \"OCGLT_v0.2\" support.\13\n\9if backgroundTextures == nil then\13\n\9\9this.clearBlack(this, posX, posY, texture)\13\n\9\9return\13\n\9end\13\n\9if checkOverlap == nil then\13\n\9\9checkOverlap = true\13\n\9end\13\n\9\13\n\9--local write = function(...) io.write(tostring(...)) end --Debug\13\n\9--local serialization = require(\"serialization\") --Debug\13\n\9\13\n\9local toDraw = {drawCalls = {}}\13\n\9local toCheck = {}\13\n\9local isCheckt = {}\13\n\9local pFColor, pBColor = nil, nil\13\n\9local fColor, bColor = nil, nil\13\n\9\13\n\9for c = 1, #backgroundTextures do\13\n\9\9isCheckt[c] = {}\13\n\9end\13\n\9\13\n\9local function SetCall(btdc, bt, c, c2)\13\n\9\9if toDraw[c] == nil then\13\n\9\9\9toDraw[c] = {}\13\n\9\9\9\13\n\9\9\9for c2 = 1, #bt[3].drawCalls, 1 do\13\n\9\9\9\9toDraw[c][c2] = {}\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9if #btdc == 3 or #btdc == 4 then\13\n\9\9\9toDraw[c][c2] = {btdc[1] +bt[1], btdc[2] +bt[2], btdc[3], btdc[4]}\13\n\9\9elseif #btdc == 5 then\13\n\9\9\9toDraw[c][c2] = {btdc[1] +bt[1], btdc[2] +bt[2], btdc[3], btdc[4], btdc[5]}\13\n\9\9end\13\n\9\9\13\n\9\9if checkOverlap then\13\n\9\9\9table.insert(toCheck, {btdc, bt[1], bt[2]})\13\n\9\9end\13\n\9\9\13\n\9\9isCheckt[c][c2] = true\13\n\9end\13\n\9\13\n\9if checkOverlap then\13\n\9\9local old = SetCall\13\n\9\9SetCall = function(btdc, bt, c, c2)\13\n\9\9\9old(btdc, bt, c, c2)\13\n\9\9\9toDraw[c][c2].bc = fColor\13\n\9\9\9toDraw[c][c2].fc = bColor\13\n\9\9end\13\n\9else\13\n\9\9local old = SetCall\13\n\9\9SetCall = function(btdc, bt, c, c2)\13\n\9\9\9old(btdc, bt, c, c2)\13\n\9\9\9if fColor ~= pFColor then\13\n\9\9\9\9toDraw[c][c2].bc = fColor\13\n\9\9\9\9pFColor = fColor\13\n\9\9\9end\13\n\9\9\9if bColor ~= pBColor then\13\n\9\9\9\9toDraw[c][c2].fc = bColor\13\n\9\9\9\9pBColor = bColor\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9local function CheckOverlab(dc, backgroundTextures, posX, posY)\13\n\9\9for c, bt in ipairs(backgroundTextures) do\13\n\9\9\9for c2, btdc in ipairs(bt[3].drawCalls or bt[3]) do\13\n\9\9\9\9if isCheckt[c][c2] ~= true then\13\n\9\9\9\9\9if #btdc == 3 or #btdc == 4 then\13\n\9\9\9\9\9\9if #dc == 3 or #dc == 4 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +#btdc[3] and dc[1] +posX +#dc[3] > btdc[1] +bt[1] and dc[2] +posY == btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9elseif #dc == 5 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +#btdc[3] and dc[1] +posX +dc[3] > btdc[1] +bt[1] and dc[2] +posY <= btdc[2] +bt[2] and dc[2] +posY +dc[4] > btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\9\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif #btdc == 5 then\13\n\9\9\9\9\9\9if #dc == 3 or #dc == 4 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +btdc[3] and dc[1] +posX +#dc[3] > btdc[1] +bt[1] and dc[2] +posY < btdc[2] +bt[2] +btdc[4] and dc[2] +posY > btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9elseif #dc == 5 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +btdc[3] and dc[1] +posX +dc[3] > btdc[1] +bt[1] and dc[2] +posY < btdc[2] +bt[2] +btdc[4] and dc[2] +posY +dc[4] > btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9if btdc[1] == \"f\" then\13\n\9\9\9\9\9\9\9fColor = btdc\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9if btdc[1] == \"b\" then\13\n\9\9\9\9\9\9\9bColor = btdc\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9for c, dc in ipairs(texture.drawCalls) do\13\n\9\9CheckOverlab(dc, backgroundTextures, posX, posY)\13\n\9end\13\n\9\13\n\9if checkOverlap then\13\n\9\9for c, tc in ipairs(toCheck) do\13\n\9\9\9CheckOverlab(tc[1], backgroundTextures, tc[2], tc[3])\13\n\9\9end\13\n\9end\13\n\9\13\n\9local graphic = {drawCalls = {}}\13\n\9for c, v in pairs(toDraw) do\13\n\9\9for c, v2 in pairs(v) do\13\n\9\9\9if #v2 ~= 0 then\13\n\9\9\9\9table.insert(graphic.drawCalls, v2.fc)\13\n\9\9\9\9table.insert(graphic.drawCalls, v2.bc)\13\n\9\9\9\9table.insert(graphic.drawCalls, v2)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9this:draw(0, 0, graphic)\13\n\9this.gpu.setForeground(0xffffff)\13\n\9--write(#graphic.drawCalls .. \" \")\13\n\9\13\nend\13\n\13\nfunction oclrl.convertToPixels(this, g, s) --WIP\13\n\9local newG = {}\13\n\9local oNewG = {}\13\n\9s = s or 1\13\n\9\13\n\9for c, v in ipairs(g.drawCalls) do\13\n\9\9if #v == 3 or #v == 4 then\13\n\9\9\9for c = 1, #v[3], s do\13\n\9\9\9\9newG[#newG +1] = {v[1] +c, v[2], string.sub(v[3], c, c +s -1), v[4]}\13\n\9\9\9end\13\n\9\9elseif #v == 5 then\13\n\9\9\9local fillString = \"\"\13\n\9\9\9for c = 1, s, 1 do\13\n\9\9\9\9fillString = fillString .. v[5]\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9for c = 1, v[4], 1 do\13\n\9\9\9\9for c2 = 1, v[3], s do\13\n\9\9\9\9\9local tm = c2 +#fillString - v[3]\13\n\9\9\9\9\9if tm < 0 then\13\n\9\9\9\9\9\9tm = 0\13\n\9\9\9\9\9end\13\n\9\9\9\9\9newG[#newG +1] = {v[1] +c2, v[2] +c -1, string.sub(fillString, tm)}\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9newG[#newG +1] = v\13\n\9\9end\13\n\9end\13\n\9\13\n\9local count = 0\13\n\9for c, v in ipairs(newG) do\13\n\9\9count = count +1\13\n\9\9if count > 1000 then\13\n\9\9\9os.sleep()\13\n\9\9\9count = 0\13\n\9\9end\13\n\9\9\13\n\9\9if #v ~= 2 then\13\n\9\9\9local set = true\13\n\9\9\9\13\n\9\9\9for c2 = c +1, #newG, 1 do\13\n\9\9\9\9if #newG[c2] ~= 2 and v[2] == newG[c2][2] then\13\n\9\9\9\9\9if v[1] == newG[c2][1] or v[1] > newG[c2][1] and v[1] +#v[3] < newG[c2][1] +#newG[c2][3] then\13\n\9\9\9\9\9\9set = false\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9if set then\13\n\9\9\9\9oNewG[#oNewG +1] = v\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9oNewG[#oNewG +1] = v\13\n\9\9end\13\n\9end \13\n\9\13\n\9return {textureFormat = \"OCGLT\", version = \"v0.1\", drawCalls = oNewG}\13\nend \13\n\13\nfunction oclrl.convertToRaster(this, g, s) --WIP\13\n\9local newG = {}\13\n\9s = s or 1\13\n\9\13\n\9for c, v in ipairs(g.drawCalls) do\13\n\9\9if #v == 3 or #v == 4 then\13\n\9\9\9\13\n\9\9\9\13\n\9\9\9\13\n\9\9elseif #v == 5 then\13\n\9\9\9\13\n\9\9else\13\n\9\9\9\13\n\9\9end\13\n\9end\13\n\9\13\n\9return {textureFormat = \"OCGLTT\", version = \"v0.1\", drawCalls = newG}\13\nend\13\n\13\nreturn oclrl\13\n\13\n\13\n",["./libs/oclrl.lua"] = "--[[\13\n\9OCLRL (OpenComputersLinearRenderLibarry) is a small libarry for linear rendering of textures.\13\n\9\13\n    oclrl Copyright (C) 2019-2020 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[ToDo:\13\n\9\13\n\9Bugs:\13\n\9\9Animation clear not working.\13\n\13\n]]\13\nlocal oclrl = {version = \"v2.0\"}\13\noclrl.__index = oclrl\13\n\13\n\13\n--===== local vars =====--\13\nlocal tmpTexture = {\13\n\9textureFormat = \"OCGLT\",\13\n\9version = \"v0.2\",\13\n\9drawCalls = {},\13\n}\13\nlocal computer = require(\"computer\")\13\n\13\n--===== local functions =====--\13\nlocal function addFrameTime(this, dt, backwards)\13\n\9this.lastFrame = this.currentFrame\13\n\9this.currentFrame = (this.currentFrame + (dt * this.speed))\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function parseLink(this, posX, posY, v, func, ...)\13\n\9if #v == 1 then\13\n\9\9tmpTexture.drawCalls = v[1]\13\n\9\9func(this, posX, posY, tmpTexture, ...)\13\n\9else\13\n\9\9tmpTexture.drawCalls = v[3]\13\n\9\9func(this, posX + v[1], posY + v[2], tmpTexture, ...)\13\n\9end\13\n\9tmpTexture.drawCalls = {}\13\nend\13\n\13\nlocal function calculateSetRideOut(s, pos, from, to)\13\n\9local tmpString = s\13\n\9local offset = 0\13\n\9\13\n\9if pos +#s > to then\13\n\9\9tmpString = string.sub(tmpString, 0, math.floor(-(pos +#s - to) +.5))\13\n\9end\13\n\9if pos < from then\13\n\9\9offset = -(pos - from)\13\n\9\9tmpString = string.sub(tmpString, math.floor(offset +1 +.5))\13\n\9end\13\n\9\13\n\9return tmpString, offset\13\nend\13\n\13\n--===== global functions =====--\13\nfunction oclrl.initiate(gpu, args)\13\n\9local this = setmetatable({}, oclrl)\13\n\9args = args or {}\13\n\9\13\n\9this.gpu = gpu\13\n\9this.resX, this.resY = gpu.getResolution()\13\n\9this.pFColor, this.pBColor = gpu.getForeground(), gpu.getBackground()\13\n\9this.checkColor = args.checkColor\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction oclrl.draw(this, posX, posY, texture, checkColor, area, clear)\13\n\9checkColor = checkColor or this.checkColor\13\n\9if checkColor == nil or checkColor == true then\13\n\9\9this.pFColor, this.pBColor = this.gpu.getForeground(), this.gpu.getBackground()\13\n\9end\13\n\9\13\n\9local fromX, toX, fromY, toY = 0, this.resX, 0, this.resY\13\n\9if area ~= nil then\13\n\9\9fromX, toX, fromY, toY = area[1], area[2], area[3], area[4]\13\n\9end\13\n\9\13\n\9local posX, posY = math.floor(posX +.5), math.floor(posY +.5)\13\n\9\13\n\9\13\n\9\13\n\9for c, v in ipairs(texture.drawCalls or texture) do \13\n\9\9if #v == 1 or type(v[3]) == \"table\" then --link\13\n\9\9\9parseLink(this, posX, posY, v, oclrl.draw, false, area, clear)\13\n\9\9elseif #v == 3 or #v == 4 then --set\13\n\9\9\9if v[1] +posX <= toX and v[2] +posY <= toY then\13\n\9\9\9\9if v[4] and v[1] +posX >= fromX and v[2] +posY +#v[3] >= fromY then\13\n\9\9\9\9\9if area ~= nil then\13\n\9\9\9\9\9\9local tmpString, offset = calculateSetRideOut(v[3], posY +v[2], fromY, toY)\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX, v[2] +posY +offset, tmpString, v[4])\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX, v[2] +posY, v[3], v[4])\13\n\9\9\9\9\9end\13\n\9\9\9\9elseif not v[4] and v[2] +posY >= fromY and v[1] +posX +#v[3] >= fromX then\13\n\9\9\9\9\9if area ~= nil  then\13\n\9\9\9\9\9\9local tmpString, offset = calculateSetRideOut(v[3], posX +v[1], area[1], area[2])\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX +offset, v[2] +posY, tmpString, v[4])\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9this.gpu.set(v[1] +posX, v[2] +posY, v[3], v[4])\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9elseif #v == 5 then --fill\13\n\9\9\9if v[1] +posX <= toX and v[2] +posY <= toY and v[1] +v[3] +posX > fromX and v[2] +v[4] +posY > fromY then\13\n\9\9\9\9if area ~= nil then\13\n\9\9\9\9\9local fx, fy, sx, sy = v[1] +posX, v[2] +posY, v[3], v[4]\13\n\9\9\9\9\9local minusRideOutX, minusRideOutY, rideOutX, rideOutY = 0, 0, 0, 0\13\n\9\9\9\9\9\13\n\9\9\9\9\9if fx < fromX then\13\n\9\9\9\9\9\9minusRideOutX = minusRideOutX - (fx - fromX)\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if fy < fromY then\13\n\9\9\9\9\9\9minusRideOutY = minusRideOutY- (fy - fromY)\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if fx + sx > toX then\13\n\9\9\9\9\9\9sx = sx + 1 - (fx + sx - (toX - minusRideOutX))\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9sx = sx - minusRideOutX\13\n\9\9\9\9\9end\13\n\9\9\9\9\9if fy + sy > toY then\13\n\9\9\9\9\9\9sy = sy + 1 - (fy + sy - (toY - minusRideOutY))\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9sy = sy - minusRideOutY\13\n\9\9\9\9\9end\13\n\9\9\9\9\9\13\n\9\9\9\9\9fx = fx + minusRideOutX\13\n\9\9\9\9\9fy = fy + minusRideOutY\13\n\9\9\9\9\9this.gpu.fill(fx, fy, sx, sy, v[5])\13\n\9\9\9\9else\13\n\9\9\9\9\9this.gpu.fill(v[1] +posX, v[2] +posY, v[3], v[4], v[5])\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9elseif clear ~= true then --color change\13\n\9\9\9if v[1] == \"b\" and v[2] ~= this.pBColor then\13\n\9\9\9\9this.gpu.setBackground(v[2])\13\n\9\9\9\9this.pBColor = v[2]\13\n\9\9\9elseif v[1] == \"f\" and v[2] ~= this.pFColor then\13\n\9\9\9\9this.gpu.setForeground(v[2])\13\n\9\9\9\9this.pFColor = v[2]\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction oclrl.clearBlack(this, posX, posY, texture, color, area)\13\n\9this.gpu.setBackground(color or 0x000000)\13\n\9this.gpu.setForeground(color or 0x000000)\13\n\9\13\n\9this:draw(posX, posY, texture, false, area, true)\13\nend\13\n\13\nfunction oclrl.generateTexture(...)\13\n\9local texture = {\13\n\9\9textureFormat = \"OCGLT\", \13\n\9\9version = \"v0.1\", \13\n\9\9drawCalls = {}\13\n\9}\13\n\9local t = {}\13\n\9if type(...) ~= \"table\" then\13\n\9\9t = {{...}}\13\n\9else\13\n\9\9t = ...\13\n\9end\13\n\9\13\n\9for i, c in pairs(t) do\13\n\9\9table.insert(texture.drawCalls, c)\13\n\9end\13\n\9\13\n\9return texture\13\nend\13\n\13\nfunction oclrl.getColors(t, n)\13\n\9local fColor, bColor = nil, nil\13\n\9for c = n, 1, -1 do\13\n\9\9if t.drawCalls[c][1] == \"f\" and fColor == nil then\13\n\9\9\9fColor = t.drawCalls[c][2]\13\n\9\9end\13\n\9\9if t.drawCalls[c][1] == \"b\" and bColor == nil then\13\n\9\9\9bColor = t.drawCalls[c][2]\13\n\9\9end\13\n\9end\13\n\9return {\"f\", fColor or 0x000000}, {\"b\", bColor or 0x000000}\13\nend\13\n\13\nfunction oclrl.clear(this, posX, posY, texture, backgroundTextures, checkOverlap) --ToDo: add \"OCGLT_v0.2\" support.\13\n\9if backgroundTextures == nil then\13\n\9\9this.clearBlack(this, posX, posY, texture)\13\n\9\9return\13\n\9end\13\n\9if checkOverlap == nil then\13\n\9\9checkOverlap = true\13\n\9end\13\n\9\13\n\9--local write = function(...) io.write(tostring(...)) end --Debug\13\n\9--local serialization = require(\"serialization\") --Debug\13\n\9\13\n\9local toDraw = {drawCalls = {}}\13\n\9local toCheck = {}\13\n\9local isCheckt = {}\13\n\9local pFColor, pBColor = nil, nil\13\n\9local fColor, bColor = nil, nil\13\n\9\13\n\9for c = 1, #backgroundTextures do\13\n\9\9isCheckt[c] = {}\13\n\9end\13\n\9\13\n\9local function SetCall(btdc, bt, c, c2)\13\n\9\9if toDraw[c] == nil then\13\n\9\9\9toDraw[c] = {}\13\n\9\9\9\13\n\9\9\9for c2 = 1, #bt[3].drawCalls, 1 do\13\n\9\9\9\9toDraw[c][c2] = {}\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9if #btdc == 3 or #btdc == 4 then\13\n\9\9\9toDraw[c][c2] = {btdc[1] +bt[1], btdc[2] +bt[2], btdc[3], btdc[4]}\13\n\9\9elseif #btdc == 5 then\13\n\9\9\9toDraw[c][c2] = {btdc[1] +bt[1], btdc[2] +bt[2], btdc[3], btdc[4], btdc[5]}\13\n\9\9end\13\n\9\9\13\n\9\9if checkOverlap then\13\n\9\9\9table.insert(toCheck, {btdc, bt[1], bt[2]})\13\n\9\9end\13\n\9\9\13\n\9\9isCheckt[c][c2] = true\13\n\9end\13\n\9\13\n\9if checkOverlap then\13\n\9\9local old = SetCall\13\n\9\9SetCall = function(btdc, bt, c, c2)\13\n\9\9\9old(btdc, bt, c, c2)\13\n\9\9\9toDraw[c][c2].bc = fColor\13\n\9\9\9toDraw[c][c2].fc = bColor\13\n\9\9end\13\n\9else\13\n\9\9local old = SetCall\13\n\9\9SetCall = function(btdc, bt, c, c2)\13\n\9\9\9old(btdc, bt, c, c2)\13\n\9\9\9if fColor ~= pFColor then\13\n\9\9\9\9toDraw[c][c2].bc = fColor\13\n\9\9\9\9pFColor = fColor\13\n\9\9\9end\13\n\9\9\9if bColor ~= pBColor then\13\n\9\9\9\9toDraw[c][c2].fc = bColor\13\n\9\9\9\9pBColor = bColor\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9local function CheckOverlab(dc, backgroundTextures, posX, posY)\13\n\9\9for c, bt in ipairs(backgroundTextures) do\13\n\9\9\9for c2, btdc in ipairs(bt[3].drawCalls or bt[3]) do\13\n\9\9\9\9if isCheckt[c][c2] ~= true then\13\n\9\9\9\9\9if #btdc == 3 or #btdc == 4 then\13\n\9\9\9\9\9\9if #dc == 3 or #dc == 4 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +#btdc[3] and dc[1] +posX +#dc[3] > btdc[1] +bt[1] and dc[2] +posY == btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9elseif #dc == 5 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +#btdc[3] and dc[1] +posX +dc[3] > btdc[1] +bt[1] and dc[2] +posY <= btdc[2] +bt[2] and dc[2] +posY +dc[4] > btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\9\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif #btdc == 5 then\13\n\9\9\9\9\9\9if #dc == 3 or #dc == 4 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +btdc[3] and dc[1] +posX +#dc[3] > btdc[1] +bt[1] and dc[2] +posY < btdc[2] +bt[2] +btdc[4] and dc[2] +posY > btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9elseif #dc == 5 then\13\n\9\9\9\9\9\9\9if dc[1] +posX < btdc[1] +bt[1] +btdc[3] and dc[1] +posX +dc[3] > btdc[1] +bt[1] and dc[2] +posY < btdc[2] +bt[2] +btdc[4] and dc[2] +posY +dc[4] > btdc[2] +bt[2] then\13\n\9\9\9\9\9\9\9\9SetCall(btdc, bt, c, c2)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9if btdc[1] == \"f\" then\13\n\9\9\9\9\9\9\9fColor = btdc\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9if btdc[1] == \"b\" then\13\n\9\9\9\9\9\9\9bColor = btdc\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9for c, dc in ipairs(texture.drawCalls) do\13\n\9\9CheckOverlab(dc, backgroundTextures, posX, posY)\13\n\9end\13\n\9\13\n\9if checkOverlap then\13\n\9\9for c, tc in ipairs(toCheck) do\13\n\9\9\9CheckOverlab(tc[1], backgroundTextures, tc[2], tc[3])\13\n\9\9end\13\n\9end\13\n\9\13\n\9local graphic = {drawCalls = {}}\13\n\9for c, v in pairs(toDraw) do\13\n\9\9for c, v2 in pairs(v) do\13\n\9\9\9if #v2 ~= 0 then\13\n\9\9\9\9table.insert(graphic.drawCalls, v2.fc)\13\n\9\9\9\9table.insert(graphic.drawCalls, v2.bc)\13\n\9\9\9\9table.insert(graphic.drawCalls, v2)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9this:draw(0, 0, graphic)\13\n\9this.gpu.setForeground(0xffffff)\13\n\9--write(#graphic.drawCalls .. \" \")\13\n\9\13\nend\13\n\13\nfunction oclrl.convertToPixels(this, g, s) --WIP\13\n\9local newG = {}\13\n\9local oNewG = {}\13\n\9s = s or 1\13\n\9\13\n\9for c, v in ipairs(g.drawCalls) do\13\n\9\9if #v == 3 or #v == 4 then\13\n\9\9\9for c = 1, #v[3], s do\13\n\9\9\9\9newG[#newG +1] = {v[1] +c, v[2], string.sub(v[3], c, c +s -1), v[4]}\13\n\9\9\9end\13\n\9\9elseif #v == 5 then\13\n\9\9\9local fillString = \"\"\13\n\9\9\9for c = 1, s, 1 do\13\n\9\9\9\9fillString = fillString .. v[5]\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9for c = 1, v[4], 1 do\13\n\9\9\9\9for c2 = 1, v[3], s do\13\n\9\9\9\9\9local tm = c2 +#fillString - v[3]\13\n\9\9\9\9\9if tm < 0 then\13\n\9\9\9\9\9\9tm = 0\13\n\9\9\9\9\9end\13\n\9\9\9\9\9newG[#newG +1] = {v[1] +c2, v[2] +c -1, string.sub(fillString, tm)}\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9newG[#newG +1] = v\13\n\9\9end\13\n\9end\13\n\9\13\n\9local count = 0\13\n\9for c, v in ipairs(newG) do\13\n\9\9count = count +1\13\n\9\9if count > 1000 then\13\n\9\9\9os.sleep()\13\n\9\9\9count = 0\13\n\9\9end\13\n\9\9\13\n\9\9if #v ~= 2 then\13\n\9\9\9local set = true\13\n\9\9\9\13\n\9\9\9for c2 = c +1, #newG, 1 do\13\n\9\9\9\9if #newG[c2] ~= 2 and v[2] == newG[c2][2] then\13\n\9\9\9\9\9if v[1] == newG[c2][1] or v[1] > newG[c2][1] and v[1] +#v[3] < newG[c2][1] +#newG[c2][3] then\13\n\9\9\9\9\9\9set = false\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9if set then\13\n\9\9\9\9oNewG[#oNewG +1] = v\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9oNewG[#oNewG +1] = v\13\n\9\9end\13\n\9end \13\n\9\13\n\9return {textureFormat = \"OCGLT\", version = \"v0.1\", drawCalls = oNewG}\13\nend \13\n\13\nfunction oclrl.convertToRaster(this, g, s) --WIP\13\n\9local newG = {}\13\n\9s = s or 1\13\n\9\13\n\9for c, v in ipairs(g.drawCalls) do\13\n\9\9if #v == 3 or #v == 4 then\13\n\9\9\9\13\n\9\9\9\13\n\9\9\9\13\n\9\9elseif #v == 5 then\13\n\9\9\9\13\n\9\9else\13\n\9\9\9\13\n\9\9end\13\n\9end\13\n\9\13\n\9return {textureFormat = \"OCGLTT\", version = \"v0.1\", drawCalls = newG}\13\nend\13\n\13\nreturn oclrl\13\n\13\n\13\n",["./libs/tl.lua"] = "local t = {t = 1}\13\n\13\nprint(\"t\")\13\n\13\nreturn t",["./libs/dbgpu_api.lua.debug"] = "--[[\13\n\9!The api is not complete yet!\13\n\9\13\n\9This is a little api to make the DoubleBuffering libarry by IgorTimofeev acting like a normal OC gpu.\13\n\9\13\n\9With the default settings it is acting (nearly) exacly like a normal OC gpu (so its basicly useless).\13\n\9To get the full effect of the DoubleBuffering you should deactivate directDraw but then you manually need to use the drawChanges function.\13\n\9\13\n\9DoubleBuffering source: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n\9DoubleBuffering Copyright (c) 2018 Igor Timofeev\13\n\9\13\n\9dbgpu_api Copyright (c) 2019 NosPo Studio\13\n\9\13\n    dbgpu_api is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    dbgpu_api is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with dbgpu_api.  If not, see <https://www.gnu.org/licenses/>.\9\13\n]]\13\n\13\nlocal version = \"v0.2d\"\13\n\13\nlocal args = ...\13\nlocal path = args.path or \"\"\13\n\13\nlocal buffer = require(path .. \"/DoubleBuffering\")\13\nlocal gpu = require(\"component\").gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal ut = require(\"libs/UT\")\13\n\13\nlocal lastBackground = gpu.getBackground()\13\nlocal lastForeground = gpu.getForeground()\13\n\13\nlocal currentVBuffer = gpu.getActiveBuffer()\13\nlocal cpuBuffers = {}\13\n\13\nlocal function flushBuffer(id, w, h)\13\n\9cpuBuffers[id] = {\13\n\9\9drawLimit = {1, 1, w, h},\13\n\9\9current = {{}, {}, {}, w, h},\13\n\9\9new = {{}, {}, {}, w, h},\13\n\9}\13\n\9\13\n\9for y = 1, h do\13\n\9\9for x = 1, w do\13\n\9\9\9table.insert(cpuBuffers[id].current[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].current[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].current[3], \" \")\13\n\9\13\n\9\9\9table.insert(cpuBuffers[id].new[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].new[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].new[3], \" \")\13\n\9\9end\13\n\9end\13\nend\13\nlocal function setBuffer(id)\13\n\9cpuBuffers[currentVBuffer].drawLimit = {buffer.getDrawLimit()}\13\n\9\13\n\9buffer.setCurrentFrameTables(cpuBuffers[id].current[1], cpuBuffers[id].current[2], cpuBuffers[id].current[3], cpuBuffers[id].current[4], cpuBuffers[id].current[5])\13\n\9buffer.setNewFrameTables(cpuBuffers[id].new[1], cpuBuffers[id].new[2], cpuBuffers[id].new[3], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9buffer.setDrawLimit(cpuBuffers[id].drawLimit[1], cpuBuffers[id].drawLimit[2], cpuBuffers[id].drawLimit[3], cpuBuffers[id].drawLimit[4])\13\n\9\13\n\9currentVBuffer = id\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function getSubFunc(s)\13\n\9if #s ~= unicode.len(s) then\13\n\9\9return unicode.sub\13\n\9else\13\n\9\9return string.sub\13\n\9end\13\nend\13\n\13\nlocal dbgpu = {\13\n\9directDraw = parseArgs(args.directDraw, true),\13\n\9forceDraw = parseArgs(args.forceDraw, false),\13\n\9rawCopy = parseArgs(args.rawCopy, false),\13\n\9actualRawCopy = parseArgs(args.actualRawCopy, args.rawCopy),\13\n\9version = version,\13\n\9buffer = buffer,\13\n}\13\n\13\nlocal function draw()\13\n\9if dbgpu.directDraw then\13\n\9\9buffer.drawChanges(dbgpu.forceDraw)\13\n\9end\13\nend\13\n\13\nfunction dbgpu.set(x, y, s, v)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9if v then\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x, y +i -1, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9else\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x +i -1, y, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9end\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.fill(x, y, sx, sy, s)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9sx = math.floor(sx)\13\n\9sy = math.floor(sy)\13\n\9s = sub(s, 0, 1)\13\n\9buffer.drawRectangle(x, y, sx, sy, lastBackground, lastForeground, s)\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.copy(x, y, sx, sy, tx, ty)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9tx = math.floor(tx)\13\n\9ty = math.floor(ty)\13\n\9\13\n\9if sx * sy > 3200 then\13\n\9\9buffer.directCopy(x, y, sx, sy, tx +x, ty +y, dbgpu.rawCopy)\13\n\9else\13\n\9\9local data, rawData = buffer.copy(x, y, sx, sy, dbgpu.rawCopy)\13\n\9\9buffer.paste(tx +x, ty +y, data, rawData)\13\n\9end\13\n\9\13\n\9if dbgpu.rawCopy and dbgpu.actualRawCopy then\9\9\13\n\9\9gpu.copy(x, y, sx, sy, tx, ty)\13\n\9end\9\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.getBackground()\13\n\9return lastBackground\13\nend\13\nfunction dbgpu.getForeground()\13\n\9return lastForeground\13\nend\13\n\13\nfunction dbgpu.setBackground(c)\13\n\9lastBackground = c\13\n\9--return gpu.setBackground(c)\13\nend\13\nfunction dbgpu.setForeground(c)\13\n\9lastForeground = c\13\n\9--return gpu.setForeground(c)\13\nend\13\n\13\nfunction dbgpu.setResolution(x, y)\13\n\9buffer.setResolution(x, y)\13\nend\13\nfunction dbgpu.getResolution()\13\n\9return buffer.getResolution()\13\nend\13\n\13\nfunction dbgpu.drawChanges(f)\13\n\9buffer.drawChanges(f)\13\nend\13\n\13\nfunction dbgpu.drawImage(x, y, image)\13\n\9cprint(\"Draw Image\")\13\n\9buffer.drawImage(x, y, image)\13\nend\13\n\13\ndbgpu.getActiveBuffer = gpu.getActiveBuffer\13\ndbgpu.setActiveBuffer = gpu.setActiveBuffer\13\ndbgpu.allocateBuffer = gpu.allocateBuffer\13\ndbgpu.freeBuffer = gpu.freeBuffer\13\ndbgpu.bitblt = gpu.bitblt\13\ndbgpu.freeAllBuffers = gpu.freeAllBuffers\13\n\13\n--debug/dbgpuVBufferTest.lua > logs/test.log\13\n\13\n--===== init =====--\13\nlocal resX, resY = gpu.getResolution()\13\nflushBuffer(0, resX, resY)\13\nsetBuffer(0)\13\n\13\ngpu.drawChanges = function() end\13\n\13\nreturn dbgpu",["./libs/thirdParty/DoubleBuffering - Copy (2).lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are made some changes to provide the best possible performance in combination with the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (NosPo version) Copyright (c) 2019-2020 NosPo Studio\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\nlocal version = \"v0.6d\" --NosPo version.\13\n\13\nlocal component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\nlocal color = require(\"libs/thirdParty/color\")\13\nlocal image = require(\"libs/thirdParty/image\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal bufferWidth, bufferHeight\13\nlocal currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nlocal drawLimitX1, drawLimitX2, drawLimitY1, drawLimitY2\13\nlocal GPUProxy, GPUProxyGetResolution, GPUProxySetResolution, GPUProxyBind, GPUProxyGetBackground, GPUProxyGetForeground, GPUProxySetBackground, GPUProxySetForeground, GPUProxyGet, GPUProxySet, GPUProxyFill\13\n\13\nlocal mathCeil, mathFloor, mathModf, mathAbs = math.ceil, math.floor, math.modf, math.abs\13\nlocal tableInsert, tableConcat = table.insert, table.concat\13\nlocal colorBlend = color.blend\13\nlocal unicodeLen, unicodeSub = unicode.len, unicode.sub\13\n\13\nlocal drawAreas, nonDrawAreas = {}, {} --drawAreas == pixelWhiteList, nonDrawAreas == pixelBlackList\13\nlocal drawAreasAreWhitelist = true\13\nlocal drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nlocal bufferOnly = false\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getIndex(x, y)\13\n\9return bufferWidth * (y - 1) + x\13\nend\13\nlocal function getCoordinates(index)\13\n\9return index % bufferWidth, math.floor(index / bufferWidth) +1\13\nend\13\n\13\nlocal function getCurrentFrameTables()\13\n\9return currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function getNewFrameTables()\13\n\9return newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function setCurrentFrameTables(b, f, s, w, h)\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\nlocal function setNewFrameTables(b, f, s, w, h)\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\n\13\nlocal function setBufferOnly(b)\13\n\9bufferOnly = b\13\nend\13\nlocal function getBufferOnly()\13\n\9return bufferOnly\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function setDrawLimit(x1, y1, x2, y2)\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = x1, y1, x2, y2\13\nend\13\n\13\nlocal function resetDrawLimit()\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = 1, 1, bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getDrawLimit()\13\n\9return drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2\13\nend\13\n\13\nlocal function setDrawAreas(areas)\13\n\9drawAreas = areas\13\nend\13\nlocal function resetDrawAreas()\13\n\9drawAreas = {}\13\nend\13\nlocal function getDrawAreas()\13\n\9return drawAreas\13\nend\13\nlocal function setNonDrawAreas(areas)\13\n\9nonDrawAreas = areas\13\nend\13\nlocal function resetNonDrawAreas()\13\n\9nonDrawAreas = {}\13\nend\13\nlocal function getNonDrawAreas()\13\n\9return nonDrawAreas\13\nend\13\n\13\nlocal function setDrawAreaOffset(x, y)\13\n\9drawAreaOffsetX = x or drawAreaOffsetX\13\n\9drawAreaOffsetY = y or drawAreaOffsetY\13\n\9\13\nend\13\nlocal function getDrawAreaOffset()\13\n\9return drawAreaOffsetX, drawAreaOffsetY\13\nend\13\nlocal function resetDrawAreaOffset()\13\n\9drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nend\13\n\13\nlocal function isDrawable(x, y)\13\n\9local drawable = true\13\n\9\13\n\9if #drawAreas == 0 and #nonDrawAreas == 0 then\13\n\9\9--return true\13\n\9end\13\n\9\13\n\9for _, a in pairs(drawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = true\13\n\9\9\9break\13\n\9\9end\13\n\9\9drawable = false\13\n\9end\13\n\9for _, a in pairs(nonDrawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = false\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9return drawable\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function flush(width, height)\13\n\9if not width or not height then\13\n\9\9width, height = GPUProxyGetResolution()\13\n\9end\13\n\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = {}, {}, {}, {}, {}, {}\13\n\9bufferWidth = width\13\n\9bufferHeight = height\13\n\9resetDrawLimit()\13\n\13\n\9for y = 1, bufferHeight do\13\n\9\9for x = 1, bufferWidth do\13\n\9\9\9tableInsert(currentFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(currentFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(currentFrameSymbols, \" \")\13\n\13\n\9\9\9tableInsert(newFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(newFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(newFrameSymbols, \" \")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function setResolution(width, height)\13\n\9GPUProxySetResolution(width, height)\13\n\9flush(width, height)\13\nend\13\n\13\nlocal function getResolution()\13\n\9return bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getWidth()\13\n\9return bufferWidth\13\nend\13\n\13\nlocal function getHeight()\13\n\9return bufferHeight\13\nend\13\n\13\nlocal function bindScreen(...)\13\n\9GPUProxyBind(...)\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\nlocal function getGPUProxy()\13\n\9return GPUProxy\13\nend\13\n\13\nlocal function updateGPUProxyMethods()\13\n\9GPUProxyGet = GPUProxy.get\13\n\9GPUProxyGetResolution = GPUProxy.getResolution\13\n\9GPUProxyGetBackground = GPUProxy.getBackground\13\n\9GPUProxyGetForeground = GPUProxy.getForeground\13\n\13\n\9GPUProxySet = GPUProxy.set\13\n\9GPUProxySetResolution = GPUProxy.setResolution\13\n\9GPUProxySetBackground = GPUProxy.setBackground\13\n\9GPUProxySetForeground = GPUProxy.setForeground\13\n\13\n\9GPUProxyBind = GPUProxy.bind\13\n\9GPUProxyFill = GPUProxy.fill\13\nend\13\n\13\nlocal function bindGPU(address)\13\n\9GPUProxy = component.proxy(address)\13\n\9updateGPUProxyMethods()\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function rawSet(index, background, foreground, symbol)\13\n\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\nend\13\n\13\nlocal function rawGet(index)\13\n\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\nend\13\n\13\nlocal function get(x, y)\13\n\9if x >= 1 and y >= 1 and x <= bufferWidth and y <= bufferHeight then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9else\13\n\9\9return 0x000000, 0x000000, \" \"\13\n\9end\13\nend\13\n\13\nlocal function set(x, y, background, foreground, symbol)\13\n\9if x >= drawLimitX1 and y >= drawLimitY1 and x <= drawLimitX2 and y <= drawLimitY2 and isDrawable(x, y) then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9end\13\nend\13\n\13\nlocal function drawRectangle(x, y, width, height, background, foreground, symbol, transparency) \13\n\9local index, indexStepOnReachOfSquareWidth = bufferWidth * (y - 1) + x, bufferWidth - width\13\n\9for j = y, y + height - 1 do\13\n\9\9if j >= drawLimitY1 and j <= drawLimitY2 then\13\n\9\9\9for i = x, x + width - 1 do\13\n\9\9\9\9if i >= drawLimitX1 and i <= drawLimitX2 and isDrawable(i, j) then\13\n\9\9\9\9\9if transparency then\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9colorBlend(newFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9colorBlend(newFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9index = index + 1\13\n\9\9\9end\13\n\13\n\9\9\9index = index + indexStepOnReachOfSquareWidth\13\n\9\9else\13\n\9\9\9index = index + bufferWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clear(color, transparency)\13\n\9drawRectangle(1, 1, bufferWidth, bufferHeight, color or 0x0, 0x000000, \" \", transparency)\13\nend\13\n\13\nlocal function copy(x, y, width, height, current)\13\n\9local copyArray, index = { width, height }\13\n\9local rawCopyArray = { width, height }\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, newFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameSymbols[index])\13\n\9\9\9\9if current then\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameForegrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameSymbols[index])\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9\9if current then\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, \" \")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return copyArray, rawCopyArray\13\nend\13\n\13\nlocal function paste(startX, startY, picture, currentPicture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\9\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9newFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9\9if currentPicture ~= nil then\13\n\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = currentPicture[pictureIndex]\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = currentPicture[pictureIndex + 1]\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = currentPicture[pictureIndex + 2]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function copyCurrent(x, y, width, height)\13\n\9local copyArray, index = { width, height }\13\n\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameSymbols[index])\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return copyArray\13\nend\13\n\13\nlocal function pasteCurrent(startX, startY, picture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9currentFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function directCopy(x, y, width, height, tx, ty, current, actualBuffer)\13\n\9local index\13\n\9local imageWidth = width\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (ty - 1) + tx, 3, bufferWidth - imageWidth\13\n\9\13\n\9local newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols\13\n\9\13\n\9if actualBuffer then\13\n\9\9newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9else\13\n\9\9newBackgrounds, newForegrounds, newSymbols = {table.unpack(newFrameBackgrounds)}, {table.unpack(newFrameForegrounds)}, {table.unpack(newFrameSymbols)}\13\n\9\13\n\9\13\n\9\9if current then\13\n\9\9\9currentBackgrounds, currentForegrounds, currentSymbols = {table.unpack(currentFrameBackgrounds)}, {table.unpack(currentFrameForegrounds)}, {table.unpack(currentFrameSymbols)}\13\n\9\9end\13\n\9end\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9local newX, newY = getCoordinates(bufferIndex)\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(ewX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9newForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9newSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = currentFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = currentFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = currentFrameSymbols[index]\13\n\9\9\9\9\9\9--[[\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\9]]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(newX, newY) then\13\n\9\9\9\9\9newBackgrounds[newIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[newIndex] = 0x0\13\n\9\9\9\9\9newSymbols[newIndex] = \" \"\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9end\13\n\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9end\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = newBackgrounds, newForegrounds, newSymbols\13\n\9if current then\13\n\9\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols = currentBackgrounds, currentForegrounds, currentSymbols\13\n\9end\13\nend\13\n\13\nlocal function rasterizeLine(x1, y1, x2, y2, method)\13\n\9local inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = x1, x2, y1, y2, false, mathAbs(x2 - x1), mathAbs(y2 - y1)\13\n\9if inLoopValueDelta < outLoopValueDelta then\13\n\9\9inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = y1, y2, x1, x2, true, outLoopValueDelta, inLoopValueDelta\13\n\9end\13\n\13\n\9if outLoopValueFrom > outLoopValueTo then\13\n\9\9outLoopValueFrom, outLoopValueTo = outLoopValueTo, outLoopValueFrom\13\n\9\9inLoopValueFrom, inLoopValueTo = inLoopValueTo, inLoopValueFrom\13\n\9end\13\n\13\n\9local outLoopValue, outLoopValueCounter, outLoopValueTriggerIncrement = outLoopValueFrom, 1, inLoopValueDelta / outLoopValueDelta\13\n\9local outLoopValueTrigger = outLoopValueTriggerIncrement\13\n\9for inLoopValue = inLoopValueFrom, inLoopValueTo, inLoopValueFrom < inLoopValueTo and 1 or -1 do\13\n\9\9if isReversed then\13\n\9\9\9method(outLoopValue, inLoopValue)\13\n\9\9else\13\n\9\9\9method(inLoopValue, outLoopValue)\13\n\9\9end\13\n\13\n\9\9outLoopValueCounter = outLoopValueCounter + 1\13\n\9\9if outLoopValueCounter > outLoopValueTrigger then\13\n\9\9\9outLoopValue, outLoopValueTrigger = outLoopValue + 1, outLoopValueTrigger + outLoopValueTriggerIncrement\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function rasterizeEllipse(centerX, centerY, radiusX, radiusY, method)\13\n\9local function rasterizeEllipsePoints(XP, YP)\13\n\9\9method(centerX + XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY - YP)\13\n\9\9method(centerX + XP, centerY - YP) \13\n\9end\13\n\13\n\9local x, y, changeX, changeY, ellipseError, twoASquare, twoBSquare = radiusX, 0, radiusY * radiusY * (1 - 2 * radiusX), radiusX * radiusX, 0, 2 * radiusX * radiusX, 2 * radiusY * radiusY\13\n\9local stoppingX, stoppingY = twoBSquare * radiusX, 0\13\n\13\n\9while stoppingX >= stoppingY do\13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9y, stoppingY, ellipseError = y + 1, stoppingY + twoASquare, ellipseError + changeY\13\n\9\9changeY = changeY + twoASquare\13\n\13\n\9\9if (2 * ellipseError + changeX) > 0 then\13\n\9\9\9x, stoppingX, ellipseError = x - 1, stoppingX - twoBSquare, ellipseError + changeX\13\n\9\9\9changeX = changeX + twoBSquare\13\n\9\9end\13\n\9end\13\n\13\n\9x, y, changeX, changeY, ellipseError, stoppingX, stoppingY = 0, radiusY, radiusY * radiusY, radiusX * radiusX * (1 - 2 * radiusY), 0, 0, twoASquare * radiusY\13\n\13\n\9while stoppingX <= stoppingY do \13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9x, stoppingX, ellipseError = x + 1, stoppingX + twoBSquare, ellipseError + changeX\13\n\9\9changeX = changeX + twoBSquare\13\n\9\9\13\n\9\9if (2 * ellipseError + changeY) > 0 then\13\n\9\9\9y, stoppingY, ellipseError = y - 1, stoppingY - twoASquare, ellipseError + changeY\13\n\9\9\9changeY = changeY + twoASquare\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawLine(x1, y1, x2, y2, background, foreground, symbol)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawEllipse(centerX, centerY, radiusX, radiusY, background, foreground, symbol)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawText(x, y, textColor, data, transparency)\13\n\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9local charIndex, bufferIndex = 1, bufferWidth * (y - 1) + x\13\n\9\9\13\n\9\9for charIndex = 1, unicodeLen(data) do\13\n\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9if transparency then\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9else\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9end\13\n\13\n\9\9\9\9newFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9end\13\n\13\n\9\9\9x, bufferIndex = x + 1, bufferIndex + 1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawImage(startX, startY, picture, blendForeground)\13\n\9local bufferIndex, pictureIndex, imageWidth, backgrounds, foregrounds, alphas, symbols = bufferWidth * (startY - 1) + startX, 1, picture[1], picture[3], picture[4], picture[5], picture[6]\13\n\9local bufferIndexStepOnReachOfImageWidth = bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9if alphas[pictureIndex] == 0 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex], newFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9elseif alphas[pictureIndex] > 0 and alphas[pictureIndex] < 1 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if blendForeground then\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] == 1 and symbols[pictureIndex] ~= \" \" then\13\n\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 1\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(x, y, width, height, color)\13\n\9local stringUp, stringDown, x2 = \"\" .. string.rep(\"\", width - 2) .. \"\", \"\" .. string.rep(\"\", width - 2) .. \"\", x + width - 1\13\n\9\13\n\9drawText(x, y, color, stringUp); y = y + 1\13\n\9for i = 1, height - 2 do\13\n\9\9drawText(x, y, color, \"\")\13\n\9\9drawText(x2, y, color, \"\")\13\n\9\9y = y + 1\13\n\9end\13\n\9drawText(x, y, color, stringDown)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function semiPixelRawSet(index, color, yPercentTwoEqualsZero)\13\n\9local upperPixel, lowerPixel, bothPixel = \"\", \"\", \" \"\13\n\9local background, foreground, symbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\13\n\9if yPercentTwoEqualsZero then\13\n\9\9if symbol == upperPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, lowerPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, lowerPixel\13\n\9\9end\13\n\9else\13\n\9\9if symbol == lowerPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, upperPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, upperPixel\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function semiPixelSet(x, y, color)\13\n\9local yFixed = mathCeil(y / 2)\13\n\9if x >= drawLimitX1 and yFixed >= drawLimitY1 and x <= drawLimitX2 and yFixed <= drawLimitY2 and isDrawable(x, yFixed) then\13\n\9\9semiPixelRawSet(bufferWidth * (yFixed - 1) + x, color, y % 2 == 0)\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelRectangle(x, y, width, height, color)\13\n\9local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = bufferWidth * (mathCeil(y / 2) - 1) + x, (bufferWidth - width), width\13\n\9for j = y, y + height - 1 do\13\n\9\9jPercentTwoEqualsZero = j % 2 == 0\13\n\9\9\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9jFixed = mathCeil(j / 2)\13\n\9\9\9semiPixelRawSet(index, color, jPercentTwoEqualsZero)\13\n\9\9\9index = index + 1\13\n\9\9end\13\n\13\n\9\9if jPercentTwoEqualsZero then\13\n\9\9\9index = index + indexStepForward\13\n\9\9else\13\n\9\9\9index = index - indexStepBackward\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelLine(x1, y1, x2, y2, color)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\nlocal function drawSemiPixelEllipse(centerX, centerY, radiusX, radiusY, color)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getPointTimedPosition(firstPoint, secondPoint, time)\13\n\9return {\13\n\9\9x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,\13\n\9\9y = firstPoint.y + (secondPoint.y - firstPoint.y) * time\13\n\9}\13\nend\13\n\13\nlocal function getConnectionPoints(points, time)\13\n\9local connectionPoints = {}\13\n\9for point = 1, #points - 1 do\13\n\9\9tableInsert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))\13\n\9end\13\n\9return connectionPoints\13\nend\13\n\13\nlocal function getMainPointPosition(points, time)\13\n\9if #points > 1 then\13\n\9\9return getMainPointPosition(getConnectionPoints(points, time), time)\13\n\9else\13\n\9\9return points[1]\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelCurve(points, color, precision)\13\n\9local linePoints = {}\13\n\9for time = 0, 1, precision or 0.01 do\13\n\9\9tableInsert(linePoints, getMainPointPosition(points, time))\13\n\9end\13\n\9\13\n\9for point = 1, #linePoints - 1 do\13\n\9\9drawSemiPixelLine(mathFloor(linePoints[point].x), mathFloor(linePoints[point].y), mathFloor(linePoints[point + 1].x), mathFloor(linePoints[point + 1].y), color)\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function drawChanges(force)\13\n\9local index, indexStepOnEveryLine, changes = bufferWidth * (drawLimitY1 - 1) + drawLimitX1, (bufferWidth - drawLimitX2 + drawLimitX1 - 1), {}\13\n\9local x, equalChars, equalCharsIndex, charX, charIndex, currentForeground\13\n\9local currentFrameBackground, currentFrameForeground, currentFrameSymbol, changesCurrentFrameBackground, changesCurrentFrameBackgroundCurrentFrameForeground\13\n\13\n\9local changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\13\n\9for y = drawLimitY1, drawLimitY2 do\13\n\9\9x = drawLimitX1\13\n\9\9while x <= drawLimitX2 do\9\9\9\13\n\9\9\9-- Determine if some pixel data was changed (or if <force> argument was passed)\13\n\9\9\9if\13\n\9\9\9\9currentFrameBackgrounds[index] ~= newFrameBackgrounds[index] or\13\n\9\9\9\9currentFrameForegrounds[index] ~= newFrameForegrounds[index] or\13\n\9\9\9\9currentFrameSymbols[index] ~= newFrameSymbols[index] or\13\n\9\9\9\9force\13\n\9\9\9then\13\n\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9currentFrameBackground, currentFrameForeground, currentFrameSymbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9\9\9\9currentFrameBackgrounds[index] = currentFrameBackground\13\n\9\9\9\9currentFrameForegrounds[index] = currentFrameForeground\13\n\9\9\9\9currentFrameSymbols[index] = currentFrameSymbol\13\n\13\n\9\9\9\9-- Look for pixels with equal chars from right of current pixel\13\n\9\9\9\9equalChars, equalCharsIndex, charX, charIndex = {currentFrameSymbol}, 2, x + 1, index + 1\13\n\9\9\9\9while charX <= drawLimitX2 do\13\n\9\9\9\9\9-- Pixels becomes equal only if they have same background and (whitespace char or same foreground)\13\n\9\9\9\9\9if\9\13\n\9\9\9\9\9\9currentFrameBackground == newFrameBackgrounds[charIndex] and\13\n\9\9\9\9\9\9(\13\n\9\9\9\9\9\9\9newFrameSymbols[charIndex] == \" \" or\13\n\9\9\9\9\9\9\9currentFrameForeground == newFrameForegrounds[charIndex]\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9\9 \9currentFrameBackgrounds[charIndex] = newFrameBackgrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameForegrounds[charIndex] = newFrameForegrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameSymbols[charIndex] = newFrameSymbols[charIndex]\13\n\13\n\9\9\9\9\9 \9equalChars[equalCharsIndex], equalCharsIndex = currentFrameSymbols[charIndex], equalCharsIndex + 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9charX, charIndex = charX + 1, charIndex + 1\13\n\9\9\9\9end\13\n\13\n\9\9\9\9-- Group pixels that need to be drawn by background and foreground\13\n\9\9\9\9changes[currentFrameBackground] = changes[currentFrameBackground] or {}\13\n\9\9\9\9changesCurrentFrameBackground = changes[currentFrameBackground]\13\n\9\9\9\9changesCurrentFrameBackground[currentFrameForeground] = changesCurrentFrameBackground[currentFrameForeground] or {index = 1}\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground = changesCurrentFrameBackground[currentFrameForeground]\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForegroundIndex = changesCurrentFrameBackgroundCurrentFrameForeground.index\13\n\9\9\9\9\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = x, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = y, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = tableConcat(equalChars), changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9\13\n\9\9\9\9x, index, changesCurrentFrameBackgroundCurrentFrameForeground.index = x + equalCharsIndex - 2, index + equalCharsIndex - 2, changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\9\9\9end\13\n\13\n\9\9\9x, index = x + 1, index + 1\13\n\9\9end\13\n\13\n\9\9index = index + indexStepOnEveryLine\13\n\9end\13\n\9\13\n\9-- Draw grouped pixels on screen\13\n\9for background, foregrounds in pairs(changes) do\13\n\9\9GPUProxySetBackground(background)\13\n\13\n\9\9for foreground, pixels in pairs(foregrounds) do\13\n\9\9\9if currentForeground ~= foreground then\13\n\9\9\9\9GPUProxySetForeground(foreground)\13\n\9\9\9\9currentForeground = foreground\13\n\9\9\9end\13\n\13\n\9\9\9for i = 1, #pixels, 3 do\13\n\9\9\9\9GPUProxySet(pixels[i], pixels[i + 1], pixels[i + 2])\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9changes = nil\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nbindGPU(component.getPrimary(\"gpu\").address)\13\n\13\nreturn {\13\n\9getCoordinates = getCoordinates,\13\n\9getIndex = getIndex,\13\n\9setDrawLimit = setDrawLimit,\13\n\9resetDrawLimit = resetDrawLimit,\13\n\9getDrawLimit = getDrawLimit,\13\n\9flush = flush,\13\n\9setResolution = setResolution,\13\n\9bindScreen = bindScreen,\13\n\9bindGPU = bindGPU,\13\n\9getGPUProxy = getGPUProxy,\13\n\9getResolution = getResolution,\13\n\9getWidth = getWidth,\13\n\9getHeight = getHeight,\13\n\9getCurrentFrameTables = getCurrentFrameTables,\13\n\9getNewFrameTables = getNewFrameTables,\13\n\9setCurrentFrameTables = setCurrentFrameTables,\13\n\9setNewFrameTables = setNewFrameTables,\13\n\9setBufferOnly = setBufferOnly,\13\n\9getBufferOnly = getBufferOnly,\13\n\13\n\9rawSet = rawSet,\13\n\9rawGet = rawGet,\13\n\9get = get,\13\n\9set = set,\13\n\9clear = clear,\13\n\9copy = copy,\13\n\9paste = paste,\13\n\9directCopy = directCopy,\13\n\9copyCurrent = copyCurrent,\13\n\9pasteCurrent = pasteCurrent,\13\n\9rasterizeLine = rasterizeLine,\13\n\9rasterizeEllipse = rasterizeEllipse,\13\n\9semiPixelRawSet = semiPixelRawSet,\13\n\9semiPixelSet = semiPixelSet,\13\n\9drawChanges = drawChanges,\13\n\13\n\9drawRectangle = drawRectangle,\13\n\9drawLine = drawLine,\13\n\9drawEllipse = drawEllipse,\13\n\9drawText = drawText,\13\n\9drawImage = drawImage,\13\n\9drawFrame = drawFrame,\13\n\13\n\9drawSemiPixelRectangle = drawSemiPixelRectangle,\13\n\9drawSemiPixelLine = drawSemiPixelLine,\13\n\9drawSemiPixelEllipse = drawSemiPixelEllipse,\13\n\9drawSemiPixelCurve = drawSemiPixelCurve,\13\n\9\13\n\9setDrawAreas = setDrawAreas,\13\n\9resetDrawAreas = resetDrawAreas,\13\n\9getDrawAreas = getDrawAreas,\13\n\9setNonDrawAreas = setNonDrawAreas,\13\n\9resetNonDrawAreas = resetNonDrawAreas,\13\n\9getNonDrawAreas = getNonDrawAreas,\13\n\9\13\n\9setDrawAreaOffset = setDrawAreaOffset,\13\n\9getDrawAreaOffset = getDrawAreaOffset,\13\n\9resetDrawAreaOffset = resetDrawAreaOffset,\13\n}",["./libs/thirdParty/AdvancedLua.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are possibly made some changes if needed to fit in to the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/AdvancedLua>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nAdvancedLua Copyright (c) 2018 Igor Timofeev\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\n\13\nlocal filesystem = require(\"filesystem\")\13\nlocal unicode = require(\"unicode\")\13\nlocal bit32 = require(\"bit32\")\13\n\13\n----------------------------------------------------------------------------------------------------\13\n\13\nfunction _G.getCurrentScript()\13\n\9local info\13\n\9for runLevel = 0, math.huge do\13\n\9\9info = debug.getinfo(runLevel)\13\n\9\9if info then\13\n\9\9\9if info.what == \"main\" then\13\n\9\9\9\9return info.source:sub(2, -1)\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9error(\"Failed to get debug info for runlevel \" .. runLevel)\13\n\9\9end\13\n\9end\13\nend\13\n\13\n----------------------------------------------------------------------------------------------------\13\n\13\nfunction bit32.merge(number2, number1)\13\n\9local cutter = math.ceil(math.log(number1 + 1, 256)) * 8\13\n\9while number2 > 0 do\13\n\9\9number1, number2, cutter = bit32.bor(bit32.lshift(bit32.band(number2, 0xFF), cutter), number1), bit32.rshift(number2, 8), cutter + 8\13\n\9end\13\n\13\n\9return number1\13\nend\13\n\13\nfunction bit32.numberToByteArray(number)\13\n\9local byteArray = {}\13\n\13\n\9repeat\13\n\9\9table.insert(byteArray, 1, bit32.band(number, 0xFF))\13\n\9\9number = bit32.rshift(number, 8)\13\n\9until number <= 0\13\n\13\n\9return byteArray\13\nend\13\n\13\nfunction bit32.numberToFixedSizeByteArray(number, size)\13\n\9local byteArray, counter = {}, 0\13\n\9\13\n\9repeat\13\n\9\9table.insert(byteArray, 1, bit32.band(number, 0xFF))\13\n\9\9number = bit32.rshift(number, 8)\13\n\9\9counter = counter + 1\13\n\9until number <= 0\13\n\13\n\9for i = 1, size - counter do\13\n\9\9table.insert(byteArray, 1, 0x0)\13\n\9end\13\n\13\n\9return byteArray\13\nend\13\n\13\nfunction bit32.byteArrayToNumber(byteArray)\13\n\9local result = byteArray[1]\13\n\9for i = 2, #byteArray do\13\n\9\9result = bit32.bor(bit32.lshift(result, 8), byteArray[i])\13\n\9end\13\n\13\n\9return result\13\nend\13\n\13\nfunction bit32.bitArrayToByte(bitArray)\13\n\9local result = 0\13\n\9for i = 1, #bitArray do\13\n\9\9result = bit32.bor(bitArray[i], bit32.lshift(result, 1))\13\n\9end\13\n\13\n\9return result\13\nend\13\n\13\n----------------------------------------------------------------------------------------------------\13\n\13\nfunction math.round(num) \13\n\9if num >= 0 then\13\n\9\9return math.floor(num + 0.5)\13\n\9else\13\n\9\9return math.ceil(num - 0.5)\13\n\9end\13\nend\13\n\13\nfunction math.roundToDecimalPlaces(num, decimalPlaces)\13\n\9local mult = 10 ^ (decimalPlaces or 0)\13\n\9return math.round(num * mult) / mult\13\nend\13\n\13\nfunction math.getDigitCount(num)\13\n\9return num == 0 and 1 or math.ceil(math.log(num + 1, 10))\13\nend\13\n\13\nfunction math.shorten(number, digitCount)\13\n\9local shortcuts = {\13\n\9\9\"K\",\13\n\9\9\"M\",\13\n\9\9\"B\",\13\n\9\9\"T\"\13\n\9}\13\n\13\n\9local index = math.floor(math.log(number, 1000))\13\n\9if number < 1000 then\13\n\9\9return number\13\n\9elseif index > #shortcuts then\13\n\9\9index = #shortcuts\13\n\9end\13\n\13\n\9return math.roundToDecimalPlaces(number / 1000 ^ index, digitCount) .. shortcuts[index]\13\nend\13\n\13\n----------------------------------------------------------------------------------------------------\13\n\13\n-- function filesystem.path(path)\13\n-- \9return path:match(\"^(.+%/).\") or \"\"\13\n-- end\13\n\13\n-- function filesystem.name(path)\13\n-- \9return path:match(\"%/?([^%/]+)%/?$\")\13\n-- end\13\n\13\nfunction filesystem.extension(path, lower)\13\n\9local extension = path:match(\"[^%/]+(%.[^%/]+)%/?$\")\13\n\9return (lower and extension) and (unicode.lower(extension)) or extension\13\nend\13\n\13\nfunction filesystem.hideExtension(path)\13\n\9return path:match(\"(.+)%..+\") or path\13\nend\13\n\13\nfunction filesystem.isFileHidden(path)\13\n\9if path:match(\"^%..+$\") then\13\n\9\9return true\13\n\9end\13\n\13\n\9return false\13\nend\13\n\13\nfunction filesystem.sortedList(path, sortingMethod, showHiddenFiles, filenameMatcher, filenameMatcherCaseSensitive)\13\n\9if not filesystem.exists(path) then\13\n\9\9error(\"Failed to get file list: directory \\\"\" .. tostring(path) .. \"\\\" doesn't exists\")\13\n\9end\13\n\13\n\9if not filesystem.isDirectory(path) then\13\n\9\9error(\"Failed to get file list: path \\\"\" .. tostring(path) .. \"\\\" is not a directory\")\13\n\9end\13\n\13\n\9local fileList, sortedFileList = {}, {}\13\n\9for file in filesystem.list(path) do\13\n\9\9if not filenameMatcher or string.unicodeFind(filenameMatcherCaseSensitive and file or unicode.lower(file), filenameMatcherCaseSensitive and filenameMatcher or unicode.lower(filenameMatcher)) then\13\n\9\9\9table.insert(fileList, file)\13\n\9\9end\13\n\9end\13\n\13\n\9if #fileList > 0 then\13\n\9\9if sortingMethod == \"type\" then\13\n\9\9\9local extension\13\n\9\9\9for i = 1, #fileList do\13\n\9\9\9\9extension = filesystem.extension(fileList[i]) or \"Script\"\13\n\9\9\9\9if filesystem.isDirectory(path .. fileList[i]) and extension ~= \".app\" then\13\n\9\9\9\9\9extension = \".01_Folder\"\13\n\9\9\9\9end\13\n\9\9\9\9fileList[i] = {fileList[i], extension}\13\n\9\9\9end\13\n\13\n\9\9\9table.sort(fileList, function(a, b) return unicode.lower(a[2]) < unicode.lower(b[2]) end)\13\n\13\n\9\9\9local currentExtensionList, currentExtension = {}, fileList[1][2]\13\n\9\9\9for i = 1, #fileList do\13\n\9\9\9\9if currentExtension == fileList[i][2] then\13\n\9\9\9\9\9table.insert(currentExtensionList, fileList[i][1])\13\n\9\9\9\9else\13\n\9\9\9\9\9table.sort(currentExtensionList, function(a, b) return unicode.lower(a) < unicode.lower(b) end)\13\n\9\9\9\9\9for j = 1, #currentExtensionList do\13\n\9\9\9\9\9\9table.insert(sortedFileList, currentExtensionList[j])\13\n\9\9\9\9\9end\13\n\9\9\9\9\9currentExtensionList, currentExtension = {fileList[i][1]}, fileList[i][2]\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9table.sort(currentExtensionList, function(a, b) return unicode.lower(a) < unicode.lower(b) end)\13\n\9\9\9\13\n\9\9\9for j = 1, #currentExtensionList do\13\n\9\9\9\9table.insert(sortedFileList, currentExtensionList[j])\13\n\9\9\9end\13\n\9\9elseif sortingMethod == \"name\" then\13\n\9\9\9sortedFileList = fileList\13\n\9\9\9table.sort(sortedFileList, function(a, b) return unicode.lower(a) < unicode.lower(b) end)\13\n\9\9elseif sortingMethod == \"date\" then\13\n\9\9\9for i = 1, #fileList do\13\n\9\9\9\9fileList[i] = {fileList[i], filesystem.lastModified(path .. fileList[i])}\13\n\9\9\9end\13\n\13\n\9\9\9table.sort(fileList, function(a, b) return unicode.lower(a[2]) > unicode.lower(b[2]) end)\13\n\13\n\9\9\9for i = 1, #fileList do\13\n\9\9\9\9table.insert(sortedFileList, fileList[i][1])\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9error(\"Unknown sorting method: \" .. tostring(sortingMethod))\13\n\9\9end\13\n\13\n\9\9local i = 1\13\n\9\9while i <= #sortedFileList do\13\n\9\9\9if not showHiddenFiles and filesystem.isFileHidden(sortedFileList[i]) then\13\n\9\9\9\9table.remove(sortedFileList, i)\13\n\9\9\9else\13\n\9\9\9\9i = i + 1\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return sortedFileList\13\nend\13\n\13\nfunction filesystem.directorySize(path)\13\n\9local size = 0\13\n\9for file in filesystem.list(path) do\13\n\9\9if filesystem.isDirectory(path .. file) then\13\n\9\9\9size = size + filesystem.directorySize(path .. file)\13\n\9\9else\13\n\9\9\9size = size + filesystem.size(path .. file)\13\n\9\9end\13\n\9end\13\n\9\13\n\9return size\13\nend\13\n\13\nfunction filesystem.readUnicodeChar(file)\13\n\9local byteArray = {string.byte(file:read(1))}\13\n\13\n\9local nullBitPosition = 0\13\n\9for i = 1, 7 do\13\n\9\9if bit32.band(bit32.rshift(byteArray[1], 8 - i), 0x1) == 0x0 then\13\n\9\9\9nullBitPosition = i\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\13\n\9for i = 1, nullBitPosition - 2 do\13\n\9\9table.insert(byteArray, string.byte(file:read(1)))\13\n\9end\13\n\13\n\9return string.char(table.unpack(byteArray))\13\nend\13\n\13\n----------------------------------------------------------------------------------------------------\13\n\13\nfunction table.serialize(array, prettyLook, indentationWidth, indentUsingTabs, recursionStackLimit)\13\n\9checkArg(1, array, \"table\")\13\n\13\n\9recursionStackLimit = recursionStackLimit or math.huge\13\n\9local indentationSymbolAdder = string.rep(indentUsingTabs and \"\9\" or \" \", indentationWidth or 2)\13\n\9local equalsSymbol = prettyLook and \" = \" or \"=\"\13\n\13\n\9local function serializeRecursively(array, currentIndentationSymbol, currentRecusrionStack)\13\n\9\9local result, nextIndentationSymbol, keyType, valueType, stringValue = {\"{\"}, currentIndentationSymbol .. indentationSymbolAdder\13\n\9\9\13\n\9\9if prettyLook then\13\n\9\9\9table.insert(result, \"\\n\")\13\n\9\9end\13\n\9\9\13\n\9\9for key, value in pairs(array) do\13\n\9\9\9keyType, valueType, stringValue = type(key), type(value), tostring(value)\13\n\13\n\9\9\9if prettyLook then\13\n\9\9\9\9table.insert(result, nextIndentationSymbol)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9if keyType == \"number\" then\13\n\9\9\9\9table.insert(result, \"[\")\13\n\9\9\9\9table.insert(result, key)\13\n\9\9\9\9table.insert(result, \"]\")\13\n\9\9\9\9table.insert(result, equalsSymbol)\13\n\9\9\9elseif keyType == \"string\" then\13\n\9\9\9\9-- ,     ,     - \13\n\9\9\9\9if prettyLook and key:match(\"^%a\") and key:match(\"^[%w%_]+$\") then\13\n\9\9\9\9\9table.insert(result, key)\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(result, \"[\\\"\")\13\n\9\9\9\9\9table.insert(result, key)\13\n\9\9\9\9\9table.insert(result, \"\\\"]\")\13\n\9\9\9\9end\13\n\13\n\9\9\9\9table.insert(result, equalsSymbol)\13\n\9\9\9end\13\n\13\n\9\9\9if valueType == \"number\" or valueType == \"boolean\" or valueType == \"nil\" then\13\n\9\9\9\9table.insert(result, stringValue)\13\n\9\9\9elseif valueType == \"string\" or valueType == \"function\" then\13\n\9\9\9\9table.insert(result, \"\\\"\")\13\n\9\9\9\9table.insert(result, stringValue)\13\n\9\9\9\9table.insert(result, \"\\\"\")\13\n\9\9\9elseif valueType == \"table\" then\13\n\9\9\9\9if currentRecusrionStack < recursionStackLimit then\13\n\9\9\9\9\9table.insert(\13\n\9\9\9\9\9\9result,\13\n\9\9\9\9\9\9table.concat(\13\n\9\9\9\9\9\9\9serializeRecursively(\13\n\9\9\9\9\9\9\9\9value,\13\n\9\9\9\9\9\9\9\9nextIndentationSymbol,\13\n\9\9\9\9\9\9\9\9currentRecusrionStack + 1\13\n\9\9\9\9\9\9\9)\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9)\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(result, \"\\\"\\\"\")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9table.insert(result, \",\")\13\n\13\n\9\9\9if prettyLook then\13\n\9\9\9\9table.insert(result, \"\\n\")\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9--  \13\n\9\9if prettyLook then\13\n\9\9\9if #result > 2 then\13\n\9\9\9\9table.remove(result, #result - 1)\13\n\9\9\9end\13\n\13\n\9\9\9table.insert(result, currentIndentationSymbol)\13\n\9\9else\13\n\9\9\9if #result > 1 then\13\n\9\9\9\9table.remove(result, #result)\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9table.insert(result, \"}\")\13\n\13\n\9\9return result\13\n\9end\13\n\9\13\n\9return table.concat(serializeRecursively(array, \"\", 1))\13\nend\13\n\13\nfunction table.unserialize(serializedString)\13\n\9checkArg(1, serializedString, \"string\")\13\n\9\13\n\9local result, reason = load(\"return \" .. serializedString)\13\n\9if result then\13\n\9\9result, reason = pcall(result)\13\n\9\9if result then\13\n\9\9\9return reason\13\n\9\9else\13\n\9\9\9return nil, reason\13\n\9\9end\13\n\9else\13\n\9\9return nil, reason\13\n\9end\13\nend\13\n\13\ntable.toString = table.serialize\13\ntable.fromString = table.unserialize\13\n\13\nfunction table.toFile(path, array, prettyLook, indentationWidth, indentUsingTabs, recursionStackLimit, appendToFile)\13\n\9checkArg(1, path, \"string\")\13\n\9checkArg(2, array, \"table\")\13\n\9\13\n\9filesystem.makeDirectory(filesystem.path(path) or \"\")\13\n\9\13\n\9local file, reason = io.open(path, appendToFile and \"a\" or \"w\")\13\n\9if file then\13\n\9\9file:write(table.serialize(array, prettyLook, indentationWidth, indentUsingTabs, recursionStackLimit))\13\n\9\9file:close()\13\n\9else\13\n\9\9error(\"Failed to open file for writing: \" .. tostring(reason))\13\n\9end\13\nend\13\n\13\nfunction table.fromFile(path)\13\n\9checkArg(1, path, \"string\")\13\n\9\13\n\9local file, reason = io.open(path, \"r\")\13\n\9if file then\13\n\9\9local data, reason = table.unserialize(file:read(\"*a\"))\13\n\9\9file:close()\13\n\13\n\9\9if data then\13\n\9\9\9return data\13\n\9\9else\13\n\9\9\9error(\"Failed to unserialize file \\\"\" .. path .. \"\\\": \" .. tostring(reason))\13\n\9\9end\13\n\9else\13\n\9\9error(\"Failed to open file \\\"\" .. path .. \"\\\" for reading: \" .. tostring(reason))\13\n\9end\13\nend\13\n\13\nfunction table.copy(tableToCopy)\13\n\9local function copyTableRecursively(source, destination)\13\n\9\9for key, value in pairs(source) do\13\n\9\9\9if type(value) == \"table\" then\13\n\9\9\9\9destination[key] = {}\13\n\9\9\9\9doTableCopy(source[key], destination[key])\13\n\9\9\9else\13\n\9\9\9\9destination[key] = value\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9local result = {}\13\n\9copyTableRecursively(tableToCopy, result)\13\n\13\n\9return result\13\nend\13\n\13\nfunction table.size(t)\13\n\9local size = 0\13\n\9for key in pairs(t) do size = size + 1 end\13\n\9return size\13\nend\13\n\13\nfunction table.contains(t, object)\13\n\9for _, value in pairs(t) do\13\n\9\9if value == object then\13\n\9\9\9return true\13\n\9\9end\13\n\9end\13\n\9return false\13\nend\13\n\13\nfunction table.indexOf(t, object)\13\n\9for i = 1, #t do\13\n\9\9if t[i] == object then \13\n\9\9\9return i\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction table.sortAlphabetically(t)\13\n\9table.sort(t, function(a, b) return a < b end)\13\nend\13\n\13\n----------------------------------------------------------------------------------------------------\13\n\13\nfunction string.brailleChar(a, b, c, d, e, f, g, h)\13\n\9return unicode.char(10240 + 128*h + 64*g + 32*f + 16*d + 8*b + 4*e + 2*c + a)\13\nend\13\n\13\nfunction string.canonicalPath(str)\13\n\9return string.gsub(\"/\" .. str, \"%/+\", \"/\")\13\nend\13\n\13\nfunction string.optimize(str, indentationWidth)\13\n\9str = string.gsub(str, \"\\r\\n\", \"\\n\")\13\n\9str = string.gsub(str, \"\9\", string.rep(\" \", indentationWidth or 2))\13\n\9return str\13\nend\13\n\13\nfunction string.optimizeForURLRequests(code)\13\n\9if code then\13\n\9\9code = string.gsub(code, \"([^%w ])\", function (c)\13\n\9\9\9return string.format(\"%%%02X\", string.byte(c))\13\n\9\9end)\13\n\9\9code = string.gsub(code, \" \", \"+\")\13\n\9end\13\n\9return code \13\nend\13\n\13\nfunction string.unicodeFind(str, pattern, init, plain)\13\n\9if init then\13\n\9\9if init < 0 then\13\n\9\9\9init = -#unicode.sub(str, init)\13\n\9\9elseif init > 0 then\13\n\9\9\9init = #unicode.sub(str, 1, init - 1) + 1\13\n\9\9end\13\n\9end\13\n\9\13\n\9a, b = string.find(str, pattern, init, plain)\13\n\9\13\n\9if a then\13\n\9\9local ap, bp = str:sub(1, a - 1), str:sub(a,b)\13\n\9\9a = unicode.len(ap) + 1\13\n\9\9b = a + unicode.len(bp) - 1\13\n\9\9return a, b\13\n\9else\13\n\9\9return a\13\n\9end\13\nend\13\n\13\nfunction string.limit(s, limit, mode, noDots)\13\n\9local length = unicode.len(s)\13\n\9if length <= limit then return s end\13\n\13\n\9if mode == \"left\" then\13\n\9\9if noDots then\13\n\9\9\9return unicode.sub(s, length - limit + 1, -1)\13\n\9\9else\13\n\9\9\9return \"\" .. unicode.sub(s, length - limit + 2, -1)\13\n\9\9end\13\n\9elseif mode == \"center\" then\13\n\9\9local integer, fractional = math.modf(limit / 2)\13\n\9\9if fractional == 0 then\13\n\9\9\9return unicode.sub(s, 1, integer) .. \"\" .. unicode.sub(s, -integer + 1, -1)\13\n\9\9else\13\n\9\9\9return unicode.sub(s, 1, integer) .. \"\" .. unicode.sub(s, -integer, -1)\13\n\9\9end\13\n\9else\13\n\9\9if noDots then\13\n\9\9\9return unicode.sub(s, 1, limit)\13\n\9\9else\13\n\9\9\9return unicode.sub(s, 1, limit - 1) .. \"\"\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction string.wrap(data, limit)\13\n\9if type(data) == \"string\" then data = {data} end\13\n\13\n\9local wrappedLines, result, preResult, position = {}\13\n\13\n\9--   ,     \13\n\9for i = 1, #data do\13\n\9\9wrappedLines[i] = data[i]\13\n\9end\13\n\13\n\9--   -\13\n\9local i = 1\13\n\9while i <= #wrappedLines do\13\n\9\9local position = string.unicodeFind(wrappedLines[i], \"\\n\")\13\n\9\9if position then\13\n\9\9\9table.insert(wrappedLines, i + 1, unicode.sub(wrappedLines[i], position + 1, -1))\13\n\9\9\9wrappedLines[i] = unicode.sub(wrappedLines[i], 1, position - 1)\13\n\9\9end\13\n\13\n\9\9i = i + 1\13\n\9end\13\n\13\n\9--  \13\n\9local i = 1\13\n\9while i <= #wrappedLines do\13\n\9\9result = \"\"\13\n\13\n\9\9for word in wrappedLines[i]:gmatch(\"[^%s]+\") do\13\n\9\9\9preResult = result .. word\13\n\13\n\9\9\9if unicode.len(preResult) > limit then\13\n\9\9\9\9if unicode.len(word) > limit then\13\n\9\9\9\9\9table.insert(wrappedLines, i + 1, unicode.sub(wrappedLines[i], limit + 1, -1))\13\n\9\9\9\9\9result = unicode.sub(wrappedLines[i], 1, limit)\13\n\9\9\9\9else\13\n\9\9\9\9\9table.insert(wrappedLines, i + 1, unicode.sub(wrappedLines[i], unicode.len(result) + 1, -1))\9\13\n\9\9\9\9end\13\n\13\n\9\9\9\9break\9\13\n\9\9\9else\13\n\9\9\9\9result = preResult .. \" \"\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9wrappedLines[i] = result:gsub(\"%s+$\", \"\"):gsub(\"^%s+\", \"\")\13\n\13\n\9\9i = i + 1\13\n\9end\13\n\13\n\9return wrappedLines\13\nend\13\n\13\n----------------------------------------------------------------------------------------------------\13\n\13\nreturn {loaded = true}",["./libs/thirdParty/luaShell.lua"] = "--[[\13\n\9This is a fork of the OpenOS LUA shell included in OpenComputers.\13\n\9There are made some changes to fit into the NosGa Engine.\13\n\9\13\n\9Original source code repo: <https://github.com/MightyPirates/OpenComputers/tree/master-MC1.12>.\13\n\9NosGa Engine: <https://github.com/NosPo-Studio/NosGa-Engine>.\13\n\9\13\n\9OpenComputers Copyright (c) 2013-2015 Florian \"Sangar\" Ncke\13\n\9LUA shell (NosGa version) (c) 2019 NosPo Studio\13\n\13\n\9Permission is hereby granted, free of charge, to any person obtaining a copy\13\n\9of this software and associated documentation files (the \"Software\"), to deal\13\n\9in the Software without restriction, including without limitation the rights\13\n\9to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\n\9copies of the Software, and to permit persons to whom the Software is\13\n\9furnished to do so, subject to the following conditions:\13\n\9\13\n\9The above copyright notice and this permission notice shall be included in\13\n\9all copies or substantial portions of the Software.\13\n\9\13\n\9THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\n\9IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\n\9FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\n\9AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\n\9LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\n\9OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\13\n\9THE SOFTWARE.\9\13\n]]\13\n\13\nlocal global = ...\13\n\13\nlocal package = require(\"package\")\13\nlocal term = global.term\13\n\13\nlocal function optrequire(...)\13\n  local success, module = pcall(require, ...)\13\n  if success then\13\n    return module\13\n  end\13\nend\13\n\13\nlocal env -- forward declare for binding in metamethod\13\nenv = setmetatable({}, {\13\n  __index = function(_, k)\13\n    _ENV[k] = _ENV[k] or optrequire(k)\13\n    return _ENV[k]\13\n  end,\13\n  __pairs = function(t)\13\n    return function(_, key)\13\n      local k, v = next(t, key)\13\n      if not k and t == env then\13\n        t = _ENV\13\n        k, v = next(t)\13\n      end\13\n      if not k and t == _ENV then\13\n        t = package.loaded\13\n        k, v = next(t)\13\n      end\13\n      return k, v\13\n    end\13\n  end,\13\n})\13\nenv._PROMPT = tostring(env._PROMPT or \"\\27[32mlua> \\27[37m\")\13\n\13\nlocal function findTable(t, path)\13\n  if type(t) ~= \"table\" then return nil end\13\n  if not path or #path == 0 then return t end\13\n  local name = string.match(path, \"[^.]+\")\13\n  for k, v in pairs(t) do\13\n    if k == name then\13\n      return findTable(v, string.sub(path, #name + 2))\13\n    end\13\n  end\13\n  local mt = getmetatable(t)\13\n  if t == env then mt = {__index=_ENV} end\13\n  if mt then\13\n    return findTable(mt.__index, path)\13\n  end\13\n  return nil\13\nend\13\n\13\nlocal function findKeys(t, r, prefix, name)\13\n  if type(t) ~= \"table\" then return end\13\n  for k, v in pairs(t) do\13\n    if type(k) == \"string\" and string.match(k, \"^\"..name) then\13\n      local postfix = \"\"\13\n      if type(v) == \"function\" then postfix = \"()\"\13\n      elseif type(v) == \"table\" and getmetatable(v) and getmetatable(v).__call then postfix = \"()\"\13\n      elseif type(v) == \"table\" then postfix = \".\"\13\n      end\13\n      r[prefix..k..postfix] = true\13\n    end\13\n  end\13\n  local mt = getmetatable(t)\13\n  if t == env then mt = {__index=_ENV} end\13\n  if mt then\13\n    return findKeys(mt.__index, r, prefix, name)\13\n  end\13\nend\13\n\13\nlocal function readHandler(line, index)\13\n  line = (line or \"\")\13\n  local tail = line:sub(index)\13\n  line = line:sub(1, index - 1)\13\n  local path = string.match(line, \"[a-zA-Z_][a-zA-Z0-9_.]*$\")\13\n  if not path then return nil end\13\n  local suffix = string.match(path, \"[^.]+$\") or \"\"\13\n  local prefix = string.sub(path, 1, #path - #suffix)\13\n  local tbl = findTable(env, prefix)\13\n  if not tbl then return nil end\13\n  local keys = {}\13\n  local hints = {}\13\n  findKeys(tbl, keys, string.sub(line, 1, #line - #suffix), suffix)\13\n  for key in pairs(keys) do\13\n    table.insert(hints, key .. tail)\13\n  end\13\n  return hints\13\nend\13\n\13\nenv.global = global\13\nenv.print = function(...)\13\n\9local s = \"[LUA]: \" .. tostring(...)\13\n\9global.print(s)\13\nend\13\n\13\nlocal function textInput(text)\13\n  --global.log(env._PROMPT)\13\n  local command = text\13\n  if not command then -- eof\13\n    return\13\n  end\13\n  local code, reason\13\n  if string.sub(command, 1, 1) == \"=\" then\13\n    code, reason = load(\"return \" .. string.sub(command, 2), \"=stdin\", \"t\", env)\13\n  else\13\n    code, reason = load(\"return \" .. command, \"=stdin\", \"t\", env)\13\n    if not code then\13\n      code, reason = load(command, \"=stdin\", \"t\", env)\13\n    end\13\n  end\13\n  if code then\13\n    local result = table.pack(xpcall(code, debug.traceback))\13\n    if not result[1] then\13\n      if type(result[2]) == \"table\" and result[2].reason == \"terminated\" then\13\n        global.fatal(result[2].code)\13\n      end\13\n      global.error(tostring(result[2]) .. \"\\n\")\13\n    else\13\n      local ok, why = pcall(function()\13\n        for i = 2, result.n do\13\n          global.print(\"[LUA]: \" .. require(\"serialization\").serialize(result[i], true) .. \"\\t\")\13\n        end\13\n      end)\13\n      if not ok then\13\n\9    if tostring(why) == \"too long without yielding\" then\13\n\9\9  global.error(\"table too big to serialize.\")\13\n\9\9else\13\n\9\9  global.error(\"crashed serializing result: \", tostring(why))\13\n\9\9end\13\n      end\13\n    end\13\n  else\13\n    global.error(tostring(reason) .. \"\\n\")\13\n  end\13\nend\13\n\13\nreturn {\13\n\9textInput = textInput,\13\n\9readHandler = readHandler,\13\n}",["./libs/thirdParty/image.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are possibly made some changes if needed to fit in to the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/Image>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nimage Copyright (c) 2018 Igor Timofeev\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\n\13\nlocal computer = require(\"computer\")\13\nlocal color = require(\"libs/thirdParty/color\")\13\nlocal unicode = require(\"unicode\")\13\nlocal fs = require(\"filesystem\")\13\nlocal gpu = require(\"component\").gpu\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nlocal image = {formatModules = {}}\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction image.getIndex(x, y, width)\13\n\9return width * (y - 1) + x\13\nend\13\n\13\nfunction image.group(picture, compressColors)\13\n\9local groupedPicture, x, y, background, foreground = {}, 1, 1\13\n\13\n\9for i = 1, #picture[3] do\13\n\9\9if compressColors then\13\n\9\9\9background, foreground = color.to8Bit(picture[3][i]), color.to8Bit(picture[4][i])\13\n\9\9\9if i % 603 == 0 then\13\n\9\9\9\9computer.pullSignal(0)\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9background, foreground = picture[3][i], picture[4][i]\13\n\9\9end\13\n\13\n\9\9groupedPicture[picture[5][i]] = groupedPicture[picture[5][i]] or {}\13\n\9\9groupedPicture[picture[5][i]][picture[6][i]] = groupedPicture[picture[5][i]][picture[6][i]] or {}\13\n\9\9groupedPicture[picture[5][i]][picture[6][i]][background] = groupedPicture[picture[5][i]][picture[6][i]][background] or {}\13\n\9\9groupedPicture[picture[5][i]][picture[6][i]][background][foreground] = groupedPicture[picture[5][i]][picture[6][i]][background][foreground] or {}\13\n\9\9groupedPicture[picture[5][i]][picture[6][i]][background][foreground][y] = groupedPicture[picture[5][i]][picture[6][i]][background][foreground][y] or {}\13\n\13\n\9\9table.insert(groupedPicture[picture[5][i]][picture[6][i]][background][foreground][y], x)\13\n\13\n\9\9x = x + 1\13\n\9\9if x > picture[1] then\13\n\9\9\9x, y = 1, y + 1\13\n\9\9end\13\n\9end\13\n\13\n\9return groupedPicture\13\nend\13\n\13\nfunction image.draw(x, y, picture)\13\n\9local groupedPicture = image.group(picture)\13\n\9local _, _, currentBackground, currentForeground, gpuGetBackground, imageX, imageY\13\n\13\n\9for alpha in pairs(groupedPicture) do\13\n\9\9for symbol in pairs(groupedPicture[alpha]) do\13\n\9\9\9\13\n\9\9\9if not (symbol == \" \" and alpha == 1) then\13\n\9\9\9\9for background in pairs(groupedPicture[alpha][symbol]) do\13\n\9\9\9\9\9\13\n\9\9\9\9\9if background ~= currentBackground then\13\n\9\9\9\9\9\9currentBackground = background\13\n\9\9\9\9\9\9gpu.setBackground(background)\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9for foreground in pairs(groupedPicture[alpha][symbol][background]) do\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if foreground ~= currentForeground and symbol ~= \" \" then\13\n\9\9\9\9\9\9\9currentForeground = foreground\13\n\9\9\9\9\9\9\9gpu.setForeground(foreground)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9for yPos in pairs(groupedPicture[alpha][symbol][background][foreground]) do\13\n\9\9\9\9\9\9\9for xPos = 1, #groupedPicture[alpha][symbol][background][foreground][yPos] do\13\n\9\9\9\9\9\9\9\9imageX, imageY = x + groupedPicture[alpha][symbol][background][foreground][yPos][xPos] - 1, y + yPos - 1\13\n\13\n\9\9\9\9\9\9\9\9if alpha > 0 then\13\n\9\9\9\9\9\9\9\9\9_, _, gpuGetBackground = gpu.get(imageX, imageY)\13\n\9\9\9\9\9\9\9\9\9\13\n\9\9\9\9\9\9\9\9\9if alpha == 1 then\13\n\9\9\9\9\9\9\9\9\9\9currentBackground = gpuGetBackground\13\n\9\9\9\9\9\9\9\9\9\9gpu.setBackground(currentBackground)\13\n\9\9\9\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9\9\9\9currentBackground = color.blend(gpuGetBackground, background, alpha)\13\n\9\9\9\9\9\9\9\9\9\9gpu.setBackground(currentBackground)\13\n\9\9\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\9\9end\13\n\13\n\9\9\9\9\9\9\9\9gpu.set(imageX, imageY, symbol)\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction image.create(width, height, background, foreground, alpha, symbol, random)\13\n\9local picture = {width, height, {}, {}, {}, {}}\13\n\13\n\9for i = 1, width * height do\13\n\9\9table.insert(picture[3], random and math.random(0x0, 0xFFFFFF) or (background or 0x0))\13\n\9\9table.insert(picture[4], random and math.random(0x0, 0xFFFFFF) or (foreground or 0x0))\13\n\9\9table.insert(picture[5], alpha or 0x0)\13\n\9\9table.insert(picture[6], random and string.char(math.random(65, 90)) or (symbol or \" \"))\13\n\9end\13\n\13\n\9return picture\13\nend\13\n\13\nfunction image.copy(picture)\13\n\9local newPicture = {picture[1], picture[2], {}, {}, {}, {}}\13\n\9\13\n\9for i = 1, #picture[3] do\13\n\9\9newPicture[3][i] = picture[3][i]\13\n\9\9newPicture[4][i] = picture[4][i]\13\n\9\9newPicture[5][i] = picture[5][i]\13\n\9\9newPicture[6][i] = picture[6][i]\13\n\9end\13\n\13\n\9return newPicture\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction image.loadFormatModule(path, extension)\13\n\9local success, result = loadfile(path)\13\n\9if success then\13\n\9\9success, result = pcall(success, image)\13\n\9\9if success then\13\n\9\9\9image.formatModules[extension] = result\13\n\9\9else\13\n\9\9\9error(\"Failed to execute image format module: \" .. tostring(result))\13\n\9\9end\13\n\9else\13\n\9\9error(\"Failed to load image format module: \" .. tostring(result))\13\n\9end\13\nend\13\n\13\nlocal function loadOrSave(methodName, path, ...)\13\n\9local extension = fs.extension(path)\13\n\9if image.formatModules[extension] then\13\n\9\9local success, result = pcall(image.formatModules[extension][methodName], path, ...)\13\n\9\9if success then\13\n\9\9\9return result\13\n\9\9else\13\n\9\9\9return false, \"Failed to \" .. methodName .. \" image file: \" .. tostring(result)\13\n\9\9end\13\n\9else\13\n\9\9return false, \"Failed to \" .. methodName .. \" image file: format module for extension \\\"\" .. tostring(extension) .. \"\\\" is not loaded\"\13\n\9end\13\nend\13\n\13\nfunction image.save(path, picture, encodingMethod)\13\n\9return loadOrSave(\"save\", path, picture, encodingMethod)\13\nend\13\n\13\nfunction image.load(path)\13\n\9return loadOrSave(\"load\", path)\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction image.toString(picture)\13\n\9local charArray = {\13\n\9\9string.format(\"%02X\", picture[1]),\13\n\9\9string.format(\"%02X\", picture[2])\13\n\9}\13\n\9\13\n\9for i = 1, #picture[3] do\13\n\9\9table.insert(charArray, string.format(\"%02X\", color.to8Bit(picture[3][i])))\13\n\9\9table.insert(charArray, string.format(\"%02X\", color.to8Bit(picture[4][i])))\13\n\9\9table.insert(charArray, string.format(\"%02X\", math.floor(picture[5][i] * 255)))\13\n\9\9table.insert(charArray, picture[6][i])\13\n\13\n\9\9if i % 603 == 0 then\13\n\9\9\9computer.pullSignal(0)\13\n\9\9end\13\n\9end\13\n\13\n\9return table.concat(charArray)\13\nend\13\n\13\nfunction image.fromString(pictureString)\13\n\9local picture = {\13\n\9\9tonumber(\"0x\" .. unicode.sub(pictureString, 1, 2)),\13\n\9\9tonumber(\"0x\" .. unicode.sub(pictureString, 3, 4)),\13\n\9\9{}, {}, {}, {}\13\n\9}\13\n\13\n\9for i = 5, unicode.len(pictureString), 7 do\13\n\9\9table.insert(picture[3], color.to24Bit(tonumber(\"0x\" .. unicode.sub(pictureString, i, i + 1))))\13\n\9\9table.insert(picture[4], color.to24Bit(tonumber(\"0x\" .. unicode.sub(pictureString, i + 2, i + 3))))\13\n\9\9table.insert(picture[5], tonumber(\"0x\" .. unicode.sub(pictureString, i + 4, i + 5)) / 255)\13\n\9\9table.insert(picture[6], unicode.sub(pictureString, i + 6, i + 6))\13\n\9end\13\n\13\n\9return picture\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nfunction image.set(picture, x, y, background, foreground, alpha, symbol)\13\n\9local index = image.getIndex(x, y, picture[1])\13\n\9picture[3][index], picture[4][index], picture[5][index], picture[6][index] = background, foreground, alpha, symbol\13\n\13\n\9return picture\13\nend\13\n\13\nfunction image.get(picture, x, y)\13\n\9local index = image.getIndex(x, y, picture[1])\13\n\9return picture[3][index], picture[4][index], picture[5][index], picture[6][index]\13\nend\13\n\13\nfunction image.getSize(picture)\13\n\9return picture[1], picture[2]\13\nend\13\n\13\nfunction image.getWidth(picture)\13\n\9return picture[1]\13\nend\13\n\13\nfunction image.getHeight(picture)\13\n\9return picture[2]\13\nend\13\n\13\nfunction image.transform(picture, newWidth, newHeight)\13\n\9local newPicture, stepWidth, stepHeight, background, foreground, alpha, symbol = {newWidth, newHeight, {}, {}, {}, {}}, picture[1] / newWidth, picture[2] / newHeight\13\n\9\13\n\9local x, y = 1, 1\13\n\9for j = 1, newHeight do\13\n\9\9for i = 1, newWidth do\13\n\9\9\9background, foreground, alpha, symbol = image.get(picture, math.floor(x), math.floor(y))\13\n\9\9\9table.insert(newPicture[3], background)\13\n\9\9\9table.insert(newPicture[4], foreground)\13\n\9\9\9table.insert(newPicture[5], alpha)\13\n\9\9\9table.insert(newPicture[6], symbol)\13\n\13\n\9\9\9x = x + stepWidth\13\n\9\9end\13\n\13\n\9\9x, y = 1, y + stepHeight\13\n\9end\13\n\13\n\9return newPicture\13\nend\13\n\13\nfunction image.crop(picture, fromX, fromY, width, height)\13\n\9if fromX >= 1 and fromY >= 1 and fromX + width - 1 <= picture[1] and fromY + height - 1 <= picture[2] then\13\n\9\9local newPicture, background, foreground, alpha, symbol = {width, height, {}, {}, {}, {}}\13\n\9\9\13\n\9\9for y = fromY, fromY + height - 1 do\13\n\9\9\9for x = fromX, fromX + width - 1 do\13\n\9\9\9\9background, foreground, alpha, symbol = image.get(picture, x, y)\13\n\9\9\9\9table.insert(newPicture[3], background)\13\n\9\9\9\9table.insert(newPicture[4], foreground)\13\n\9\9\9\9table.insert(newPicture[5], alpha)\13\n\9\9\9\9table.insert(newPicture[6], symbol)\13\n\9\9\9end\13\n\9\9end\13\n\13\n\9\9return newPicture\13\n\9else\13\n\9\9return false, \"Failed to crop image: target coordinates are out of source range\"\13\n\9end\13\nend\13\n\13\nfunction image.flipHorizontally(picture)\13\n\9local newPicture, background, foreground, alpha, symbol = {picture[1], picture[2], {}, {}, {}, {}}\13\n\9\13\n\9for y = 1, picture[2] do\13\n\9\9for x = picture[1], 1, -1 do\13\n\9\9\9background, foreground, alpha, symbol = image.get(picture, x, y)\13\n\9\9\9table.insert(newPicture[3], background)\13\n\9\9\9table.insert(newPicture[4], foreground)\13\n\9\9\9table.insert(newPicture[5], alpha)\13\n\9\9\9table.insert(newPicture[6], symbol)\13\n\9\9end\13\n\9end\13\n\13\n\9return newPicture\13\nend\13\n\13\nfunction image.flipVertically(picture)\13\n\9local newPicture, background, foreground, alpha, symbol = {picture[1], picture[2], {}, {}, {}, {}}\13\n\9\13\n\9for y = picture[2], 1, -1 do\13\n\9\9for x = 1, picture[1] do\13\n\9\9\9background, foreground, alpha, symbol = image.get(picture, x, y)\13\n\9\9\9table.insert(newPicture[3], background)\13\n\9\9\9table.insert(newPicture[4], foreground)\13\n\9\9\9table.insert(newPicture[5], alpha)\13\n\9\9\9table.insert(newPicture[6], symbol)\13\n\9\9end\13\n\9end\13\n\13\n\9return newPicture\13\nend\13\n\13\nfunction image.expand(picture, fromTop, fromBottom, fromLeft, fromRight, background, foreground, alpha, symbol)\13\n\9local newPicture = image.create(picture[1] + fromRight + fromLeft, picture[2] + fromTop + fromBottom, background, foreground, alpha, symbol)\13\n\13\n\9for y = 1, picture[2] do\13\n\9\9for x = 1, picture[1] do\13\n\9\9\9image.set(newPicture, x + fromLeft, y + fromTop, image.get(picture, x, y))\13\n\9\9end\13\n\9end\13\n\13\n\9return newPicture\13\nend\13\n\13\nfunction image.blend(picture, blendColor, transparency)\13\n\9local newPicture = {picture[1], picture[2], {}, {}, {}, {}}\13\n\13\n\9for i = 1, #picture[3] do\13\n\9\9table.insert(newPicture[3], color.blend(picture[3][i], blendColor, transparency))\13\n\9\9table.insert(newPicture[4], color.blend(picture[4][i], blendColor, transparency))\13\n\9\9table.insert(newPicture[5], picture[5][i])\13\n\9\9table.insert(newPicture[6], picture[6][i])\13\n\9end\13\n\13\n\9return newPicture\13\nend\13\n\13\nfunction image.rotate(picture, angle)\13\n\9local radAngle = math.rad(angle)\13\n\9local sin, cos = math.sin(radAngle), math.cos(radAngle)\13\n\9local pixMap = {}\13\n\13\n\9local xCenter, yCenter = picture[1] / 2, picture[2] / 2\13\n\9local xMin, xMax, yMin, yMax = math.huge, -math.huge, math.huge, -math.huge\13\n\9for y = 1, picture[2] do\13\n\9\9for x = 1, picture[1] do\13\n\9\9\9local xNew = math.round(xCenter + (x - xCenter) * cos - (y - yCenter) * sin)\13\n\9\9\9local yNew = math.round(yCenter + (y - yCenter) * cos + (x - xCenter) * sin)\13\n\13\n\9\9\9xMin, xMax, yMin, yMax = math.min(xMin, xNew), math.max(xMax, xNew), math.min(yMin, yNew), math.max(yMax, yNew)\13\n\13\n\9\9\9pixMap[yNew] = pixMap[yNew] or {}\13\n\9\9\9pixMap[yNew][xNew] = {image.get(picture, x, y)}\13\n\9\9end\13\n\9end\13\n\13\n\9local newPicture = image.create(xMax - xMin + 1, yMax - yMin + 1, 0xFF0000, 0x0, 0x0, \"#\")\13\n\9for y in pairs(pixMap) do\13\n\9\9for x in pairs(pixMap[y]) do\13\n\9\9\9image.set(newPicture, x - xMin + 1, y - yMin + 1, pixMap[y][x][1], pixMap[y][x][2], pixMap[y][x][3], pixMap[y][x][4])\13\n\9\9end\13\n\9end\13\n\13\n\9return newPicture\13\nend\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nimage.loadFormatModule(\"libs/thirdParty/OCIF.lua\", \".pic\")\13\n\13\n-------------------------------------------------------------------------------\13\n\13\nreturn image",["./libs/thirdParty/GUI.lua"] = "local global = _G.ngeGlobal\n\nrequire(\"libs/thirdParty/AdvancedLua\")\nlocal component = require(\"component\")\nlocal computer = require(\"computer\")\nlocal keyboard = require(\"keyboard\")\nlocal filesystem = require(\"filesystem\")\nlocal unicode = require(\"unicode\")\nlocal event = require(\"event\")\nlocal color = require(\"libs/thirdParty/color\")\nlocal image = require(\"libs/thirdParty/image\")\nlocal buffer = global.db\n\n-----------------------------------------------------------------------------------------\n\nlocal GUI = {\n\9ALIGNMENT_HORIZONTAL_LEFT = 1,\n\9ALIGNMENT_HORIZONTAL_CENTER = 2,\n\9ALIGNMENT_HORIZONTAL_RIGHT = 3,\n\9ALIGNMENT_VERTICAL_TOP = 4,\n\9ALIGNMENT_VERTICAL_CENTER = 5,\n\9ALIGNMENT_VERTICAL_BOTTOM = 6,\n\n\9DIRECTION_HORIZONTAL = 7,\n\9DIRECTION_VERTICAL = 8,\n\n\9SIZE_POLICY_ABSOLUTE = 9,\n\9SIZE_POLICY_RELATIVE = 10,\n\n\9IO_MODE_FILE = 11,\n\9IO_MODE_DIRECTORY = 12,\n\9IO_MODE_BOTH = 13,\n\9IO_MODE_OPEN = 14,\n\9IO_MODE_SAVE = 15,\n\n\9BUTTON_PRESS_DURATION = 0.2,\n\9BUTTON_ANIMATION_DURATION = 0.2,\n\9SWITCH_ANIMATION_DURATION = 0.3,\n\9FILESYSTEM_DIALOG_ANIMATION_DURATION = 0.5,\n\9\n\9CONTEXT_MENU_SEPARATOR_COLOR = 0x878787,\n\9CONTEXT_MENU_DEFAULT_TEXT_COLOR = 0x2D2D2D,\n\9CONTEXT_MENU_DEFAULT_BACKGROUND_COLOR = 0xFFFFFF,\n\9CONTEXT_MENU_PRESSED_BACKGROUND_COLOR = 0x3366CC,\n\9CONTEXT_MENU_PRESSED_TEXT_COLOR = 0xFFFFFF,\n\9CONTEXT_MENU_DISABLED_COLOR = 0x878787,\n\9CONTEXT_MENU_BACKGROUND_TRANSPARENCY = 0.18,\n\9CONTEXT_MENU_SHADOW_TRANSPARENCY = 0.4,\n\n\9BACKGROUND_CONTAINER_PANEL_COLOR = 0x0,\n\9BACKGROUND_CONTAINER_TITLE_COLOR = 0xE1E1E1,\n\9BACKGROUND_CONTAINER_PANEL_TRANSPARENCY = 0.3,\n\n\9WINDOW_BACKGROUND_PANEL_COLOR = 0xF0F0F0,\n\9WINDOW_SHADOW_TRANSPARENCY = 0.6,\n\9WINDOW_TITLE_BACKGROUND_COLOR = 0xE1E1E1,\n\9WINDOW_TITLE_TEXT_COLOR = 0x2D2D2D,\n\9WINDOW_TAB_BAR_DEFAULT_BACKGROUND_COLOR = 0x2D2D2D,\n\9WINDOW_TAB_BAR_DEFAULT_TEXT_COLOR = 0xF0F0F0,\n\9WINDOW_TAB_BAR_SELECTED_BACKGROUND_COLOR = 0xF0F0F0,\n\9WINDOW_TAB_BAR_SELECTED_TEXT_COLOR = 0x2D2D2D,\n\n\9PALETTE_CONFIG_PATH = filesystem.path(getCurrentScript()) .. \".palette.cfg\",\n\n\9LUA_SYNTAX_COLOR_SCHEME = {\n\9\9background = 0x1E1E1E,\n\9\9text = 0xE1E1E1,\n\9\9strings = 0x99FF80,\n\9\9loops = 0xFFFF98,\n\9\9comments = 0x898989,\n\9\9boolean = 0xFFDB40,\n\9\9logic = 0xFFCC66,\n\9\9numbers = 0x66DBFF,\n\9\9functions = 0xFFCC66,\n\9\9compares = 0xFFCC66,\n\9\9lineNumbersBackground = 0x2D2D2D,\n\9\9lineNumbersText = 0xC3C3C3,\n\9\9scrollBarBackground = 0x2D2D2D,\n\9\9scrollBarForeground = 0x5A5A5A,\n\9\9selection = 0x4B4B4B,\n\9\9indentation = 0x2D2D2D\n\9},\n\n\9LUA_SYNTAX_PATTERNS = {\n\9\9\"[%.%,%>%<%=%~%+%-%*%/%^%#%%%&]\", \"compares\", 0, 0,\n\9\9\"[^%a%d][%.%d]+[^%a%d]\", \"numbers\", 1, 1,\n\9\9\"[^%a%d][%.%d]+$\", \"numbers\", 1, 0,\n\9\9\"0x%w+\", \"numbers\", 0, 0,\n\9\9\" not \", \"logic\", 0, 1,\n\9\9\" or \", \"logic\", 0, 1,\n\9\9\" and \", \"logic\", 0, 1,\n\9\9\"function%(\", \"functions\", 0, 1,\n\9\9\"function%s[^%s%(%)%{%}%[%]]+%(\", \"functions\", 9, 1,\n\9\9\"nil\", \"boolean\", 0, 0,\n\9\9\"false\", \"boolean\", 0, 0,\n\9\9\"true\", \"boolean\", 0, 0,\n\9\9\" break$\", \"loops\", 0, 0,\n\9\9\"elseif \", \"loops\", 0, 1,\n\9\9\"else[%s%;]\", \"loops\", 0, 1,\n\9\9\"else$\", \"loops\", 0, 0,\n\9\9\"function \", \"loops\", 0, 1,\n\9\9\"local \", \"loops\", 0, 1,\n\9\9\"return\", \"loops\", 0, 0,\n\9\9\"until \", \"loops\", 0, 1,\n\9\9\"then\", \"loops\", 0, 0,\n\9\9\"if \", \"loops\", 0, 1,\n\9\9\"repeat$\", \"loops\", 0, 0,\n\9\9\" in \", \"loops\", 0, 1,\n\9\9\"for \", \"loops\", 0, 1,\n\9\9\"end[%s%;]\", \"loops\", 0, 1,\n\9\9\"end$\", \"loops\", 0, 0,\n\9\9\"do \", \"loops\", 0, 1,\n\9\9\"do$\", \"loops\", 0, 0,\n\9\9\"while \", \"loops\", 0, 1,\n\9\9\"\\'[^\\']+\\'\", \"strings\", 0, 0,\n\9\9\"\\\"[^\\\"]+\\\"\", \"strings\", 0, 0,\n\9\9\"%-%-.+\", \"comments\", 0, 0,\n\9},\n}\n\n--------------------------------------------------------------------------------\n\nfunction GUI.setAlignment(object, horizontalAlignment, verticalAlignment)\n\9object.horizontalAlignment, object.verticalAlignment = horizontalAlignment, verticalAlignment\n\9\n\9return object\nend\n\nfunction GUI.getAlignmentCoordinates(x, y, width1, height1, horizontalAlignment, verticalAlignment, width2, height2)\n\9if horizontalAlignment == GUI.ALIGNMENT_HORIZONTAL_CENTER then\n\9\9x = x + width1 / 2 - width2 / 2\n\9elseif horizontalAlignment == GUI.ALIGNMENT_HORIZONTAL_RIGHT then\n\9\9x = x + width1 - width2\n\9elseif horizontalAlignment ~= GUI.ALIGNMENT_HORIZONTAL_LEFT then\n\9\9error(\"Unknown horizontal alignment: \" .. tostring(horizontalAlignment))\n\9end\n\n\9if verticalAlignment == GUI.ALIGNMENT_VERTICAL_CENTER then\n\9\9y = y + height1 / 2 - height2 / 2\n\9elseif verticalAlignment == GUI.ALIGNMENT_VERTICAL_BOTTOM then\n\9\9y = y + height1 - height2\n\9elseif verticalAlignment ~= GUI.ALIGNMENT_VERTICAL_TOP then\n\9\9error(\"Unknown vertical alignment: \" .. tostring(verticalAlignment))\n\9end\n\n\9return x, y\nend\n\nfunction GUI.getMarginCoordinates(x, y, horizontalAlignment, verticalAlignment, horizontalMargin, verticalMargin)\n\9if horizontalAlignment == GUI.ALIGNMENT_HORIZONTAL_RIGHT then\n\9\9x = x - horizontalMargin\n\9else\n\9\9x = x + horizontalMargin\n\9end\n\9\n\9if verticalAlignment == GUI.ALIGNMENT_VERTICAL_BOTTOM then\n\9\9y = y - verticalMargin\n\9else\n\9\9y = y + verticalMargin\n\9end\n\n\9return x, y\nend\n\n--------------------------------------------------------------------------------\n\nlocal function objectDraw(object)\n\9return object\nend\n\nfunction GUI.object(x, y, width, height)\n\9return {\n\9\9x = x,\n\9\9y = y,\n\9\9width = width,\n\9\9height = height,\n\9\9draw = objectDraw\n\9}\nend\n\n--------------------------------------------------------------------------------\n\nlocal function containerObjectIndexOf(object)\n\9if not object.parent then error(\"Object doesn't have a parent container\") end\n\n\9for objectIndex = 1, #object.parent.children do\n\9\9if object.parent.children[objectIndex] == object then\n\9\9\9return objectIndex\n\9\9end\n\9end\nend\n\nlocal function containerObjectMoveForward(object)\n\9local objectIndex = containerObjectIndexOf(object)\n\9if objectIndex < #object.parent.children then\n\9\9object.parent.children[index], object.parent.children[index + 1] = object.parent.children[index + 1], object.parent.children[index]\n\9end\n\9\n\9return object\nend\n\nlocal function containerObjectMoveBackward(object)\n\9local objectIndex = containerObjectIndexOf(object)\n\9if objectIndex > 1 then\n\9\9object.parent.children[objectIndex], object.parent.children[objectIndex - 1] = object.parent.children[objectIndex - 1], object.parent.children[objectIndex]\n\9end\n\9\n\9return object\nend\n\nlocal function containerObjectMoveToFront(object)\n\9table.remove(object.parent.children, containerObjectIndexOf(object))\n\9table.insert(object.parent.children, object)\n\9\n\9return object\nend\n\nlocal function containerObjectMoveToBack(object)\n\9table.remove(object.parent.children, containerObjectIndexOf(object))\n\9table.insert(object.parent.children, 1, object)\n\9\n\9return object\nend\n\nlocal function containerObjectRemove(object)\n\9table.remove(object.parent.children, containerObjectIndexOf(object))\nend\n\nlocal function containerObjectAnimationStart(animation, duration)\n\9animation.position = 0\n\9animation.duration = duration\n\9animation.started = true\n\9animation.startUptime = computer.uptime()\n\n\9computer.pushSignal(\"GUI\", \"animationStarted\")\nend\n\nlocal function containerObjectAnimationStop(animation)\n\9animation.position = 0\n\9animation.started = false\nend\n\nlocal function containerObjectAnimationRemove(animation)\n\9animation.removeLater = true\nend\n\nlocal function containerObjectAddAnimation(object, frameHandler, onFinish)\n\9local animation = {\n\9\9object = object,\n\9\9position = 0,\n\9\9start = containerObjectAnimationStart,\n\9\9stop = containerObjectAnimationStop,\n\9\9remove = containerObjectAnimationRemove,\n\9\9frameHandler = frameHandler,\n\9\9onFinish = onFinish,\n\9}\n\n\9object.firstParent.animations = object.firstParent.animations or {}\n\9table.insert(object.firstParent.animations, animation)\n\n\9return animation\nend\n\nlocal function containerAddChild(container, object, atIndex)\n\9object.localX = object.x\n\9object.localY = object.y\n\9object.indexOf = containerObjectIndexOf\n\9object.moveToFront = containerObjectMoveToFront\n\9object.moveToBack = containerObjectMoveToBack\n\9object.moveForward = containerObjectMoveForward\n\9object.moveBackward = containerObjectMoveBackward\n\9object.remove = containerObjectRemove\n\9object.addAnimation = containerObjectAddAnimation\n\n\9local function updateFirstParent(object, firstParent)\n\9\9object.firstParent = firstParent\n\9\9if object.children then\n\9\9\9for i = 1, #object.children do\n\9\9\9\9updateFirstParent(object.children[i], firstParent)\n\9\9\9end\n\9\9end\n\9end\n\n\9object.parent = container\n\9updateFirstParent(object, container.firstParent or container)\n\n\9if atIndex then\n\9\9table.insert(container.children, atIndex, object)\n\9else\n\9\9table.insert(container.children, object)\n\9end\n\9\n\9return object\nend\n\nlocal function containerRemoveChildren(container, from, to)\n\9from = from or 1\n\9for objectIndex = from, to or #container.children do\n\9\9table.remove(container.children, from)\n\9end\nend\n\nlocal function getRectangleIntersection(R1X1, R1Y1, R1X2, R1Y2, R2X1, R2Y1, R2X2, R2Y2)\n\9if R2X1 <= R1X2 and R2Y1 <= R1Y2 and R2X2 >= R1X1 and R2Y2 >= R1Y1 then\n\9\9return\n\9\9\9math.max(R2X1, R1X1),\n\9\9\9math.max(R2Y1, R1Y1),\n\9\9\9math.min(R2X2, R1X2),\n\9\9\9math.min(R2Y2, R1Y2)\n\9else\n\9\9return\n\9end\nend\n\nfunction containerDraw(container)\n\9local R1X1, R1Y1, R1X2, R1Y2, child = buffer.getDrawLimit()\n\9local intersectionX1, intersectionY1, intersectionX2, intersectionY2 = getRectangleIntersection(\n\9\9R1X1,\n\9\9R1Y1,\n\9\9R1X2,\n\9\9R1Y2,\n\9\9container.x,\n\9\9container.y,\n\9\9container.x + container.width - 1,\n\9\9container.y + container.height - 1\n\9)\n\n\9if intersectionX1 then\n\9\9buffer.setDrawLimit(intersectionX1, intersectionY1, intersectionX2, intersectionY2)\n\9\9\n\9\9for i = 1, #container.children do\n\9\9\9child = container.children[i]\n\9\9\9\n\9\9\9if not child.hidden then\n\9\9\9\9child.x, child.y = container.x + child.localX - 1, container.y + child.localY - 1\n\9\9\9\9child:draw()\n\9\9\9end\n\9\9end\n\n\9\9buffer.setDrawLimit(R1X1, R1Y1, R1X2, R1Y2)\n\9end\n\n\9return container\nend\n\nfunction GUI.container(x, y, width, height)\n\9local container = GUI.object(x, y, width, height)\n\n\9container.children = {}\n\9container.passScreenEvents = true\n\9\n\9container.draw = containerDraw\n\9container.removeChildren = containerRemoveChildren\n\9container.addChild = containerAddChild\n\9\n\9return container\nend\n\nfunction GUI.fullScreenContainer()\n\9return GUI.container(1, 1, buffer.getResolution())\nend\n\n--------------------------------------------------------------------------------\n\nlocal function applicationStart(application, eventPullTimeout)\n\9local animation, animationIndex, animationOnFinishMethodsIndex, animationOnFinishMethods, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32\n\9\n\9local function handle(isScreenEvent, currentContainer, intersectionX1, intersectionY1, intersectionX2, intersectionY2)\n\9\9if\n\9\9\9not isScreenEvent or\n\9\9\9intersectionX1 and\n\9\9\9e3 >= intersectionX1 and\n\9\9\9e3 <= intersectionX2 and\n\9\9\9e4 >= intersectionY1 and\n\9\9\9e4 <= intersectionY2\n\9\9then\n\9\9\9local currentContainerPassed, child, newIntersectionX1, newIntersectionY1, newIntersectionX2, newIntersectionY2\n\n\9\9\9if isScreenEvent then\n\9\9\9\9if currentContainer.eventHandler and not currentContainer.disabled then\n\9\9\9\9\9currentContainer.eventHandler(application, currentContainer, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32)\n\9\9\9\9end\n\n\9\9\9\9currentContainerPassed = not currentContainer.passScreenEvents\n\9\9\9elseif currentContainer.eventHandler then\n\9\9\9\9currentContainer.eventHandler(application, currentContainer, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32)\n\9\9\9end\n\n\9\9\9for i = #currentContainer.children, 1, -1 do\n\9\9\9\9child = currentContainer.children[i]\n\n\9\9\9\9if not child.hidden then\n\9\9\9\9\9if child.children then\n\9\9\9\9\9\9newIntersectionX1, newIntersectionY1, newIntersectionX2, newIntersectionY2 = getRectangleIntersection(\n\9\9\9\9\9\9\9intersectionX1,\n\9\9\9\9\9\9\9intersectionY1,\n\9\9\9\9\9\9\9intersectionX2,\n\9\9\9\9\9\9\9intersectionY2,\n\9\9\9\9\9\9\9child.x,\n\9\9\9\9\9\9\9child.y,\n\9\9\9\9\9\9\9child.x + child.width - 1,\n\9\9\9\9\9\9\9child.y + child.height - 1\n\9\9\9\9\9\9)\n\n\9\9\9\9\9\9if \n\9\9\9\9\9\9\9newIntersectionX1 and\n\9\9\9\9\9\9\9handle(\n\9\9\9\9\9\9\9\9isScreenEvent,\n\9\9\9\9\9\9\9\9child,\n\9\9\9\9\9\9\9\9newIntersectionX1,\n\9\9\9\9\9\9\9\9newIntersectionY1,\n\9\9\9\9\9\9\9\9newIntersectionX2,\n\9\9\9\9\9\9\9\9newIntersectionY2,\n\9\9\9\9\9\9\9\9e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32\n\9\9\9\9\9\9\9)\n\9\9\9\9\9\9then\n\9\9\9\9\9\9\9return true\n\9\9\9\9\9\9end\n\9\9\9\9\9else\n\9\9\9\9\9\9if application.needConsume then\n\9\9\9\9\9\9\9application.needConsume = nil\n\9\9\9\9\9\9\9return true\n\9\9\9\9\9\9end\n\n\9\9\9\9\9\9if isScreenEvent then\n\9\9\9\9\9\9\9if \n\9\9\9\9\9\9\9\9e3 >= child.x and\n\9\9\9\9\9\9\9\9e3 <= child.x + child.width - 1 and\n\9\9\9\9\9\9\9\9e4 >= child.y and\n\9\9\9\9\9\9\9\9e4 <= child.y + child.height - 1\n\9\9\9\9\9\9\9then\n\9\9\9\9\9\9\9\9if child.eventHandler and not child.disabled then\n\9\9\9\9\9\9\9\9\9child.eventHandler(application, child, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32)\n\9\9\9\9\9\9\9\9end\n\n\9\9\9\9\9\9\9\9if not child.passScreenEvents then\n\9\9\9\9\9\9\9\9\9return true\n\9\9\9\9\9\9\9\9end\n\9\9\9\9\9\9\9end\n\9\9\9\9\9\9elseif child.eventHandler then\n\9\9\9\9\9\9\9child.eventHandler(application, child, e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32)\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9if currentContainerPassed then\n\9\9\9\9return true\n\9\9\9end\n\9\9end\n\9end\n\n\9application.eventPullTimeout = eventPullTimeout\n\n\9repeat\n\9\9e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, e13, e14, e15, e16, e17, e18, e19, e20, e21, e22, e23, e24, e25, e26, e27, e28, e29, e30, e31, e32 = coroutine.yield()\n\n\9\9handle(\n\9\9\9e1 == \"touch\" or\n\9\9\9e1 == \"drag\" or\n\9\9\9e1 == \"drop\" or\n\9\9\9e1 == \"scroll\" or\n\9\9\9e1 == \"double_touch\",\n\9\9\9application,\n\9\9\9application.x,\n\9\9\9application.y,\n\9\9\9application.x + application.width - 1,\n\9\9\9application.y + application.height - 1\n\9\9)\n\n\9\9if application.animations then\n\9\9\9animationIndex, animationOnFinishMethodsIndex, animationOnFinishMethods = 1, 1, {}\n\9\9\9--      \n\9\9\9while animationIndex <= #application.animations do\n\9\9\9\9animation = application.animations[animationIndex]\n\n\9\9\9\9if animation.removeLater then\n\9\9\9\9\9table.remove(application.animations, animationIndex)\n\n\9\9\9\9\9if #application.animations == 0 then\n\9\9\9\9\9\9application.animations = nil\n\9\9\9\9\9\9break\n\9\9\9\9\9end\n\9\9\9\9else\n\9\9\9\9\9if animation.started then\n\9\9\9\9\9\9animation.position = (computer.uptime() - animation.startUptime) / animation.duration\n\9\9\9\9\9\9\n\9\9\9\9\9\9if animation.position < 1 then\n\9\9\9\9\9\9\9animation.frameHandler(animation)\n\9\9\9\9\9\9else\n\9\9\9\9\9\9\9animation.position, animation.started = 1, false\n\9\9\9\9\9\9\9animation.frameHandler(animation)\n\9\9\9\9\9\9\9\n\9\9\9\9\9\9\9animationOnFinishMethods[animationOnFinishMethodsIndex] = animation\n\9\9\9\9\9\9\9animationOnFinishMethodsIndex = animationOnFinishMethodsIndex + 1\n\9\9\9\9\9\9end\n\9\9\9\9\9end\n\n\9\9\9\9\9animationIndex = animationIndex + 1\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9--       \n\9\9\9--application:draw()\n\n\9\9\9--     .onFinish\n\9\9\9for i = 1, #animationOnFinishMethods do\n\9\9\9\9animationOnFinishMethods[i].onFinish(animationOnFinishMethods[i])\n\9\9\9end\n\9\9end\n\9until application.needClose\n\n\9application.needClose = nil\nend\n\nlocal function applicationStop(application)\n\9application.needClose = true\n\9global.core.uiHandler.ignoreApplication(application)\nend\n\nlocal function applicationConsumeEvent(application)\n\9application.needConsume = true\nend\n\nlocal function applicationDraw(object, ...)\n\9containerDraw(object)\n\9--buffer.drawChanges(...)\nend\n\nfunction GUI.application(x, y, width, height)\n\9local application = GUI.container(x or 1, y or 1, width or buffer.getWidth(), height or buffer.getHeight())\n\9\n\9application.draw = applicationDraw\n\9application.stop = applicationStop\n\9application.consumeEvent = applicationConsumeEvent\n\n\9application.coroutine = coroutine.create(applicationStart)\n\n\9application.start = function()\n\9\9coroutine.resume(application.coroutine, application, nil)\n\9\9global.core.uiHandler.listApplication(application)\n\9end\n\n\9return application\nend\n\n--------------------------------------------------------------------------------\n\nlocal function pressableDraw(pressable)\n\9local background = pressable.pressed and pressable.colors.pressed.background or pressable.disabled and pressable.colors.disabled.background or pressable.colors.default.background\n\9local text = pressable.pressed and pressable.colors.pressed.text or pressable.disabled and pressable.colors.disabled.text or pressable.colors.default.text\n\n\9if background then\n\9\9buffer.drawRectangle(pressable.x, pressable.y, pressable.width, pressable.height, background, text, \" \")\n\9end\n\9buffer.drawText(math.floor(pressable.x + pressable.width / 2 - unicode.len(pressable.text) / 2), math.floor(pressable.y + pressable.height / 2), text, pressable.text)\nend\n\nlocal function pressableHandlePress(application, pressable, ...)\n\9pressable.pressed = not pressable.pressed\n\9--application:draw()\n\n\9if not pressable.switchMode then\n\9\9pressable.pressed = not pressable.pressed\n\9\9os.sleep(GUI.BUTTON_PRESS_DURATION)\n\9\9\n\9\9--application:draw()\n\9end\n\n\9if pressable.onTouch then\n\9\9pressable.onTouch(application, pressable, ...)\n\9end\nend\n\nlocal function pressableEventHandler(application, pressable, e1, ...)\n\9if e1 == \"touch\" then\n\9\9pressableHandlePress(application, pressable, e1, ...)\n\9end\nend\n\nlocal function pressable(x, y, width, height, backgroundColor, textColor, backgroundPressedColor, textPressedColor, backgroundDisabledColor, textDisabledColor, text)\n\9local pressable = GUI.object(x, y, width, height)\n\n\9pressable.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9text = textColor\n\9\9},\n\9\9pressed = {\n\9\9\9background = backgroundPressedColor,\n\9\9\9text = textPressedColor\n\9\9},\n\9\9disabled = {\n\9\9\9background = backgroundDisabledColor,\n\9\9\9text = textDisabledColor\n\9\9}\n\9}\n\n\9pressable.pressed = false\n\9pressable.text = text\n\9pressable.draw = pressableDraw\n\9pressable.eventHandler = pressableEventHandler\n\n\9return pressable\nend\n\n--------------------------------------------------------------------------------\n\nlocal function buttonPlayAnimation(button, onFinish)\n\9button.animationStarted = true\n\9button:addAnimation(\n\9\9function(animation)\n\9\9\9if button.pressed then\n\9\9\9\9if button.colors.default.background and button.colors.pressed.background then\n\9\9\9\9\9button.animationCurrentBackground = color.transition(button.colors.pressed.background, button.colors.default.background, animation.position)\n\9\9\9\9end\n\9\9\9\9button.animationCurrentText = color.transition(button.colors.pressed.text, button.colors.default.text, animation.position)\n\9\9\9else\n\9\9\9\9if button.colors.default.background and button.colors.pressed.background then\n\9\9\9\9\9button.animationCurrentBackground = color.transition(button.colors.default.background, button.colors.pressed.background, animation.position)\n\9\9\9\9end\n\9\9\9\9button.animationCurrentText = color.transition(button.colors.default.text, button.colors.pressed.text, animation.position)\n\9\9\9end\n\9\9end,\n\9\9function(animation)\n\9\9\9button.animationStarted = false\n\9\9\9button.pressed = not button.pressed\n\9\9\9onFinish(animation)\n\9\9end\n\9):start(button.animationDuration)\nend\n\nlocal function buttonPress(button, application, object, ...)\n\9if button.animated then\n\9\9local eventData = {...}\n\9\9\n\9\9buttonPlayAnimation(button, function(animation)\n\9\9\9if button.onTouch then\n\9\9\9\9button.onTouch(application, button, table.unpack(eventData))\n\9\9\9end\n\n\9\9\9animation:remove()\n\n\9\9\9if not button.switchMode then\n\9\9\9\9buttonPlayAnimation(button, function(animation)\n\9\9\9\9\9animation:remove()\n\9\9\9\9end)\n\9\9\9end\n\9\9end)\n\9else\n\9\9pressableHandlePress(application, button, ...)\n\9end\nend\n\nlocal function buttonEventHandler(application, button, e1, ...)\n\9if e1 == \"touch\" and (not button.animated or not button.animationStarted) then\n\9\9button:press(application, button, e1, ...)\n\9end\nend\n\nlocal function buttonGetColors(button)\n\9if button.disabled then\n\9\9return button.colors.disabled.background, button.colors.disabled.text\n\9else\n\9\9if button.animated and button.animationStarted then\n\9\9\9return button.animationCurrentBackground, button.animationCurrentText\n\9\9else\n\9\9\9if button.pressed then\n\9\9\9\9return button.colors.pressed.background, button.colors.pressed.text\n\9\9\9else\n\9\9\9\9return button.colors.default.background, button.colors.default.text\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function buttonDrawText(button, textColor)\n\9buffer.drawText(math.floor(button.x + button.width / 2 - unicode.len(button.text) / 2), math.floor(button.y + button.height / 2), textColor, button.text)\nend\n\nlocal function buttonDraw(button)\n\9local backgroundColor, textColor = buttonGetColors(button)\n\9\n\9if backgroundColor then\n\9\9buffer.drawRectangle(button.x, button.y, button.width, button.height, backgroundColor, textColor, \" \", button.colors.transparency)\n\9end\n\9buttonDrawText(button, textColor)\nend\n\nlocal function framedButtonDraw(button)\n\9local backgroundColor, textColor = buttonGetColors(button)\n\9\n\9if backgroundColor then\n\9\9buffer.drawFrame(button.x, button.y, button.width, button.height, backgroundColor)\n\9end\n\9buttonDrawText(button, textColor)\nend\n\nlocal function roundedButtonDraw(button)\n\9local backgroundColor, textColor = buttonGetColors(button)\n\n\9if backgroundColor then\n\9\9local x2, y2 = button.x + button.width - 1, button.y + button.height - 1\n\9\9if button.height > 1 then\n\9\9\9buffer.drawText(button.x + 1, button.y, backgroundColor, string.rep(\"\", button.width - 2))\n\9\9\9buffer.drawText(button.x, button.y, backgroundColor, \"\")\n\9\9\9buffer.drawText(x2, button.y, backgroundColor, \"\")\n\9\9\9\n\9\9\9buffer.drawRectangle(button.x, button.y + 1, button.width, button.height - 2, backgroundColor, textColor, \" \")\n\9\9\9\n\9\9\9buffer.drawText(button.x + 1, y2, backgroundColor, string.rep(\"\", button.width - 2))\n\9\9\9buffer.drawText(button.x, y2, backgroundColor, \"\")\n\9\9\9buffer.drawText(x2, y2, backgroundColor, \"\")\n\9\9else\n\9\9\9buffer.drawRectangle(button.x, button.y, button.width, button.height, backgroundColor, textColor, \" \")\n\9\9\9GUI.roundedCorners(button.x, button.y, button.width, button.height, backgroundColor)\n\9\9end\n\9end\n\n\9buttonDrawText(button, textColor)\nend\n\nlocal function tagButtonDraw(button)\n\9local backgroundColor, textColor = buttonGetColors(button)\n\9\n\9buffer.drawRectangle(button.x, button.y, button.width, button.height, backgroundColor, textColor, \" \")\n\9buffer.drawText(button.x - 1, button.y, backgroundColor, \"\")\n\9buttonDrawText(button, textColor)\nend\n\nlocal function buttonCreate(x, y, width, height, backgroundColor, textColor, backgroundPressedColor, textPressedColor, text)\n\9local button = pressable(x, y, width, height, backgroundColor, textColor, backgroundPressedColor, textPressedColor, 0x878787, 0xA5A5A5, text)\n\n\9button.animationDuration = GUI.BUTTON_ANIMATION_DURATION\n\9button.animated = true\n\n\9button.animationCurrentBackground = backgroundColor\n\9button.animationCurrentText = textColor\n\9\n\9button.press = buttonPress\n\9button.eventHandler = buttonEventHandler\n\n\9return button\nend\n\nlocal function adaptiveButtonCreate(x, y, xOffset, yOffset, backgroundColor, textColor, backgroundPressedColor, textPressedColor, text)\n\9return buttonCreate(x, y, unicode.len(text) + xOffset * 2, yOffset * 2 + 1, backgroundColor, textColor, backgroundPressedColor, textPressedColor, text)\nend\n\nfunction GUI.button(...)\n\9local button = buttonCreate(...)\n\9button.draw = buttonDraw\n\n\9return button\nend\n\nfunction GUI.adaptiveButton(...)\n\9local button = adaptiveButtonCreate(...)\n\9button.draw = buttonDraw\n\n\9return button\nend\n\nfunction GUI.framedButton(...)\n\9local button = buttonCreate(...)\n\9button.draw = framedButtonDraw\n\n\9return button\nend\n\nfunction GUI.adaptiveFramedButton(...)\n\9local button = adaptiveButtonCreate(...)\n\9button.draw = framedButtonDraw\n\n\9return button\nend\n\nfunction GUI.roundedButton(...)\n\9local button = buttonCreate(...)\n\9button.draw = roundedButtonDraw\n\n\9return button\nend\n\nfunction GUI.adaptiveRoundedButton(...)\n\9local button = adaptiveButtonCreate(...)\n\9button.draw = roundedButtonDraw\n\n\9return button\nend\n\nfunction GUI.tagButton(...)\n\9local button = buttonCreate(...)\n\9button.draw = tagButtonDraw\n\n\9return button\nend\n\nfunction GUI.adaptiveTagButton(...)\n\9local button = adaptiveButtonCreate(...)\n\9button.draw = tagButtonDraw\n\n\9return button\nend\n\n--------------------------------------------------------------------------------\n\nlocal function drawPanel(object)\n\9buffer.drawRectangle(object.x, object.y, object.width, object.height, object.colors.background, 0x0, \" \", object.colors.transparency)\n\9return object\nend\n\nfunction GUI.panel(x, y, width, height, color, transparency)\n\9local object = GUI.object(x, y, width, height)\n\9\n\9object.colors = {\n\9\9background = color,\n\9\9transparency = transparency\n\9}\n\9object.draw = drawPanel\n\9\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function drawLabel(object)\n\9local xText, yText = GUI.getAlignmentCoordinates(\n\9\9object.x,\n\9\9object.y,\n\9\9object.width,\n\9\9object.height,\n\9\9object.horizontalAlignment,\n\9\9object.verticalAlignment,\n\9\9unicode.len(object.text),\n\9\0091\n\9)\n\9buffer.drawText(math.floor(xText), math.floor(yText), object.colors.text, object.text)\n\9return object\nend\n\nfunction GUI.label(x, y, width, height, textColor, text)\n\9local object = GUI.object(x, y, width, height)\n\9\n\9object.setAlignment = GUI.setAlignment\n\9object:setAlignment(GUI.ALIGNMENT_HORIZONTAL_LEFT, GUI.ALIGNMENT_VERTICAL_TOP)\n\9object.colors = {text = textColor}\n\9object.text = text\n\9object.draw = drawLabel\n\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function drawImage(object)\n\9buffer.drawImage(object.x, object.y, object.image)\n\9return object\nend\n\nfunction GUI.image(x, y, image)\n\9local object = GUI.object(x, y, image[1], image[2])\n\9object.image = image\n\9object.draw = drawImage\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nfunction GUI.actionButtons(x, y, fatSymbol)\n\9local symbol = fatSymbol and \"\" or \"\"\n\9\n\9local container = GUI.container(x, y, 5, 1)\n\9container.close = container:addChild(GUI.button(1, 1, 1, 1, nil, 0xFF4940, nil, 0x992400, symbol))\n\9container.minimize = container:addChild(GUI.button(3, 1, 1, 1, nil, 0xFFB640, nil, 0x996D00, symbol))\n\9container.maximize = container:addChild(GUI.button(5, 1, 1, 1, nil, 0x00B640, nil, 0x006D40, symbol))\n\n\9return container\nend\n\n--------------------------------------------------------------------------------\n\nlocal function drawProgressBar(object)\n\9local activeWidth = math.floor(math.min(object.value, 100) / 100 * object.width)\n\9if object.thin then\n\9\9buffer.drawText(object.x, object.y, object.colors.passive, string.rep(\"\", object.width))\n\9\9buffer.drawText(object.x, object.y, object.colors.active, string.rep(\"\", activeWidth))\n\9else\n\9\9buffer.drawRectangle(object.x, object.y, object.width, object.height, object.colors.passive, 0x0, \" \")\n\9\9buffer.drawRectangle(object.x, object.y, activeWidth, object.height, object.colors.active, 0x0, \" \")\n\9end\n\n\9if object.showValue then\n\9\9local stringValue = (object.valuePrefix or \"\") .. object.value .. (object.valuePostfix or \"\")\n\9\9buffer.drawText(math.floor(object.x + object.width / 2 - unicode.len(stringValue) / 2), object.y + 1, object.colors.value, stringValue)\n\9end\n\n\9return object\nend\n\nfunction GUI.progressBar(x, y, width, activeColor, passiveColor, valueColor, value, thin, showValue, valuePrefix, valuePostfix)\n\9local object = GUI.object(x, y, width, 1)\n\9\n\9object.value = value\n\9object.colors = {active = activeColor, passive = passiveColor, value = valueColor}\n\9object.thin = thin\n\9object.draw = drawProgressBar\n\9object.showValue = showValue\n\9object.valuePrefix = valuePrefix\n\9object.valuePostfix = valuePostfix\n\9\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nfunction GUI.drawShadow(x, y, width, height, transparency, thin)\n\9if thin then\n\9\9buffer.drawRectangle(x + width, y + 1, 1, height - 1, 0x0, 0x0, \" \", transparency)\n\9\9buffer.drawText(x + 1, y + height, 0x0, string.rep(\"\", width), transparency)\n\9\9buffer.drawText(x + width, y, 0x0, \"\", transparency)\n\9else\n\9\9buffer.drawRectangle(x + width, y + 1, 2, height, 0x0, 0x0, \" \", transparency)\n\9\9buffer.drawRectangle(x + 2, y + height, width - 2, 1, 0x0, 0x0, \" \", transparency)\n\9end\nend\n\nfunction GUI.roundedCorners(x, y, width, height, color, transparency)\n\9buffer.drawText(x - 1, y, color, \"\", transparency)\n\9buffer.drawText(x + width, y, color, \"\", transparency)\nend\n\n--------------------------------------------------------------------------------\n\nfunction GUI.alert(...)\n\9local args = {...}\n\9for i = 1, #args do\n\9\9if type(args[i]) == \"table\" then\n\9\9\9args[i] = table.toString(args[i], true)\n\9\9else\n\9\9\9args[i] = tostring(args[i])\n\9\9end\n\9end\n\9if #args == 0 then args[1] = \"nil\" end\n\n\9local sign = image.fromString([[06030000FF 0000FF 00F7FF00F7FF0000FF 0000FF 0000FF 00F7FFF7FF00 F7FF00 00F7FF0000FF 00F7FFF7FF00CF7FF00yF7FF00kF7FF00a00F7FF]])\n\9local offset = 2\n\9local lines = #args > 1 and \"\\\"\" .. table.concat(args, \"\\\", \\\"\") .. \"\\\"\" or args[1]\n\9local bufferWidth, bufferHeight = buffer.getResolution()\n\9local width = math.floor(bufferWidth * 0.5)\n\9local textWidth = width - image.getWidth(sign) - 2\n\n\9lines = string.wrap(lines, textWidth)\n\9local height = image.getHeight(sign)\n\9if #lines + 2 > height then\n\9\9height = #lines + 2\n\9end\n\n\9local application = GUI.application(1, math.floor(bufferHeight / 2 - height / 2), bufferWidth, height + offset * 2)\n\9--local oldPixels = buffer.copy(application.x, application.y, application.width, application.height)\n\n\9local x, y = math.floor(bufferWidth / 2 - width / 2), offset + 1\n\9application:addChild(GUI.panel(1, 1, application.width, application.height, 0x1D1D1D))\n\9application:addChild(GUI.image(x, y, sign))\n\9application:addChild(GUI.textBox(x + image.getWidth(sign) + 2, y, textWidth, #lines, 0x1D1D1D, 0xE1E1E1, lines, 1, 0, 0)).eventHandler = nil\n\9local buttonWidth = 10\n\9local button = application:addChild(GUI.roundedButton(x + image.getWidth(sign) + textWidth - buttonWidth + 2, application.height - offset, buttonWidth, 1, 0x3366CC, 0xE1E1E1, 0xE1E1E1, 0x3366CC, \"OK\"))\n\9\n\9button.onTouch = function()\n\9\9application:stop()\n\9\9--buffer.paste(application.x, application.y, oldPixels)\n\9\9--buffer.drawChanges()\n\9\9global.clear()\n\9end\n\n\9application.eventHandler = function(application, object, e1, e2, e3, e4, ...)\n\9\9if e1 == \"key_down\" and e4 == 28 then\n\9\9\9button.animated = false\n\9\9\9button:press(application, object, e1, e2, e3, e4, ...)\n\9\9end\n\9end\n\n\9--application:draw(true)\n\9application:start()\nend\n\n--------------------------------------------------------------------------------\n\nlocal function codeViewDraw(codeView)\n\9local toLine, colorScheme, patterns = codeView.fromLine + codeView.height - 1, codeView.syntaxColorScheme, codeView.syntaxPatterns\n\9-- Line numbers bar and code area\n\9codeView.lineNumbersWidth = unicode.len(tostring(toLine)) + 2\n\9codeView.codeAreaPosition = codeView.x + codeView.lineNumbersWidth\n\9codeView.codeAreaWidth = codeView.width - codeView.lineNumbersWidth\n\9-- Line numbers \n\9buffer.drawRectangle(codeView.x, codeView.y, codeView.lineNumbersWidth, codeView.height, colorScheme.lineNumbersBackground, colorScheme.lineNumbersText, \" \")\9\n\9-- Background\n\9buffer.drawRectangle(codeView.codeAreaPosition, codeView.y, codeView.codeAreaWidth, codeView.height, colorScheme.background, colorScheme.text, \" \")\n\9-- Line numbers texts\n\9local y = codeView.y\n\9for line = codeView.fromLine, toLine do\n\9\9if codeView.lines[line] then\n\9\9\9local text = tostring(line)\n\9\9\9if codeView.highlights[line] then\n\9\9\9\9buffer.drawRectangle(codeView.x, y, codeView.lineNumbersWidth, 1, codeView.highlights[line], colorScheme.text, \" \", 0.3)\n\9\9\9\9buffer.drawRectangle(codeView.codeAreaPosition, y, codeView.codeAreaWidth, 1, codeView.highlights[line], colorScheme.text, \" \")\n\9\9\9end\n\9\9\9buffer.drawText(codeView.codeAreaPosition - unicode.len(text) - 1, y, colorScheme.lineNumbersText, text)\n\9\9\9y = y + 1\n\9\9else\n\9\9\9break\n\9\9end\9\n\9end\n\n\9local function drawUpperSelection(y, selectionIndex)\n\9\9buffer.drawRectangle(\n\9\9\9codeView.codeAreaPosition + codeView.selections[selectionIndex].from.symbol - codeView.fromSymbol + 1,\n\9\9\9y + codeView.selections[selectionIndex].from.line - codeView.fromLine,\n\9\9\9codeView.codeAreaWidth - codeView.selections[selectionIndex].from.symbol + codeView.fromSymbol - 1,\n\9\9\0091,\n\9\9\9codeView.selections[selectionIndex].color or colorScheme.selection, colorScheme.text, \" \"\n\9\9)\n\9end\n\n\9local function drawLowerSelection(y, selectionIndex)\n\9\9buffer.drawRectangle(\n\9\9\9codeView.codeAreaPosition,\n\9\9\9y + codeView.selections[selectionIndex].from.line - codeView.fromLine,\n\9\9\9codeView.selections[selectionIndex].to.symbol - codeView.fromSymbol + 2,\n\9\9\0091,\n\9\9\9codeView.selections[selectionIndex].color or colorScheme.selection, colorScheme.text, \" \"\n\9\9)\n\9end\n\n\9local oldDrawLimitX1, oldDrawLimitY1, oldDrawLimitX2, oldDrawLimitY2 = buffer.getDrawLimit()\n\9buffer.setDrawLimit(codeView.codeAreaPosition, codeView.y, codeView.codeAreaPosition + codeView.codeAreaWidth - 1, codeView.y + codeView.height - 1)\n\n\9if #codeView.selections > 0 then\n\9\9for selectionIndex = 1, #codeView.selections do\n\9\9\9y = codeView.y\n\9\9\9local dy = codeView.selections[selectionIndex].to.line - codeView.selections[selectionIndex].from.line\n\9\9\9if dy == 0 then\n\9\9\9\9buffer.drawRectangle(\n\9\9\9\9\9codeView.codeAreaPosition + codeView.selections[selectionIndex].from.symbol - codeView.fromSymbol + 1,\n\9\9\9\9\9y + codeView.selections[selectionIndex].from.line - codeView.fromLine,\n\9\9\9\9\9codeView.selections[selectionIndex].to.symbol - codeView.selections[selectionIndex].from.symbol + 1,\n\9\9\9\9\0091,\n\9\9\9\9\9codeView.selections[selectionIndex].color or colorScheme.selection, colorScheme.text, \" \"\n\9\9\9\9)\n\9\9\9elseif dy == 1 then\n\9\9\9\9drawUpperSelection(y, selectionIndex); y = y + 1\n\9\9\9\9drawLowerSelection(y, selectionIndex)\n\9\9\9else\n\9\9\9\9drawUpperSelection(y, selectionIndex); y = y + 1\n\9\9\9\9for i = 1, dy - 1 do\n\9\9\9\9\9buffer.drawRectangle(codeView.codeAreaPosition, y + codeView.selections[selectionIndex].from.line - codeView.fromLine, codeView.codeAreaWidth, 1, codeView.selections[selectionIndex].color or colorScheme.selection, colorScheme.text, \" \"); y = y + 1\n\9\9\9\9end\n\n\9\9\9\9drawLowerSelection(y, selectionIndex)\n\9\9\9end\n\9\9end\n\9end\n\n\9-- Code strings\n\9y = codeView.y\n\9buffer.setDrawLimit(codeView.codeAreaPosition + 1, y, codeView.codeAreaPosition + codeView.codeAreaWidth - 2, y + codeView.height - 1)\n\9\n\9for i = codeView.fromLine, toLine do\n\9\9if codeView.lines[i] then\n\9\9\9if codeView.syntaxHighlight then\n\9\9\9\9GUI.highlightString(codeView.codeAreaPosition + 1,\n\9\9\9\9\9y,\n\9\9\9\9\9codeView.codeAreaWidth - 2,\n\9\9\9\9\9codeView.fromSymbol,\n\9\9\9\9\9codeView.indentationWidth,\n\9\9\9\9\9patterns,\n\9\9\9\9\9colorScheme,\n\9\9\9\9\9codeView.lines[i]\n\9\9\9\9)\n\9\9\9else\n\9\9\9\9buffer.drawText(codeView.codeAreaPosition - codeView.fromSymbol + 2, y, colorScheme.text, codeView.lines[i])\n\9\9\9end\n\n\9\9\9y = y + 1\n\9\9else\n\9\9\9break\n\9\9end\n\9end\n\n\9buffer.setDrawLimit(oldDrawLimitX1, oldDrawLimitY1, oldDrawLimitX2, oldDrawLimitY2)\n\n\9if #codeView.lines > codeView.height then\n\9\9codeView.verticalScrollBar.colors.background, codeView.verticalScrollBar.colors.foreground = colorScheme.scrollBarBackground, colorScheme.scrollBarForeground\n\9\9codeView.verticalScrollBar.minimumValue, codeView.verticalScrollBar.maximumValue, codeView.verticalScrollBar.value, codeView.verticalScrollBar.shownValueCount = 1, #codeView.lines, codeView.fromLine, codeView.height\n\9\9codeView.verticalScrollBar.localX = codeView.width\n\9\9codeView.verticalScrollBar.localY = 1\n\9\9codeView.verticalScrollBar.height = codeView.height - 1\n\9\9codeView.verticalScrollBar.hidden = false\n\9else\n\9\9codeView.verticalScrollBar.hidden = true\n\9end\n\n\9if codeView.maximumLineLength > codeView.codeAreaWidth - 2 then\n\9\9codeView.horizontalScrollBar.colors.background, codeView.horizontalScrollBar.colors.foreground = colorScheme.scrollBarBackground, colorScheme.scrollBarForeground\n\9\9codeView.horizontalScrollBar.minimumValue, codeView.horizontalScrollBar.maximumValue, codeView.horizontalScrollBar.value, codeView.horizontalScrollBar.shownValueCount = 1, codeView.maximumLineLength, codeView.fromSymbol, codeView.codeAreaWidth - 2\n\9\9codeView.horizontalScrollBar.localX = codeView.lineNumbersWidth + 1\n\9\9codeView.horizontalScrollBar.localY = codeView.height\n\9\9codeView.horizontalScrollBar.width = codeView.codeAreaWidth - 1\n\9\9codeView.horizontalScrollBar.hidden = false\n\9else\n\9\9codeView.horizontalScrollBar.hidden = true\n\9end\n\n\9codeView:overrideDraw()\nend\n\nfunction GUI.codeView(x, y, width, height, fromSymbol, fromLine, maximumLineLength, selections, highlights, syntaxPatterns, syntaxColorScheme, syntaxHighlight, lines)\9\n\9local codeView = GUI.container(x, y, width, height)\n\9\n\9codeView.passScreenEvents = false\n\9codeView.lines = lines\n\9codeView.fromSymbol = fromSymbol\n\9codeView.fromLine = fromLine\n\9codeView.maximumLineLength = maximumLineLength\n\9codeView.selections = selections or {}\n\9codeView.highlights = highlights or {}\n\9codeView.syntaxHighlight = syntaxHighlight\n\9codeView.syntaxPatterns = syntaxPatterns\n\9codeView.syntaxColorScheme = syntaxColorScheme\n\9codeView.indentationWidth = 2\n\n\9codeView.verticalScrollBar = codeView:addChild(GUI.scrollBar(1, 1, 1, 1, 0x0, 0x0, 1, 1, 1, 1, 1, true))\n\9codeView.horizontalScrollBar = codeView:addChild(GUI.scrollBar(1, 1, 1, 1, 0x0, 0x0, 1, 1, 1, 1, 1, true))\n\n\9codeView.overrideDraw = codeView.draw\n\9codeView.draw = codeViewDraw\n\n\9return codeView\nend \n\n--------------------------------------------------------------------------------\n\nlocal function colorSelectorDraw(colorSelector)\n\9local overlayColor = colorSelector.color < 0x7FFFFF and 0xFFFFFF or 0x0\n\9\9\n\9buffer.drawRectangle(\n\9\9colorSelector.x,\n\9\9colorSelector.y,\n\9\9colorSelector.width,\n\9\9colorSelector.height,\n\9\9colorSelector.pressed and color.blend(colorSelector.color, overlayColor, 0.8) or colorSelector.color,\n\9\9overlayColor,\n\9\9\" \"\n\9)\n\9\n\9if colorSelector.height > 1 and colorSelector.drawLine then\n\9\9buffer.drawText(colorSelector.x, colorSelector.y + colorSelector.height - 1, overlayColor, string.rep(\"\", colorSelector.width), 0.8)\n\9end\n\9\n\9buffer.drawText(colorSelector.x + 1, colorSelector.y + math.floor(colorSelector.height / 2), overlayColor, string.limit(colorSelector.text, colorSelector.width - 2))\n\9\n\9return colorSelector\nend\n\nlocal function colorSelectorEventHandler(application, object, e1, ...)\n\9if e1 == \"touch\" then\n\9\9local eventData = {...}\n\9\9object.pressed = true\n\n\9\9local palette = application:addChild(GUI.palette(1, 1, object.color))\n\9\9palette.localX, palette.localY = math.floor(application.width / 2 - palette.width / 2), math.floor(application.height / 2 - palette.height / 2)\n\n\9\9palette.cancelButton.onTouch = function()\n\9\9\9object.pressed = false\n\9\9\9palette:remove()\n\9\9\9--application:draw()\n\n\9\9\9if object.onColorSelected then\n\9\9\9\9object.onColorSelected(application, object, e1, table.unpack(eventData))\n\9\9\9end\n\9\9end\n\n\9\9palette.submitButton.onTouch = function()\n\9\9\9object.color = palette.color.integer\n\9\9\9palette.cancelButton.onTouch()\n\9\9end\n\9\9\n\9\9--application:draw()\n\9end\nend\n\nfunction GUI.colorSelector(x, y, width, height, color, text)\n\9local colorSelector = GUI.object(x, y, width, height)\n\9\n\9colorSelector.drawLine = true\n\9colorSelector.eventHandler = colorSelectorEventHandler\n\9colorSelector.color = color\n\9colorSelector.text = text\n\9colorSelector.draw = colorSelectorDraw\n\9\n\9return colorSelector\nend \n\n--------------------------------------------------------------------------------\n\nlocal function getAxisValue(number, postfix, roundValues)\n\9if roundValues then\n\9\9return math.floor(number) .. postfix\n\9else\n\9\9local integer, fractional = math.modf(number)\n\9\9local firstPart, secondPart = \"\", \"\"\n\9\9if math.abs(integer) >= 1000 then\n\9\9\9return math.shorten(integer, 2) .. postfix\n\9\9else\n\9\9\9if math.abs(fractional) > 0 then\n\9\9\9\9return string.format(\"%.2f\", number) .. postfix\n\9\9\9else\n\9\9\9\9return number .. postfix\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function drawChart(object)\n\9-- Sorting by x value\n\9local valuesCopy = {}\n\9for i = 1, #object.values do valuesCopy[i] = object.values[i] end\n\9table.sort(valuesCopy, function(a, b) return a[1] < b[1] end)\n\9\n\9if #valuesCopy == 0 then valuesCopy = {{0, 0}} end\n\n\9-- Max, min, deltas\n\9local xMin, xMax, yMin, yMax = valuesCopy[1][1], valuesCopy[#valuesCopy][1], valuesCopy[1][2], valuesCopy[1][2]\n\9for i = 1, #valuesCopy do yMin, yMax = math.min(yMin, valuesCopy[i][2]), math.max(yMax, valuesCopy[i][2]) end\n\9local dx, dy = xMax - xMin, yMax - yMin\n\n\9-- y axis values and helpers\n\9local value, chartHeight, yAxisValueMaxWidth, yAxisValues = yMin, object.height - 1 - (object.showXAxisValues and 1 or 0), 0, {}\n\9for y = object.y + object.height - 3, object.y + 1, -chartHeight * object.yAxisValueInterval do\n\9\9local stringValue = getAxisValue(value, object.yAxisPostfix, object.roundValues)\n\9\9yAxisValueMaxWidth = math.max(yAxisValueMaxWidth, unicode.len(stringValue))\n\9\9table.insert(yAxisValues, {y = math.ceil(y), value = stringValue})\n\9\9value = value + dy * object.yAxisValueInterval\n\9end\n\9local stringValue = getAxisValue(yMax, object.yAxisPostfix, object.roundValues)\n\9table.insert(yAxisValues, {y = object.y, value = stringValue})\n\9yAxisValueMaxWidth = math.max(yAxisValueMaxWidth, unicode.len(stringValue))\n\n\9local chartWidth = object.width - (object.showYAxisValues and yAxisValueMaxWidth + 2 or 0) \n\9local chartX = object.x + object.width - chartWidth\n\9for i = 1, #yAxisValues do\n\9\9if object.showYAxisValues then\n\9\9\9buffer.drawText(chartX - unicode.len(yAxisValues[i].value) - 2, yAxisValues[i].y, object.colors.axisValue, yAxisValues[i].value)\n\9\9end\n\9\9buffer.drawText(chartX, yAxisValues[i].y, object.colors.helpers, string.rep(\"\", chartWidth))\n\9end\n\n\9-- x axis values\n\9if object.showXAxisValues then\n\9\9value = xMin\n\9\9for x = chartX, chartX + chartWidth - 2, chartWidth * object.xAxisValueInterval do\n\9\9\9local stringValue = getAxisValue(value, object.xAxisPostfix, object.roundValues)\n\9\9\9buffer.drawText(math.floor(x - unicode.len(stringValue) / 2), object.y + object.height - 1, object.colors.axisValue, stringValue)\n\9\9\9value = value + dx * object.xAxisValueInterval\n\9\9end\n\9\9local value = getAxisValue(xMax, object.xAxisPostfix, object.roundValues)\n\9\9buffer.drawText(object.x + object.width - unicode.len(value), object.y + object.height - 1, object.colors.axisValue, value)\n\9end\n\n\9-- Axis lines\n\9for y = object.y, object.y + chartHeight - 1 do\n\9\9buffer.drawText(chartX - 1, y, object.colors.axis, \"\")\n\9end\n\9buffer.drawText(chartX - 1, object.y + chartHeight, object.colors.axis, \"\" .. string.rep(\"\", math.floor(chartWidth / 2)))\n\n\9local function fillVerticalPart(x1, y1, x2, y2)\n\9\9local dx, dy = x2 - x1, y2 - y1\n\9\9local absdx, absdy = math.abs(dx), math.abs(dy)\n\9\9if absdx >= absdy then\n\9\9\9local step, y = dy / absdx, y1\n\9\9\9for x = x1, x2, (x1 < x2 and 1 or -1) do\n\9\9\9\9local yFloor = math.floor(y)\n\9\9\9\9buffer.drawSemiPixelRectangle(math.floor(x), yFloor, 1, math.floor(object.y + chartHeight) * 2 - yFloor - 1, object.colors.chart)\n\9\9\9\9y = y + step\n\9\9\9end\n\9\9else\n\9\9\9local step, x = dx / absdy, x1\n\9\9\9for y = y1, y2, (y1 < y2 and 1 or -1) do\n\9\9\9\9local yFloor = math.floor(y)\n\9\9\9\9buffer.drawSemiPixelRectangle(math.floor(x), yFloor, 1, math.floor(object.y + chartHeight) * 2 - yFloor - 1, object.colors.chart)\n\9\9\9\9x = x + step\n\9\9\9end\n\9\9end\n\9end\n\n\9-- chart\n\9for i = 1, #valuesCopy - 1 do\n\9\9local x = math.floor(chartX + (valuesCopy[i][1] - xMin) / dx * (chartWidth - 1))\n\9\9local y = math.floor(object.y + chartHeight - 1 - (valuesCopy[i][2] - yMin) / dy * (chartHeight - 1)) * 2\n\9\9local xNext = math.floor(chartX + (valuesCopy[i + 1][1] - xMin) / dx * (chartWidth - 1))\n\9\9local yNext = math.floor(object.y + chartHeight - 1 - (valuesCopy[i + 1][2] - yMin) / dy * (chartHeight - 1)) * 2\n\9\9if object.fillChartArea then\n\9\9\9fillVerticalPart(x, y, xNext, yNext)\n\9\9else\n\9\9\9buffer.drawSemiPixelLine(x, y, xNext, yNext, object.colors.chart)\n\9\9end\n\9end\n\n\9return object\nend\n\nfunction GUI.chart(x, y, width, height, axisColor, axisValueColor, axisHelpersColor, chartColor, xAxisValueInterval, yAxisValueInterval, xAxisPostfix, yAxisPostfix, fillChartArea, values)\n\9local object = GUI.object(x, y, width, height)\n\n\9object.colors = {axis = axisColor, chart = chartColor, axisValue = axisValueColor, helpers = axisHelpersColor}\n\9object.draw = drawChart\n\9object.values = values or {}\n\9object.xAxisPostfix = xAxisPostfix\n\9object.yAxisPostfix = yAxisPostfix\n\9object.xAxisValueInterval = xAxisValueInterval\n\9object.yAxisValueInterval = yAxisValueInterval\n\9object.fillChartArea = fillChartArea\n\9object.showYAxisValues = true\n\9object.showXAxisValues = true\n\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function switchAndLabelDraw(switchAndLabel)\n\9switchAndLabel.label.width = switchAndLabel.width\n\9switchAndLabel.switch.localX = switchAndLabel.width - switchAndLabel.switch.width\n\n\9switchAndLabel.label.x, switchAndLabel.label.y = switchAndLabel.x + switchAndLabel.label.localX - 1, switchAndLabel.y + switchAndLabel.label.localY - 1\n\9switchAndLabel.switch.x, switchAndLabel.switch.y = switchAndLabel.x + switchAndLabel.switch.localX - 1, switchAndLabel.y + switchAndLabel.switch.localY - 1\n\9\n\9switchAndLabel.label:draw()\n\9switchAndLabel.switch:draw()\n\n\9return switchAndLabel\nend\n\nfunction GUI.switchAndLabel(x, y, width, switchWidth, activeColor, passiveColor, pipeColor, textColor, text, switchState)\n\9local switchAndLabel = GUI.container(x, y, width, 1)\n\n\9switchAndLabel.label = switchAndLabel:addChild(GUI.label(1, 1, width, 1, textColor, text))\n\9switchAndLabel.switch = switchAndLabel:addChild(GUI.switch(1, 1, switchWidth, activeColor, passiveColor, pipeColor, switchState))\n\9switchAndLabel.draw = switchAndLabelDraw\n\n\9return switchAndLabel \nend\n\n--------------------------------------------------------------------------------\n\nlocal function sliderDraw(object)\n\9--            \n\9object.value = math.min(math.max(object.value, object.minimumValue), object.maximumValue)\n\9\n\9if object.showMaximumAndMinimumValues then\n\9\9local stringMaximumValue, stringMinimumValue = tostring(object.roundValues and math.floor(object.maximumValue) or math.roundToDecimalPlaces(object.maximumValue, 2)), tostring(object.roundValues and math.floor(object.minimumValue) or math.roundToDecimalPlaces(object.minimumValue, 2))\n\9\9buffer.drawText(object.x - unicode.len(stringMinimumValue) - 1, object.y, object.colors.value, stringMinimumValue)\n\9\9buffer.drawText(object.x + object.width + 1, object.y, object.colors.value, stringMaximumValue)\n\9end\n\n\9if object.currentValuePrefix or object.currentValuePostfix then\n\9\9local stringCurrentValue = (object.currentValuePrefix or \"\") .. (object.roundValues and math.floor(object.value) or math.roundToDecimalPlaces(object.value, 2)) .. (object.currentValuePostfix or \"\")\n\9\9buffer.drawText(math.floor(object.x + object.width / 2 - unicode.len(stringCurrentValue) / 2), object.y + 1, object.colors.value, stringCurrentValue)\n\9end\n\n\9local activeWidth = math.round((object.value - object.minimumValue) / (object.maximumValue - object.minimumValue) * object.width)\n\9buffer.drawText(object.x, object.y, object.colors.passive, string.rep(\"\", object.width))\n\9buffer.drawText(object.x, object.y, object.colors.active, string.rep(\"\", activeWidth))\n\9buffer.drawText(activeWidth >= object.width and object.x + activeWidth - 1 or object.x + activeWidth, object.y, object.colors.pipe, \"\")\n\n\9return object\nend\n\nlocal function sliderEventHandler(application, object, e1, e2, e3, ...)\n\9if e1 == \"touch\" or e1 == \"drag\" then\n\9\9local clickPosition = e3 - object.x\n\n\9\9if clickPosition == 0 then\n\9\9\9object.value = object.minimumValue\n\9\9elseif clickPosition == object.width - 1 then\n\9\9\9object.value = object.maximumValue\n\9\9else\n\9\9\9object.value = object.minimumValue + (clickPosition / object.width * (object.maximumValue - object.minimumValue))\n\9\9end\n\n\9\9--application:draw()\n\n\9\9if object.onValueChanged then\n\9\9\9object.onValueChanged(application, object, e1, e2, e3, ...)\n\9\9end\n\9end\nend\n\nfunction GUI.slider(x, y, width, activeColor, passiveColor, pipeColor, valueColor, minimumValue, maximumValue, value, showMaximumAndMinimumValues, currentValuePrefix, currentValuePostfix)\n\9local object = GUI.object(x, y, width, 1)\n\9\n\9object.eventHandler = sliderEventHandler\n\9object.colors = {active = activeColor, passive = passiveColor, pipe = pipeColor, value = valueColor}\n\9object.draw = sliderDraw\n\9object.minimumValue = minimumValue\n\9object.maximumValue = maximumValue\n\9object.value = value\n\9object.showMaximumAndMinimumValues = showMaximumAndMinimumValues\n\9object.currentValuePrefix = currentValuePrefix\n\9object.currentValuePostfix = currentValuePostfix\n\9object.roundValues = false\n\9\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function switchDraw(switch)\n\9buffer.drawText(switch.x - 1, switch.y, switch.colors.passive, \"\")\n\9buffer.drawRectangle(switch.x, switch.y, switch.width, 1, switch.colors.passive, 0x0, \" \")\n\9buffer.drawText(switch.x + switch.width, switch.y, switch.colors.passive, \"\")\n\n\9buffer.drawText(switch.x - 1, switch.y, switch.colors.active, \"\")\n\9buffer.drawRectangle(switch.x, switch.y, switch.pipePosition - 1, 1, switch.colors.active, 0x0, \" \")\n\n\9buffer.drawText(switch.x + switch.pipePosition - 2, switch.y, switch.colors.pipe, \"\")\n\9buffer.drawRectangle(switch.x + switch.pipePosition - 1, switch.y, 2, 1, switch.colors.pipe, 0x0, \" \")\n\9buffer.drawText(switch.x + switch.pipePosition + 1, switch.y, switch.colors.pipe, \"\")\n\9\n\9return switch\nend\n\nlocal function switchSetState(switch, state)\n\9switch.state = state\n\9switch.pipePosition = switch.state and switch.width - 1 or 1\n\n\9return switch\nend\n\nlocal function switchEventHandler(application, switch, e1, ...)\n\9if e1 == \"touch\" then\n\9\9local eventData = {...}\n\n\9\9switch.state = not switch.state\n\9\9switch:addAnimation(\n\9\9\9function(animation)\n\9\9\9\9if switch.state then\n\9\9\9\9\9switch.pipePosition = math.round(1 + animation.position * (switch.width - 2))\n\9\9\9\9else\9\n\9\9\9\9\9switch.pipePosition = math.round(1 + (1 - animation.position) * (switch.width - 2))\n\9\9\9\9end\n\9\9\9end,\n\9\9\9function(animation)\n\9\9\9\9animation:remove()\n\9\9\9\9if switch.onStateChanged then\n\9\9\9\9\9switch.onStateChanged(switch, e1, table.unpack(eventData))\n\9\9\9\9end\n\9\9\9end\n\9\9):start(switch.animationDuration)\n\9end\nend\n\nfunction GUI.switch(x, y, width, activeColor, passiveColor, pipeColor, state)\n\9local switch = GUI.object(x, y, width, 1)\n\n\9switch.pipePosition = 1\n\9switch.eventHandler = switchEventHandler\n\9switch.colors = {\n\9\9active = activeColor,\n\9\9passive = passiveColor,\n\9\9pipe = pipeColor,\n\9}\n\9switch.draw = switchDraw\n\9switch.state = state or false\n\9switch.update = switchUpdate\n\9switch.animated = true\n\9switch.animationDuration = GUI.SWITCH_ANIMATION_DURATION\n\9switch.setState = switchSetState\n\n\9switch:setState(state)\n\9\n\9return switch\nend\n\n--------------------------------------------------------------------------------\n\nlocal function layoutCheckCell(layout, column, row)\n\9if column < 1 or column > #layout.columnSizes or row < 1 or row > #layout.rowSizes then\n\9\9error(\"Specified grid position (\" .. tostring(column) .. \"x\" .. tostring(row) .. \") is out of layout grid range\")\n\9end\nend\n\nlocal function layoutGetAbsoluteTotalSize(array)\n\9local absoluteTotalSize = 0\n\9for i = 1, #array do\n\9\9if array[i].sizePolicy == GUI.SIZE_POLICY_ABSOLUTE then\n\9\9\9absoluteTotalSize = absoluteTotalSize + array[i].size\n\9\9end\n\9end\n\9return absoluteTotalSize\nend\n\nlocal function layoutGetCalculatedSize(array, index, dependency)\n\9if array[index].sizePolicy == GUI.SIZE_POLICY_RELATIVE then\n\9\9array[index].calculatedSize = array[index].size * dependency\n\9else\n\9\9array[index].calculatedSize = array[index].size\n\9end\nend\n\nlocal function layoutUpdate(layout)\n\9local columnPercentageTotalSize, rowPercentageTotalSize = layout.width - layoutGetAbsoluteTotalSize(layout.columnSizes), layout.height - layoutGetAbsoluteTotalSize(layout.rowSizes)\n\9for row = 1, #layout.rowSizes do\n\9\9layoutGetCalculatedSize(layout.rowSizes, row, rowPercentageTotalSize)\n\9\9for column = 1, #layout.columnSizes do\n\9\9\9layoutGetCalculatedSize(layout.columnSizes, column, columnPercentageTotalSize)\n\9\9\9layout.cells[row][column].childrenWidth, layout.cells[row][column].childrenHeight = 0, 0\n\9\9end\n\9end\n\n\9--        \n\9local child, layoutRow, layoutColumn, cell\n\9for i = 1, #layout.children do\n\9\9child = layout.children[i]\n\9\9\n\9\9if not child.hidden then\n\9\9\9layoutRow, layoutColumn = child.layoutRow, child.layoutColumn\n\n\9\9\9--     \n\9\9\9if layoutRow >= 1 and layoutRow <= #layout.rowSizes and layoutColumn >= 1 and layoutColumn <= #layout.columnSizes then\n\9\9\9\9cell = layout.cells[layoutRow][layoutColumn]\n\9\9\9\9-- - \n\9\9\9\9if cell.horizontalFitting then\n\9\9\9\9\9child.width = math.round(layout.columnSizes[layoutColumn].calculatedSize - cell.horizontalFittingRemove)\n\9\9\9\9end\n\n\9\9\9\9if cell.verticalFitting then\n\9\9\9\9\9child.height = math.round(layout.rowSizes[layoutRow].calculatedSize - cell.verticalFittingRemove)\n\9\9\9\9end\n\n\9\9\9\9--    \n\9\9\9\9if cell.direction == GUI.DIRECTION_HORIZONTAL then\n\9\9\9\9\9cell.childrenWidth = cell.childrenWidth + child.width + cell.spacing\n\9\9\9\9\9cell.childrenHeight = math.max(cell.childrenHeight, child.height)\n\9\9\9\9else\n\9\9\9\9\9cell.childrenWidth = math.max(cell.childrenWidth, child.width)\n\9\9\9\9\9cell.childrenHeight = cell.childrenHeight + child.height + cell.spacing\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9error(\"Layout child with index \" .. i .. \" has been assigned to cell (\" .. layoutColumn .. \"x\" .. layoutRow .. \") out of layout grid range\")\n\9\9\9end\n\9\9end\n\9end\n\n\9--     \n\9local x, y = 1, 1\n\9for row = 1, #layout.rowSizes do\n\9\9for column = 1, #layout.columnSizes do\n\9\9\9cell = layout.cells[row][column]\n\9\9\9cell.x, cell.y = GUI.getAlignmentCoordinates(\n\9\9\9\9x,\n\9\9\9\9y,\n\9\9\9\9layout.columnSizes[column].calculatedSize,\n\9\9\9\9layout.rowSizes[row].calculatedSize,\n\9\9\9\9cell.horizontalAlignment,\n\9\9\9\9cell.verticalAlignment,\n\9\9\9\9cell.childrenWidth - (cell.direction == GUI.DIRECTION_HORIZONTAL and cell.spacing or 0),\n\9\9\9\9cell.childrenHeight - (cell.direction == GUI.DIRECTION_VERTICAL and cell.spacing or 0)\n\9\9\9)\n\n\9\9\9--     \n\9\9\9if cell.horizontalMargin ~= 0 or cell.verticalMargin ~= 0 then\n\9\9\9\9cell.x, cell.y = GUI.getMarginCoordinates(\n\9\9\9\9\9cell.x,\n\9\9\9\9\9cell.y,\n\9\9\9\9\9cell.horizontalAlignment,\n\9\9\9\9\9cell.verticalAlignment,\n\9\9\9\9\9cell.horizontalMargin,\n\9\9\9\9\9cell.verticalMargin\n\9\9\9\9)\n\9\9\9end\n\n\9\9\9x = x + layout.columnSizes[column].calculatedSize\n\9\9end\n\n\9\9x, y = 1, y + layout.rowSizes[row].calculatedSize\n\9end\n\n\9--   \n\9for i = 1, #layout.children do\n\9\9child = layout.children[i]\n\9\9\n\9\9if not child.hidden then\n\9\9\9cell = layout.cells[child.layoutRow][child.layoutColumn]\n\9\9\9\n\9\9\9child.localX, cell.localY = GUI.getAlignmentCoordinates(\n\9\9\9\9cell.x,\n\9\9\9\9cell.y,\n\9\9\9\9cell.childrenWidth,\n\9\9\9\9cell.childrenHeight,\n\9\9\9\9cell.horizontalAlignment,\n\9\9\9\9cell.verticalAlignment,\n\9\9\9\9child.width,\n\9\9\9\9child.height\n\9\9\9)\n\n\9\9\9if cell.direction == GUI.DIRECTION_HORIZONTAL then\n\9\9\9\9child.localX, child.localY = math.floor(cell.x), math.floor(cell.localY)\n\9\9\9\9cell.x = cell.x + child.width + cell.spacing\n\9\9\9else\n\9\9\9\9child.localX, child.localY = math.floor(child.localX), math.floor(cell.y)\n\9\9\9\9cell.y = cell.y + child.height + cell.spacing\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function layoutSetPosition(layout, column, row, object)\n\9layoutCheckCell(layout, column, row)\n\9object.layoutRow = row\n\9object.layoutColumn = column\n\n\9return object\nend\n\nlocal function layoutSetDirection(layout, column, row, direction)\n\9layoutCheckCell(layout, column, row)\n\9layout.cells[row][column].direction = direction\n\n\9return layout\nend\n\nlocal function layoutSetSpacing(layout, column, row, spacing)\n\9layoutCheckCell(layout, column, row)\n\9layout.cells[row][column].spacing = spacing\n\n\9return layout\nend\n\nlocal function layoutSetAlignment(layout, column, row, horizontalAlignment, verticalAlignment)\n\9layoutCheckCell(layout, column, row)\n\9layout.cells[row][column].horizontalAlignment, layout.cells[row][column].verticalAlignment = horizontalAlignment, verticalAlignment\n\n\9return layout\nend\n\nlocal function layoutGetMargin(layout, column, row)\n\9layoutCheckCell(layout, column, row)\n\n\9return layout.cells[row][column].horizontalMargin, layout.cells[row][column].verticalMargin\nend\n\nlocal function layoutSetMargin(layout, column, row, horizontalMargin, verticalMargin)\n\9layoutCheckCell(layout, column, row)\n\9layout.cells[row][column].horizontalMargin = horizontalMargin\n\9layout.cells[row][column].verticalMargin = verticalMargin\n\n\9return layout\nend\n\nlocal function layoutNewCell()\n\9return {\n\9\9horizontalAlignment = GUI.ALIGNMENT_HORIZONTAL_CENTER,\n\9\9verticalAlignment = GUI.ALIGNMENT_VERTICAL_CENTER,\n\9\9horizontalMargin = 0,\n\9\9verticalMargin = 0,\n\9\9direction = GUI.DIRECTION_VERTICAL,\n\9\9spacing = 1\n\9}\nend\n\nlocal function layoutCalculatePercentageSize(changingExistent, array, index)\n\9if array[index].sizePolicy == GUI.SIZE_POLICY_RELATIVE then\n\9\9local allPercents, beforeFromIndexPercents = 0, 0\n\9\9for i = 1, #array do\n\9\9\9if array[i].sizePolicy == GUI.SIZE_POLICY_RELATIVE then\n\9\9\9\9allPercents = allPercents + array[i].size\n\n\9\9\9\9if i <= index then\n\9\9\9\9\9beforeFromIndexPercents = beforeFromIndexPercents + array[i].size\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9local modifyer\n\9\9if changingExistent then\n\9\9\9if beforeFromIndexPercents > 1 then\n\9\9\9\9error(\"Layout summary percentage > 100% at index \" .. index)\n\9\9\9end\n\9\9\9modifyer = (1 - beforeFromIndexPercents) / (allPercents - beforeFromIndexPercents)\n\9\9else\n\9\9\9modifyer = (1 - array[index].size) / (allPercents - array[index].size)\n\9\9end\n\n\9\9for i = changingExistent and index + 1 or 1, #array do\n\9\9\9if array[i].sizePolicy == GUI.SIZE_POLICY_RELATIVE and i ~= index then\n\9\9\9\9array[i].size = modifyer * array[i].size\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function layoutSetColumnWidth(layout, column, sizePolicy, size)\n\9layout.columnSizes[column].sizePolicy, layout.columnSizes[column].size = sizePolicy, size\n\9layoutCalculatePercentageSize(true, layout.columnSizes, column)\n\n\9return layout\nend\n\nlocal function layoutSetRowHeight(layout, row, sizePolicy, size)\n\9layout.rowSizes[row].sizePolicy, layout.rowSizes[row].size = sizePolicy, size\n\9layoutCalculatePercentageSize(true, layout.rowSizes, row)\n\n\9return layout\nend\n\nlocal function layoutAddColumn(layout, sizePolicy, size)\n\9for i = 1, #layout.rowSizes do\n\9\9table.insert(layout.cells[i], layoutNewCell())\n\9end\n\n\9table.insert(layout.columnSizes, {\n\9\9sizePolicy = sizePolicy,\n\9\9size = size\n\9})\n\9layoutCalculatePercentageSize(false, layout.columnSizes, #layout.columnSizes)\n\n\9return layout\nend\n\nlocal function layoutAddRow(layout, sizePolicy, size)\n\9local row = {}\n\9for i = 1, #layout.columnSizes do\n\9\9table.insert(row, layoutNewCell())\n\9end\n\n\9table.insert(layout.cells, row)\n\9table.insert(layout.rowSizes, {\n\9\9sizePolicy = sizePolicy,\n\9\9size = size\n\9})\n\n\9layoutCalculatePercentageSize(false, layout.rowSizes, #layout.rowSizes)\n\n\9return layout\nend\n\nlocal function layoutRemoveRow(layout, row)\n\9table.remove(layout.cells, row)\n\n\9layout.rowSizes[row].size = 0\n\9layoutCalculatePercentageSize(false, layout.rowSizes, row)\n\n\9table.remove(layout.rowSizes, row)\n\n\9return layout\nend\n\nlocal function layoutRemoveColumn(layout, column)\n\9for i = 1, #layout.rowSizes do\n\9\9table.remove(layout.cells[i], column)\n\9end\n\n\9layout.columnSizes[column].size = 0\n\9layoutCalculatePercentageSize(false, layout.columnSizes, column)\n\n\9table.remove(layout.columnSizes, column)\n\n\9return layout\nend\n\nlocal function layoutSetGridSize(layout, columnCount, rowCount)\n\9layout.cells = {}\n\9layout.rowSizes = {}\n\9layout.columnSizes = {}\n\n\9local rowSize, columnSize = 1 / rowCount, 1 / columnCount\n\9for i = 1, rowCount do\n\9\9layoutAddRow(layout, GUI.SIZE_POLICY_RELATIVE, 1 / i)\n\9end\n\n\9for i = 1, columnCount do\n\9\9layoutAddColumn(layout, GUI.SIZE_POLICY_RELATIVE, 1 / i)\n\9end\n\n\9return layout\nend\n\nlocal function layoutDraw(layout)\n\9layout:update()\n\9containerDraw(layout)\n\9\n\9if layout.showGrid then\n\9\9local x, y = layout.x, layout.y\n\9\9for j = 1, #layout.columnSizes do\n\9\9\9for i = 1, #layout.rowSizes do\n\9\9\9\9buffer.drawFrame(\n\9\9\9\9\9math.round(x),\n\9\9\9\9\9math.round(y),\n\9\9\9\9\9math.round(layout.columnSizes[j].calculatedSize),\n\9\9\9\9\9math.round(layout.rowSizes[i].calculatedSize),\n\9\9\9\9\0090xFF0000\n\9\9\9\9)\n\9\9\9\9y = y + layout.rowSizes[i].calculatedSize\n\9\9\9end\n\9\9\9x, y = x + layout.columnSizes[j].calculatedSize, layout.y\n\9\9end\n\9end\nend\n\nlocal function layoutFitToChildrenSize(layout, column, row)\n\9layout.width, layout.height = 0, 0\n\n\9for i = 1, #layout.children do\n\9\9if not layout.children[i].hidden then\n\9\9\9if layout.cells[row][column].direction == GUI.DIRECTION_HORIZONTAL then\n\9\9\9\9layout.width = layout.width + layout.children[i].width + layout.cells[row][column].spacing\n\9\9\9\9layout.height = math.max(layout.height, layout.children[i].height)\n\9\9\9else\n\9\9\9\9layout.width = math.max(layout.width, layout.children[i].width)\n\9\9\9\9layout.height = layout.height + layout.children[i].height + layout.cells[row][column].spacing\n\9\9\9end\n\9\9end\n\9end\n\n\9if layout.cells[row][column].direction == GUI.DIRECTION_HORIZONTAL then\n\9\9layout.width = layout.width - layout.cells[row][column].spacing\n\9else\n\9\9layout.height = layout.height - layout.cells[row][column].spacing\n\9end\n\n\9return layout\nend\n\nlocal function layoutSetFitting(layout, column, row, horizontal, vertical, horizontalRemove, verticalRemove)\n\9layoutCheckCell(layout, column, row)\n\9layout.cells[row][column].horizontalFitting = horizontal\n\9layout.cells[row][column].verticalFitting = vertical\n\9layout.cells[row][column].horizontalFittingRemove = horizontalRemove or 0\n\9layout.cells[row][column].verticalFittingRemove = verticalRemove or 0\n\n\9return layout\nend\n\nlocal function layoutAddChild(layout, object, ...)\n\9object.layoutRow = layout.defaultRow\n\9object.layoutColumn = layout.defaultColumn\n\9containerAddChild(layout, object, ...)\n\n\9return object\nend\n\nfunction GUI.layout(x, y, width, height, columnCount, rowCount)\n\9local layout = GUI.container(x, y, width, height)\n\n\9layout.defaultRow = 1\n\9layout.defaultColumn = 1\n\n\9layout.addRow = layoutAddRow\n\9layout.addColumn = layoutAddColumn\n\9layout.removeRow = layoutRemoveRow\n\9layout.removeColumn = layoutRemoveColumn\n\n\9layout.setRowHeight = layoutSetRowHeight\n\9layout.setColumnWidth = layoutSetColumnWidth\n\n\9layout.setPosition = layoutSetPosition\n\9layout.setDirection = layoutSetDirection\n\9layout.setGridSize = layoutSetGridSize\n\9layout.setSpacing = layoutSetSpacing\n\9layout.setAlignment = layoutSetAlignment\n\9layout.setMargin = layoutSetMargin\n\9layout.getMargin = layoutGetMargin\n\9\n\9layout.fitToChildrenSize = layoutFitToChildrenSize\n\9layout.setFitting = layoutSetFitting\n\n\9layout.update = layoutUpdate\n\9layout.addChild = layoutAddChild\n\9layout.draw = layoutDraw\n\n\9layout:setGridSize(columnCount, rowCount)\n\n\9return layout\nend\n\n--------------------------------------------------------------------------------\n\nlocal function filesystemDialogDraw(filesystemDialog)\n\9if filesystemDialog.extensionComboBox.hidden then\n\9\9filesystemDialog.input.width = filesystemDialog.cancelButton.localX - 4\n\9else\n\9\9filesystemDialog.input.width = filesystemDialog.extensionComboBox.localX - 3\n\9end\n\n\9if filesystemDialog.IOMode == GUI.IO_MODE_SAVE then\n\9\9filesystemDialog.submitButton.disabled = not filesystemDialog.input.text or filesystemDialog.input.text == \"\"\n\9else\n\9\9filesystemDialog.input.text = filesystemDialog.filesystemTree.selectedItem or \"\"\n\9\9filesystemDialog.submitButton.disabled = not filesystemDialog.filesystemTree.selectedItem\n\9end\n\9\n\9containerDraw(filesystemDialog)\n\9GUI.drawShadow(filesystemDialog.x, filesystemDialog.y, filesystemDialog.width, filesystemDialog.height, GUI.CONTEXT_MENU_SHADOW_TRANSPARENCY, true)\n\n\9return filesystemDialog\nend\n\nlocal function filesystemDialogSetMode(filesystemDialog, IOMode, filesystemMode)\n\9filesystemDialog.IOMode = IOMode\n\9filesystemDialog.filesystemMode = filesystemMode\n\n\9if filesystemDialog.IOMode == GUI.IO_MODE_SAVE then\n\9\9filesystemDialog.filesystemTree.showMode = GUI.IO_MODE_DIRECTORY\n\9\9filesystemDialog.filesystemTree.selectionMode = GUI.IO_MODE_DIRECTORY\n\9\9filesystemDialog.input.disabled = false\n\9\9filesystemDialog.extensionComboBox.hidden = filesystemDialog.filesystemMode ~= GUI.IO_MODE_FILE or not filesystemDialog.filesystemTree.extensionFilters\n\9else\n\9\9if filesystemDialog.filesystemMode == GUI.IO_MODE_FILE then\n\9\9\9filesystemDialog.filesystemTree.showMode = GUI.IO_MODE_BOTH\n\9\9\9filesystemDialog.filesystemTree.selectionMode = GUI.IO_MODE_FILE\n\9\9else\n\9\9\9filesystemDialog.filesystemTree.showMode = GUI.IO_MODE_DIRECTORY\n\9\9\9filesystemDialog.filesystemTree.selectionMode = GUI.IO_MODE_DIRECTORY\n\9\9end\n\n\9\9filesystemDialog.input.disabled = true\n\9\9filesystemDialog.extensionComboBox.hidden = true\n\9end\nend\n\nlocal function filesystemDialogAddExtensionFilter(filesystemDialog, extension)\n\9filesystemDialog.extensionComboBox:addItem(extension)\n\9filesystemDialog.extensionComboBox.width = math.max(filesystemDialog.extensionComboBox.width, unicode.len(extension) + 3)\n\9filesystemDialog.extensionComboBox.localX = filesystemDialog.cancelButton.localX - filesystemDialog.extensionComboBox.width - 2\n\9filesystemDialog.filesystemTree:addExtensionFilter(extension)\n\n\9filesystemDialog:setMode(filesystemDialog.IOMode, filesystemDialog.filesystemMode)\nend\n\nlocal function filesystemDialogExpandPath(filesystemDialog, ...)\n\9filesystemDialog.filesystemTree:expandPath(...)\nend\n\nfunction GUI.filesystemDialog(x, y, width, height, submitButtonText, cancelButtonText, placeholderText, path)\n\9local filesystemDialog = GUI.container(x, y, width, height)\n\9\n\9filesystemDialog:addChild(GUI.panel(1, height - 2, width, 3, 0xD2D2D2))\n\9\n\9filesystemDialog.cancelButton = filesystemDialog:addChild(GUI.adaptiveRoundedButton(1, height - 1, 1, 0, 0xE1E1E1, 0x3C3C3C, 0x3C3C3C, 0xE1E1E1, cancelButtonText))\n\9filesystemDialog.submitButton = filesystemDialog:addChild(GUI.adaptiveRoundedButton(1, height - 1, 1, 0, 0x3C3C3C, 0xE1E1E1, 0xE1E1E1, 0x3C3C3C, submitButtonText))\n\9filesystemDialog.submitButton.localX = filesystemDialog.width - filesystemDialog.submitButton.width - 1\n\9filesystemDialog.cancelButton.localX = filesystemDialog.submitButton.localX - filesystemDialog.cancelButton.width - 2\n\n\9filesystemDialog.extensionComboBox = filesystemDialog:addChild(GUI.comboBox(1, height - 1, 1, 1, 0xE1E1E1, 0x696969, 0xC3C3C3, 0x878787))\n\9filesystemDialog.extensionComboBox.hidden = true\n\n\9filesystemDialog.input = filesystemDialog:addChild(GUI.input(2, height - 1, 1, 1, 0xE1E1E1, 0x696969, 0x969696, 0xE1E1E1, 0x3C3C3C, \"\", placeholderText))\n\n\9filesystemDialog.filesystemTree = filesystemDialog:addChild(GUI.filesystemTree(1, 1, width, height - 3, 0xE1E1E1, 0x3C3C3C, 0x3C3C3C, 0xA5A5A5, 0x3C3C3C, 0xE1E1E1, 0xB4B4B4, 0xA5A5A5, 0xC3C3C3, 0x4B4B4B))\n\9filesystemDialog.filesystemTree.workPath = path\n\9filesystemDialog.animationDuration = GUI.FILESYSTEM_DIALOG_ANIMATION_DURATION\n\n\9filesystemDialog.draw = filesystemDialogDraw\n\9filesystemDialog.setMode = filesystemDialogSetMode\n\9filesystemDialog.addExtensionFilter = filesystemDialogAddExtensionFilter\n\n\9filesystemDialog.expandPath = filesystemDialogExpandPath\n\9filesystemDialog:setMode(GUI.IO_MODE_OPEN, GUI.IO_MODE_FILE)\n\n\9return filesystemDialog\nend\n\nlocal function filesystemDialogShow(filesystemDialog)\n\9filesystemDialog.filesystemTree:updateFileList()\n\9filesystemDialog:addAnimation(\n\9\9function(animation)\n\9\9\9filesystemDialog.localY = math.floor(1 + (1.0 - animation.position) * (-filesystemDialog.height))\n\9\9end,\n\9\9function(animation)\n\9\9\9animation:remove()\n\9\9end\n\9):start(filesystemDialog.animationDuration)\n\n\9return filesystemDialog\nend\n\n--------------------------------------------------------------------------------\n\nfunction GUI.addFilesystemDialog(parentContainer, addPanel, ...)\n\9local container = GUI.addBackgroundContainer(parentContainer, addPanel, false, nil)\n\n\9local filesystemDialog = container:addChild(GUI.filesystemDialog(1, 1, ...))\n\9filesystemDialog.localX = math.floor(container.width / 2 - filesystemDialog.width / 2)\n\9filesystemDialog.localY = -filesystemDialog.height\n\n\9local function onAnyTouch()\n\9\9container:remove()\n\9\9filesystemDialog.firstParent:draw()\n\9end\n\n\9filesystemDialog.cancelButton.onTouch = function()\n\9\9onAnyTouch()\n\n\9\9if filesystemDialog.onCancel then\n\9\9\9filesystemDialog.onCancel()\n\9\9end\n\9end\n\n\9filesystemDialog.submitButton.onTouch = function()\n\9\9onAnyTouch()\n\9\9\n\9\9local path = filesystemDialog.filesystemTree.selectedItem or filesystemDialog.filesystemTree.workPath or \"/\"\n\9\9if filesystemDialog.IOMode == GUI.IO_MODE_SAVE then\n\9\9\9path = path .. filesystemDialog.input.text\n\9\9\9\n\9\9\9if filesystemDialog.filesystemMode == GUI.IO_MODE_FILE then\n\9\9\9\9local selectedItem = filesystemDialog.extensionComboBox:getItem(filesystemDialog.extensionComboBox.selectedItem)\n\9\9\9\9path = path .. (selectedItem and selectedItem.text or \"\")\n\9\9\9else\n\9\9\9\9path = path .. \"/\"\n\9\9\9end\n\9\9end\n\n\9\9if filesystemDialog.onSubmit then\n\9\9\9filesystemDialog.onSubmit(path)\n\9\9end\n\9end\n\n\9filesystemDialog.show = filesystemDialogShow\n\n\9return filesystemDialog\nend\n\n--------------------------------------------------------------------------------\n\nlocal function filesystemChooserDraw(object)\n\9local tipWidth = object.height * 2 - 1\n\9local y = math.floor(object.y + object.height / 2)\n\9\n\9buffer.drawRectangle(object.x, object.y, object.width - tipWidth, object.height, object.colors.background, object.colors.text, \" \")\n\9buffer.drawRectangle(object.x + object.width - tipWidth, object.y, tipWidth, object.height, object.pressed and object.colors.tipText or object.colors.tipBackground, object.pressed and object.colors.tipBackground or object.colors.tipText, \" \")\n\9buffer.drawText(object.x + object.width - math.floor(tipWidth / 2) - 1, y, object.pressed and object.colors.tipBackground or object.colors.tipText, \"\")\n\9buffer.drawText(object.x + 1, y, object.colors.text, string.limit(object.path or object.placeholderText, object.width - tipWidth - 2, \"left\"))\n\n\9return filesystemChooser\nend\n\nlocal function filesystemChooserAddExtensionFilter(object, extension)\n\9object.extensionFilters[unicode.lower(extension)] = true\nend\n\nlocal function filesystemChooserSetMode(object, IOMode, filesystemMode)\n\9object.IOMode = IOMode\n\9object.filesystemMode = filesystemMode\nend\n\nlocal function filesystemChooserEventHandler(application, object, e1)\n\9if e1 == \"touch\" then\n\9\9object.pressed = true\n\9\9--application:draw()\n\n\9\9local filesystemDialog = GUI.addFilesystemDialog(application, false, 50, math.floor(application.height * 0.8), object.submitButtonText, object.cancelButtonText, object.placeholderText, object.filesystemDialogPath)\n\n\9\9for key in pairs(object.extensionFilters) do\n\9\9\9filesystemDialog:addExtensionFilter(key)\n\9\9end\n\n\9\9filesystemDialog:setMode(object.IOMode, object.filesystemMode)\n\n\9\9if object.path and #object.path > 0 then\n\9\9\9-- local path = object.path:gsub(\"/+\", \"/\")\n\9\9\9filesystemDialog.filesystemTree.selectedItem = object.IOMode == GUI.IO_MODE_OPEN and object.path or filesystem.path(object.path)\n\9\9\9filesystemDialog.input.text = filesystem.name(object.path)\n\9\9\9filesystemDialog:expandPath(object.IOMode == GUI.IO_MODE_OPEN and filesystem.path(object.path) or filesystem.path(filesystem.path(object.path)))\n\9\9end\n\9\9\n\9\9filesystemDialog.onCancel = function()\n\9\9\9object.pressed = false\n\9\9\9--application:draw()\n\9\9end\n\n\9\9filesystemDialog.onSubmit = function(path)\n\9\9\9object.path = path\n\9\9\9filesystemDialog.onCancel()\n\9\9\9if object.onSubmit then\n\9\9\9\9object.onSubmit(object.path)\n\9\9\9end\n\9\9end\n\n\9\9filesystemDialog:show()\n\9end\nend\n\nfunction GUI.filesystemChooser(x, y, width, height, backgroundColor, textColor, tipBackgroundColor, tipTextColor, path, submitButtonText, cancelButtonText, placeholderText, filesystemDialogPath)\n\9local object = GUI.object(x, y, width, height)\n\9\n\9object.eventHandler = comboBoxEventHandler\n\9object.colors = {\n\9\9tipBackground = tipBackgroundColor,\n\9\9tipText = tipTextColor,\n\9\9text = textColor,\n\9\9background = backgroundColor\n\9}\n\n\9object.submitButtonText = submitButtonText\n\9object.cancelButtonText = cancelButtonText\n\9object.placeholderText = placeholderText\n\9object.pressed = false\n\9object.path = path\n\9object.filesystemDialogPath = filesystemDialogPath\n\9object.filesystemMode = GUI.IO_MODE_FILE\n\9object.IOMode = GUI.IO_MODE_OPEN\n\9object.extensionFilters = {}\n\n\9object.draw = filesystemChooserDraw\n\9object.eventHandler = filesystemChooserEventHandler\n\9object.addExtensionFilter = filesystemChooserAddExtensionFilter\n\9object.setMode = filesystemChooserSetMode\n\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function resizerDraw(object)\n\9local horizontalMode, x, y, symbol = object.width >= object.height\n\n\9if horizontalMode then\n\9\9buffer.drawText(object.x, math.floor(object.y + object.height / 2), object.colors.helper, string.rep(\"\", object.width))\n\9\9\n\9\9if object.lastTouchX then\n\9\9\9buffer.drawText(object.lastTouchX, object.lastTouchY, object.colors.arrow, \"\")\n\9\9end\n\9else\n\9\9local x = math.floor(object.x + object.width / 2)\n\9\9local bufferWidth, bufferHeight, index = buffer.getResolution()\n\9\9\n\9\9for i = object.y, object.y + object.height - 1 do\n\9\9\9if x >= 1 and x <= bufferWidth and i >= 1 and i <= bufferHeight then\n\9\9\9\9index = buffer.getIndex(x, i)\n\9\9\9\9buffer.rawSet(index, buffer.rawGet(index), object.colors.helper, \"\")\n\9\9\9end\n\9\9end\n\n\9\9if object.lastTouchX then\n\9\9\9buffer.drawText(object.lastTouchX - 1, object.lastTouchY, object.colors.arrow, \"\")\n\9\9end\n\9end\nend\n\nlocal function resizerEventHandler(application, object, e1, e2, e3, e4)\n\9if e1 == \"touch\" then\n\9\9object.lastTouchX, object.lastTouchY = e3, e4\n\9\9--application:draw()\n\9elseif e1 == \"drag\" and object.lastTouchX then\9\9\n\9\9if object.onResize then\n\9\9\9object.onResize(e3 - object.lastTouchX, e4 - object.lastTouchY)\n\9\9end\n\9\9\n\9\9object.lastTouchX, object.lastTouchY = e3, e4\n\9\9--application:draw()\n\9elseif e1 == \"drop\" then\n\9\9if object.onResizeFinished then\n\9\9\9object.onResizeFinished()\n\9\9end\n\n\9\9object.lastTouchX, object.lastTouchY = nil, nil\n\9\9--application:draw()\n\9end\nend\n\nfunction GUI.resizer(x, y, width, height, helperColor, arrowColor)\n\9local object = GUI.object(x, y, width, height)\n\9\n\9object.colors = {\n\9\9helper = helperColor,\n\9\9arrow = arrowColor\n\9}\n\n\9object.draw = resizerDraw\n\9object.eventHandler = resizerEventHandler\n\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function scrollBarDraw(scrollBar)\n\9local isVertical = scrollBar.height > scrollBar.width\n\9local valuesDelta = scrollBar.maximumValue - scrollBar.minimumValue\n\9local part = scrollBar.value / valuesDelta\n\n\9if isVertical then\n\9\9local barSize = math.ceil(scrollBar.shownValueCount / valuesDelta * scrollBar.height)\n\9\9local halfBarSize = math.floor(barSize / 2)\n\9\9\n\9\9scrollBar.ghostPosition.y = scrollBar.y + halfBarSize\n\9\9scrollBar.ghostPosition.height = scrollBar.height - barSize\n\n\9\9if scrollBar.thin then\n\9\9\9local y1 = math.floor(scrollBar.ghostPosition.y + part * scrollBar.ghostPosition.height - halfBarSize)\n\9\9\9local y2 = y1 + barSize - 1\n\9\9\9local background\n\n\9\9\9for y = scrollBar.y, scrollBar.y + scrollBar.height - 1 do\n\9\9\9\9background = buffer.get(scrollBar.x, y)\n\9\9\9\9buffer.set(scrollBar.x, y, background, y >= y1 and y <= y2 and scrollBar.colors.foreground or scrollBar.colors.background, \"\")\n\9\9\9end\n\9\9else\n\9\9\9buffer.drawRectangle(scrollBar.x, scrollBar.y, scrollBar.width, scrollBar.height, scrollBar.colors.background, scrollBar.colors.foreground, \" \")\n\9\9\9buffer.drawRectangle(\n\9\9\9\9scrollBar.x,\n\9\9\9\9math.floor(scrollBar.ghostPosition.y + part * scrollBar.ghostPosition.height - halfBarSize),\n\9\9\9\9scrollBar.width,\n\9\9\9\9barSize,\n\9\9\9\9scrollBar.colors.foreground, 0x0, \" \"\n\9\9\9)\n\9\9end\n\9else\n\9\9local barSize = math.ceil(scrollBar.shownValueCount / valuesDelta * scrollBar.width)\n\9\9local halfBarSize = math.floor(barSize / 2)\n\9\9\n\9\9scrollBar.ghostPosition.x = scrollBar.x + halfBarSize\n\9\9scrollBar.ghostPosition.width = scrollBar.width - barSize\n\n\9\9if scrollBar.thin then\n\9\9\9local x1 = math.floor(scrollBar.ghostPosition.x + part * scrollBar.ghostPosition.width - halfBarSize)\n\9\9\9local x2 = x1 + barSize - 1\n\9\9\9local background\n\n\9\9\9for x = scrollBar.x, scrollBar.x + scrollBar.width - 1 do\n\9\9\9\9background = buffer.get(x, scrollBar.y)\n\9\9\9\9buffer.set(x, scrollBar.y, background, x >= x1 and x <= x2 and scrollBar.colors.foreground or scrollBar.colors.background, \"\")\n\9\9\9end\n\9\9else\n\9\9\9buffer.drawRectangle(scrollBar.x, scrollBar.y, scrollBar.width, scrollBar.height, scrollBar.colors.background, scrollBar.colors.foreground, \" \")\n\9\9\9buffer.drawRectangle(\n\9\9\9\9math.floor(scrollBar.ghostPosition.x + part * scrollBar.ghostPosition.width - halfBarSize),\n\9\9\9\9scrollBar.y,\n\9\9\9\9barSize,\n\9\9\9\9scrollBar.height,\n\9\9\9\9scrollBar.colors.foreground, 0x0, \" \"\n\9\9\9)\n\9\9end\n\9end\n\n\9return scrollBar\nend\n\nlocal function scrollBarEventHandler(application, object, e1, e2, e3, e4, e5, ...)\n\9local newValue = object.value\n\n\9if e1 == \"touch\" or e1 == \"drag\" then\n\9\9if object.height > object.width then\n\9\9\9if e4 == object.y + object.height - 1 then\n\9\9\9\9newValue = object.maximumValue\n\9\9\9else\n\9\9\9\9newValue = object.minimumValue + (e4 - object.y) / object.height * (object.maximumValue - object.minimumValue)\n\9\9\9end\n\9\9else\n\9\9\9if e3 == object.x + object.width - 1 then\n\9\9\9\9newValue = object.maximumValue\n\9\9\9else\n\9\9\9\9newValue = object.minimumValue + (e3 - object.x) / object.width * (object.maximumValue - object.minimumValue)\n\9\9\9end\n\9\9end\n\9elseif e1 == \"scroll\" then\n\9\9if e5 == 1 then\n\9\9\9if object.value >= object.minimumValue + object.onScrollValueIncrement then\n\9\9\9\9newValue = object.value - object.onScrollValueIncrement\n\9\9\9else\n\9\9\9\9newValue = object.minimumValue\n\9\9\9end\n\9\9else\n\9\9\9if object.value <= object.maximumValue - object.onScrollValueIncrement then\n\9\9\9\9newValue = object.value + object.onScrollValueIncrement\n\9\9\9else\n\9\9\9\9newValue = object.maximumValue\n\9\9\9end\n\9\9end\n\9end\n\n\9if e1 == \"touch\" or e1 == \"drag\" or e1 == \"scroll\" then\n\9\9object.value = newValue\n\9\9if object.onTouch then\n\9\9\9object.onTouch(application, object, e1, e2, e3, e4, e5, ...)\n\9\9end\n\n\9\9--application:draw()\n\9end\nend\n\nfunction GUI.scrollBar(x, y, width, height, backgroundColor, foregroundColor, minimumValue, maximumValue, value, shownValueCount, onScrollValueIncrement, thin)\n\9local scrollBar = GUI.object(x, y, width, height)\n\n\9scrollBar.eventHandler = scrollBarEventHandler\n\9scrollBar.maximumValue = maximumValue\n\9scrollBar.minimumValue = minimumValue\n\9scrollBar.value = value\n\9scrollBar.onScrollValueIncrement = onScrollValueIncrement\n\9scrollBar.shownValueCount = shownValueCount\n\9scrollBar.thin = thin\n\9scrollBar.colors = {\n\9\9background = backgroundColor,\n\9\9foreground = foregroundColor,\n\9}\n\9scrollBar.ghostPosition = {}\n\9scrollBar.draw = scrollBarDraw\n\n\9return scrollBar\nend\n\n--------------------------------------------------------------------------------\n\nlocal function treeDraw(tree)\9\n\9local y, yEnd, showScrollBar = tree.y, tree.y + tree.height - 1, #tree.items > tree.height\n\9local textLimit = tree.width - (showScrollBar and 1 or 0)\n\n\9if tree.colors.default.background then\n\9\9buffer.drawRectangle(tree.x, tree.y, tree.width, tree.height, tree.colors.default.background, tree.colors.default.expandable, \" \")\n\9end\n\n\9for i = tree.fromItem, #tree.items do\n\9\9local textColor, arrowColor, text = tree.colors.default.notExpandable, tree.colors.default.arrow, tree.items[i].expandable and \" \" or \" \"\n\n\9\9if tree.selectedItem == tree.items[i].definition then\n\9\9\9textColor, arrowColor = tree.colors.selected.any, tree.colors.selected.arrow\n\9\9\9buffer.drawRectangle(tree.x, y, tree.width, 1, tree.colors.selected.background, textColor, \" \")\n\9\9else\n\9\9\9if tree.items[i].expandable then\n\9\9\9\9textColor = tree.colors.default.expandable\n\9\9\9elseif tree.items[i].disabled then\n\9\9\9\9textColor = tree.colors.disabled\n\9\9\9end\n\9\9end\n\n\9\9if tree.items[i].expandable then\n\9\9\9buffer.drawText(tree.x + tree.items[i].offset, y, arrowColor, tree.expandedItems[tree.items[i].definition] and \"\" or \"\")\n\9\9end\n\n\9\9buffer.drawText(tree.x + tree.items[i].offset + 2, y, textColor, unicode.sub(text .. tree.items[i].name, 1, textLimit - tree.items[i].offset - 2))\n\n\9\9y = y + 1\n\9\9if y > yEnd then break end\n\9end\n\n\9if showScrollBar then\n\9\9local scrollBar = tree.scrollBar\n\9\9scrollBar.x = tree.x + tree.width - 1\n\9\9scrollBar.y = tree.y\n\9\9scrollBar.width = 1\n\9\9scrollBar.height = tree.height\n\9\9scrollBar.colors.background = tree.colors.scrollBar.background\n\9\9scrollBar.colors.foreground = tree.colors.scrollBar.foreground\n\9\9scrollBar.minimumValue = 1\n\9\9scrollBar.maximumValue = #tree.items\n\9\9scrollBar.value = tree.fromItem\n\9\9scrollBar.shownValueCount = tree.height\n\9\9scrollBar.onScrollValueIncrement = 1\n\9\9scrollBar.thin = true\n\n\9\9scrollBar:draw()\n\9end\n\n\9return tree\nend\n\nlocal function treeEventHandler(application, tree, e1, e2, e3, e4, e5, ...)\n\9if e1 == \"touch\" then\n\9\9local i = e4 - tree.y + tree.fromItem\n\9\9if tree.items[i] then\n\9\9\9if\n\9\9\9\9tree.items[i].expandable and\n\9\9\9\9(\n\9\9\9\9\9tree.selectionMode == GUI.IO_MODE_FILE or\n\9\9\9\9\9e3 >= tree.x + tree.items[i].offset - 1 and e3 <= tree.x + tree.items[i].offset + 1\n\9\9\9\9)\n\9\9\9then\n\9\9\9\9if tree.expandedItems[tree.items[i].definition] then\n\9\9\9\9\9tree.expandedItems[tree.items[i].definition] = nil\n\9\9\9\9else\n\9\9\9\9\9tree.expandedItems[tree.items[i].definition] = true\n\9\9\9\9end\n\n\9\9\9\9if tree.onItemExpanded then\n\9\9\9\9\9tree.onItemExpanded(tree.selectedItem, e1, e2, e3, e4, e5, ...)\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9if\n\9\9\9\9\9(\n\9\9\9\9\9\9tree.selectionMode == GUI.IO_MODE_BOTH or\n\9\9\9\9\9\9tree.selectionMode == GUI.IO_MODE_DIRECTORY and tree.items[i].expandable or\n\9\9\9\9\9\9tree.selectionMode == GUI.IO_MODE_FILE\n\9\9\9\9\9) and not tree.items[i].disabled\n\9\9\9\9then\n\9\9\9\9\9tree.selectedItem = tree.items[i].definition\n\n\9\9\9\9\9if tree.onItemSelected then\n\9\9\9\9\9\9tree.onItemSelected(tree.selectedItem, e1, e2, e3, e4, e5, ...)\n\9\9\9\9\9end\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9--application:draw()\n\9\9end\n\9elseif e1 == \"scroll\" then\n\9\9if e5 == 1 then\n\9\9\9if tree.fromItem > 1 then\n\9\9\9\9tree.fromItem = tree.fromItem - 1\n\9\9\9\9--application:draw()\n\9\9\9end\n\9\9else\n\9\9\9if tree.fromItem < #tree.items then\n\9\9\9\9tree.fromItem = tree.fromItem + 1\n\9\9\9\9--application:draw()\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function treeAddItem(tree, name, definition, offset, expandable, disabled)\n\9local item = {\n\9\9name = name, \n\9\9expandable = expandable,\n\9\9offset = offset or 0,\n\9\9definition = definition,\n\9\9disabled = disabled\n\9}\n\9table.insert(tree.items, item)\n\n\9return item\nend\n\nfunction GUI.tree(x, y, width, height, backgroundColor, expandableColor, notExpandableColor, arrowColor, backgroundSelectedColor, anySelectionColor, arrowSelectionColor, disabledColor, scrollBarBackground, scrollBarForeground, showMode, selectionMode)\n\9local tree = GUI.object(x, y, width, height)\n\9\n\9tree.eventHandler = treeEventHandler\n\9tree.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9expandable = expandableColor,\n\9\9\9notExpandable = notExpandableColor,\n\9\9\9arrow = arrowColor,\n\9\9},\n\9\9selected = {\n\9\9\9background = backgroundSelectedColor,\n\9\9\9any = anySelectionColor,\n\9\9\9arrow = arrowSelectionColor,\n\9\9},\n\9\9scrollBar = {\n\9\9\9background = scrollBarBackground,\n\9\9\9foreground = scrollBarForeground\n\9\9},\n\9\9disabled = disabledColor\n\9}\n\9tree.items = {}\n\9tree.fromItem = 1\n\9tree.selectedItem = nil\n\9tree.expandedItems = {}\n\n\9tree.scrollBar = GUI.scrollBar(1, 1, 1, 1, 0x0, 0x0, 1, 1, 1, 1, 1)\n\n\9tree.showMode = showMode\n\9tree.selectionMode = selectionMode\n\9tree.eventHandler = treeEventHandler\n\9tree.addItem = treeAddItem\n\9tree.draw = treeDraw\n\n\9return tree\nend\n\n--------------------------------------------------------------------------------\n\nlocal function filesystemTreeUpdateFileListRecursively(tree, path, offset)\n\9local list = {}\n\9for file in filesystem.list(path) do\n\9\9table.insert(list, file)\n\9end\n\n\9local i, expandables = 1, {}\n\9while i <= #list do\n\9\9if filesystem.isDirectory(path .. list[i]) then\n\9\9\9table.insert(expandables, list[i])\n\9\9\9table.remove(list, i)\n\9\9else\n\9\9\9i = i + 1\n\9\9end\n\9end\n\n\9table.sort(expandables, function(a, b) return unicode.lower(a) < unicode.lower(b) end)\n\9table.sort(list, function(a, b) return unicode.lower(a) < unicode.lower(b) end)\n\n\9if tree.showMode == GUI.IO_MODE_BOTH or tree.showMode == GUI.IO_MODE_DIRECTORY then\n\9\9for i = 1, #expandables do\n\9\9\9tree:addItem(filesystem.name(expandables[i]), path .. expandables[i], offset, true)\n\n\9\9\9if tree.expandedItems[path .. expandables[i]] then\n\9\9\9\9filesystemTreeUpdateFileListRecursively(tree, path .. expandables[i], offset + 2)\n\9\9\9end\n\9\9end\n\9end\n\n\9if tree.showMode == GUI.IO_MODE_BOTH or tree.showMode == GUI.IO_MODE_FILE then\n\9\9for i = 1, #list do\n\9\9\9tree:addItem(list[i], path .. list[i], offset, false, tree.extensionFilters and not tree.extensionFilters[filesystem.extension(path .. list[i], true)] or false)\n\9\9end\n\9end\nend\n\nlocal function filesystemTreeUpdateFileList(tree)\n\9tree.items = {}\n\9filesystemTreeUpdateFileListRecursively(tree, tree.workPath, 1)\nend\n\nlocal function filesystemTreeAddExtensionFilter(tree, extensionFilter)\n\9tree.extensionFilters = tree.extensionFilters or {}\n\9tree.extensionFilters[unicode.lower(extensionFilter)] = true\nend\n\nlocal function filesystemTreeExpandPath(tree, path)\n\9local blyadina = tree.workPath\n\9for pizda in path:gmatch(\"[^/]+\") do\n\9\9blyadina = blyadina .. pizda .. \"/\"\n\9\9tree.expandedItems[blyadina] = true\n\9end\nend\n\nfunction GUI.filesystemTree(...)\n\9local tree = GUI.tree(...)\n\n\9tree.workPath = \"/\"\n\9tree.updateFileList = filesystemTreeUpdateFileList\n\9tree.addExtensionFilter = filesystemTreeAddExtensionFilter\n\9tree.expandPath = filesystemTreeExpandPath\n\9tree.onItemExpanded = function()\n\9\9tree:updateFileList()\n\9end\n\n\9return tree\nend\n\n--------------------------------------------------------------------------------\n\nlocal function textBoxUpdate(object)\n\9local doubleVerticalOffset = object.offset.vertical * 2\n\9object.textWidth = object.width - object.offset.horizontal * 2 - (object.scrollBarEnabled and 1 or 0)\n\n\9object.linesCopy = {}\n\n\9if object.autoWrap then\n\9\9for i = 1, #object.lines do\n\9\9\9local isTable = type(object.lines[i]) == \"table\"\n\9\9\9for subLine in (isTable and object.lines[i].text or object.lines[i]):gmatch(\"[^\\n]+\") do\n\9\9\9\9local wrappedLine = string.wrap(subLine, object.textWidth)\n\9\9\9\9for j = 1, #wrappedLine do\n\9\9\9\9\9table.insert(object.linesCopy, isTable and {text = wrappedLine[j], color = object.lines[i].color} or wrappedLine[j])\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9else\n\9\9for i = 1, #object.lines do\n\9\9\9table.insert(object.linesCopy, object.lines[i])\n\9\9end\n\9end\n\n\9if object.autoHeight then\n\9\9object.height = #object.linesCopy + doubleVerticalOffset\n\9end\n\n\9object.textHeight = object.height - doubleVerticalOffset\nend\n\nlocal function textBoxDraw(object)\n\9object:update()\n\n\9if object.colors.background then\n\9\9buffer.drawRectangle(object.x, object.y, object.width, object.height, object.colors.background, object.colors.text, \" \", object.colors.transparency)\n\9end\n\n\9local x, y = nil, object.y + object.offset.vertical\n\9local lineType, text, textColor\n\9for i = object.currentLine, object.currentLine + object.textHeight - 1 do\n\9\9if object.linesCopy[i] then\n\9\9\9lineType = type(object.linesCopy[i])\n\9\9\9if lineType == \"string\" then\n\9\9\9\9text, textColor = string.limit(object.linesCopy[i], object.textWidth), object.colors.text\n\9\9\9elseif lineType == \"table\" then\n\9\9\9\9text, textColor = string.limit(object.linesCopy[i].text, object.textWidth), object.linesCopy[i].color\n\9\9\9else\n\9\9\9\9error(\"Unknown TextBox line type: \" .. tostring(lineType))\n\9\9\9end\n\n\9\9\9x = GUI.getAlignmentCoordinates(\n\9\9\9\9object.x + object.offset.horizontal,\n\9\9\9\0091,\n\9\9\9\9object.textWidth,\n\9\9\9\0091,\n\9\9\9\9object.horizontalAlignment,\n\9\9\9\9object.verticalAlignment,\n\9\9\9\9unicode.len(text),\n\9\9\9\0091\n\9\9\9)\n\n\9\9\9buffer.drawText(math.floor(x), y, textColor, text)\n\9\9\9y = y + 1\n\9\9else\n\9\9\9break\n\9\9end\n\9end\n\n\9if object.scrollBarEnabled and object.textHeight < #object.lines then\n\9\9object.scrollBar.x = object.x + object.width - 1\n\9\9object.scrollBar.y = object.y\n\9\9object.scrollBar.height = object.height\n\9\9object.scrollBar.maximumValue = #object.lines - object.textHeight + 1\n\9\9object.scrollBar.value = object.currentLine\n\9\9object.scrollBar.shownValueCount = object.textHeight\n\n\9\9object.scrollBar:draw()\n\9end\n\n\9return object\nend\n\nlocal function scrollDownTextBox(object, count)\n\9count = math.min(count or 1, #object.lines - object.height - object.currentLine + object.offset.vertical * 2 + 1)\n\9if #object.lines >= object.height and object.currentLine < #object.lines - count then\n\9\9object.currentLine = object.currentLine + count\n\9end\n\n\9return object\nend\n\nlocal function scrollUpTextBox(object, count)\n\9count = count or 1\n\9if object.currentLine > count and object.currentLine >= 1 then object.currentLine = object.currentLine - count end\n\9return object\nend\n\nlocal function scrollToStartTextBox(object)\n\9object.currentLine = 1\n\9return object\nend\n\nlocal function scrollToEndTextBox(object)\n\9if #object.lines > object.textHeight then\n\9\9object.currentLine = #object.lines - object.textHeight + 1\n\9end\n\n\9return object\nend\n\nlocal function textBoxScrollEventHandler(application, object, e1, e2, e3, e4, e5)\n\9if e1 == \"scroll\" then\n\9\9if e5 == 1 then\n\9\9\9object:scrollUp()\n\9\9else\n\9\9\9object:scrollDown()\n\9\9end\n\n\9\9--application:draw()\n\9end\nend\n\nfunction GUI.textBox(x, y, width, height, backgroundColor, textColor, lines, currentLine, horizontalOffset, verticalOffset, autoWrap, autoHeight)\n\9local object = GUI.object(x, y, width, height)\n\9\n\9object.colors = {\n\9\9text = textColor,\n\9\9background = backgroundColor\n\9}\n\9object.lines = lines\n\9object.currentLine = currentLine or 1\n\9object.scrollUp = scrollUpTextBox\n\9object.scrollDown = scrollDownTextBox\n\9object.scrollToStart = scrollToStartTextBox\n\9object.scrollToEnd = scrollToEndTextBox\n\9object.offset = {horizontal = horizontalOffset or 0, vertical = verticalOffset or 0}\n\9object.autoWrap = autoWrap\n\9object.autoHeight = autoHeight\n\9object.scrollBar = GUI.scrollBar(1, 1, 1, 1, 0xC3C3C3, 0x4B4B4B, 1, 1, 1, 1, 1, true)\n\9object.scrollBarEnabled = false\n\9\n\9object.eventHandler = textBoxScrollEventHandler\n\9object.draw = textBoxDraw\n\9object.update = textBoxUpdate\n\n\9object.setAlignment = GUI.setAlignment\n\9object:setAlignment(GUI.ALIGNMENT_HORIZONTAL_LEFT, GUI.ALIGNMENT_VERTICAL_TOP)\n\9object:update()\n\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function inputSetCursorPosition(input, newPosition)\n\9if newPosition < 1 then\n\9\9newPosition = 1\n\9elseif newPosition > unicode.len(input.text) + 1 then\n\9\9newPosition = unicode.len(input.text) + 1\n\9end\n\n\9if newPosition > input.textCutFrom + input.width - 1 - input.textOffset * 2 then\n\9\9input.textCutFrom = input.textCutFrom + newPosition - (input.textCutFrom + input.width - 1 - input.textOffset * 2)\n\9elseif newPosition < input.textCutFrom then\n\9\9input.textCutFrom = newPosition\n\9end\n\n\9input.cursorPosition = newPosition\n\n\9return input\nend\n\nlocal function inputTextDrawMethod(x, y, color, text)\n\9buffer.drawText(x, y, color, text)\nend\n\nlocal function inputDraw(input)\n\9local background, foreground, transparency, text\n\9if input.focused then\n\9\9background, transparency = input.colors.focused.background, input.colors.focused.transparency\n\9\9if input.text == \"\" then\n\9\9\9input.textCutFrom = 1\n\9\9\9foreground, text = input.colors.placeholderText, input.text\n\9\9else\n\9\9\9foreground = input.colors.focused.text\n\9\9\9if input.textMask then\n\9\9\9\9text = string.rep(input.textMask, unicode.len(input.text))\n\9\9\9else\n\9\9\9\9text = input.text\n\9\9\9end\n\9\9end\n\9else\n\9\9background, transparency = input.colors.default.background, input.colors.default.transparency\n\9\9if input.text == \"\" then\n\9\9\9input.textCutFrom = 1\n\9\9\9foreground, text = input.colors.placeholderText, input.placeholderText\n\9\9else\n\9\9\9foreground = input.colors.default.text\n\9\9\9if input.textMask then\n\9\9\9\9text = string.rep(input.textMask, unicode.len(input.text))\n\9\9\9else\n\9\9\9\9text = input.text\n\9\9\9end\n\9\9end\n\9end\n\n\9if background then\n\9\9buffer.drawRectangle(input.x, input.y, input.width, input.height, background, foreground, \" \", transparency)\n\9end\n\n\9local y = input.y + math.floor(input.height / 2)\n\n\9input.textDrawMethod(\n\9\9input.x + input.textOffset,\n\9\9y,\n\9\9foreground,\n\9\9unicode.sub(\n\9\9\9text or \"\",\n\9\9\9input.textCutFrom,\n\9\9\9input.textCutFrom + input.width - 1 - input.textOffset * 2\n\9\9)\n\9)\n\n\9if input.cursorBlinkState then\n\9\9local index = buffer.getIndex(input.x + input.cursorPosition - input.textCutFrom + input.textOffset, y)\n\9\9local background = buffer.rawGet(index)\n\9\9buffer.rawSet(index, background, input.colors.cursor, input.cursorSymbol)\n\9end\nend\n\nlocal function inputCursorBlink(application, input, state)\n\9input.cursorBlinkState = state\n\9input.cursorBlinkUptime = computer.uptime()\n\9--application:draw()\nend\n\nlocal function inputStopInput(application, input)\n\9input.stopInputObject:remove()\n\9input.focused = false\n\n\9if input.validator then\n\9\9if not input.validator(input.text) then\n\9\9\9input.text = input.startText\n\9\9\9input.startText = nil\n\n\9\9\9input:setCursorPosition(unicode.len(input.text) + 1)\n\9\9end\n\9end\n\9\n\9if input.onInputFinished then\n\9\9input.onInputFinished(application, input)\n\9end\n\n\9inputCursorBlink(application, input, false)\nend\n\nlocal function inputStartInput(input)\n\9input.startText = input.text\n\9input.focused = true\n\n\9if input.historyEnabled then\n\9\9input.historyIndex = input.historyIndex + 1\n\9end\n\n\9if input.eraseTextOnFocus then\n\9\9input.text = \"\"\n\9end\n\9\n\9input:setCursorPosition(unicode.len(input.text) + 1)\n\n\9input.stopInputObject.width, input.stopInputObject.height = input.firstParent.width, input.firstParent.height\n\9input.firstParent:addChild(input.stopInputObject)\n\n\9inputCursorBlink(input.firstParent, input, true)\nend\n\nlocal function inputEventHandler(application, input, e1, e2, e3, e4, e5, e6)\n\9if e1 == \"touch\" or e1 == \"drag\" then\n\9\9if input.focused then\n\9\9\9input:setCursorPosition(input.textCutFrom + e3 - input.x - input.textOffset)\n\9\9\9inputCursorBlink(application, input, true)\n\9\9else\n\9\9\9input:startInput()\n\9\9end\n\9elseif e1 == \"key_down\" and input.focused then\n\9\9application:consumeEvent()\n\n\9\9-- Return\n\9\9if e4 == 28 then\n\9\9\9if input.historyEnabled then\n\9\9\9\9--  \n\9\9\9\9for i = 1, (#input.history - input.historyLimit) do\n\9\9\9\9\9table.remove(input.history, 1)\n\9\9\9\9end\n\n\9\9\9\9--     \n\9\9\9\9if input.history[#input.history] ~= input.text and unicode.len(input.text) > 0 then\n\9\9\9\9\9table.insert(input.history, input.text)\n\9\9\9\9end\n\9\9\9\9input.historyIndex = #input.history\n\9\9\9end\n\n\9\9\9inputStopInput(application, input)\n\9\9\9return\n\9\9-- Arrows up/down/left/right\n\9\9elseif e4 == 200 then\n\9\9\9if input.historyEnabled and #input.history > 0 then\n\9\9\9\9--         \n\9\9\9\9if input.historyIndex == #input.history + 1 and unicode.len(input.text) > 0 then\n\9\9\9\9\9input.history[input.historyIndex] = input.text\n\9\9\9\9end\n\n\9\9\9\9input.historyIndex = input.historyIndex - 1\n\9\9\9\9if input.historyIndex > #input.history then\n\9\9\9\9\9input.historyIndex = #input.history\n\9\9\9\9elseif input.historyIndex < 1 then\n\9\9\9\9\9input.historyIndex = 1\n\9\9\9\9end\n\n\9\9\9\9input.text = input.history[input.historyIndex]\n\9\9\9\9input:setCursorPosition(unicode.len(input.text) + 1)\n\9\9\9end\n\9\9elseif e4 == 208 then\n\9\9\9if input.historyEnabled and #input.history > 0 then\n\9\9\9\9input.historyIndex = input.historyIndex + 1\n\9\9\9\9if input.historyIndex > #input.history then\n\9\9\9\9\9input.historyIndex = #input.history\n\9\9\9\9elseif input.historyIndex < 1 then\n\9\9\9\9\9input.historyIndex = 1\n\9\9\9\9end\n\9\9\9\9\n\9\9\9\9input.text = input.history[input.historyIndex]\n\9\9\9\9input:setCursorPosition(unicode.len(input.text) + 1)\n\9\9\9end\n\9\9elseif e4 == 203 then\n\9\9\9input:setCursorPosition(input.cursorPosition - 1)\n\9\9elseif e4 == 205 then\9\n\9\9\9input:setCursorPosition(input.cursorPosition + 1)\n\9\9-- Backspace\n\9\9elseif e4 == 14 then\n\9\9\9input.text = unicode.sub(unicode.sub(input.text, 1, input.cursorPosition - 1), 1, -2) .. unicode.sub(input.text, input.cursorPosition, -1)\n\9\9\9input:setCursorPosition(input.cursorPosition - 1)\n\9\9-- Delete\n\9\9elseif e4 == 211 then\n\9\9\9input.text = unicode.sub(input.text, 1, input.cursorPosition - 1) .. unicode.sub(input.text, input.cursorPosition + 1, -1)\n\9\9else\n\9\9\9local char = unicode.char(e3)\n\9\9\9if not keyboard.isControl(e3) then\n\9\9\9\9input.text = unicode.sub(input.text, 1, input.cursorPosition - 1) .. char .. unicode.sub(input.text, input.cursorPosition, -1)\n\9\9\9\9input:setCursorPosition(input.cursorPosition + 1)\n\9\9\9end\n\9\9end\n\n\9\9inputCursorBlink(application, input, true)\n\9elseif e1 == \"clipboard\" and input.focused then\n\9\9input.text = unicode.sub(input.text, 1, input.cursorPosition - 1) .. e3 .. unicode.sub(input.text, input.cursorPosition, -1)\n\9\9input:setCursorPosition(input.cursorPosition + unicode.len(e3))\n\9\9\n\9\9inputCursorBlink(application, input, true)\n\9\9application:consumeEvent()\n\9elseif not e1 and input.focused and computer.uptime() - input.cursorBlinkUptime > input.cursorBlinkDelay then\n\9\9inputCursorBlink(application, input, not input.cursorBlinkState)\n\9end\nend\n\nfunction GUI.input(x, y, width, height, backgroundColor, textColor, placeholderTextColor, backgroundFocusedColor, textFocusedColor, text, placeholderText, eraseTextOnFocus, textMask)\n\9local input = GUI.object(x, y, width, height)\n\9\n\9input.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9text = textColor\n\9\9},\n\9\9focused = {\n\9\9\9background = backgroundFocusedColor,\n\9\9\9text = textFocusedColor\n\9\9},\n\9\9placeholderText = placeholderTextColor,\n\9\9cursor = 0x00A8FF\n\9}\n\n\9input.text = text or \"\"\n\9input.placeholderText = placeholderText\n\9input.eraseTextOnFocus = eraseTextOnFocus\n\9input.textMask = textMask\n\n\9input.textOffset = 1\n\9input.textCutFrom = 1\n\9input.cursorPosition = 1\n\9input.cursorSymbol = \"\"\n\9input.cursorBlinkDelay = 0.4\n\9input.cursorBlinkState = false\n\9input.textMask = textMask\n\9input.setCursorPosition = inputSetCursorPosition\n\n\9input.history = {}\n\9input.historyLimit = 20\n\9input.historyIndex = 0\n\9input.historyEnabled = false\n\n\9input.stopInputObject = GUI.object(1, 1, 1, 1)\n\9input.stopInputObject.eventHandler = function(application, object, e1, e2, e3, e4, ...)\n\9\9if e1 == \"touch\" or e1 == \"drop\" then\n\9\9\9if \n\9\9\9\9e3 >= input.x and\n\9\9\9\9e3 < input.x + input.width and\n\9\9\9\9e4 >= input.y and\n\9\9\9\9e4 < input.y + input.height\n\9\9\9then\n\9\9\9\9input.eventHandler(application, input, e1, e2, e3, e4, ...)\n\9\9\9else\n\9\9\9\9inputStopInput(application, input)\n\9\9\9end\n\9\9end\n\9end\n\n\9input.textDrawMethod = inputTextDrawMethod\n\9input.draw = inputDraw\n\9input.eventHandler = inputEventHandler\n\9input.startInput = inputStartInput\n\n\9return input\nend\n\n--------------------------------------------------------------------------------\n\nlocal function autoCompleteDraw(object)\n\9local y, yEnd = object.y, object.y + object.height - 1\n\n\9buffer.drawRectangle(object.x, object.y, object.width, object.height, object.colors.default.background, object.colors.default.text, \" \")\n\n\9for i = object.fromItem, object.itemCount do\n\9\9local textColor, textMatchColor = object.colors.default.text, object.colors.default.textMatch\n\9\9if i == object.selectedItem then\n\9\9\9buffer.drawRectangle(object.x, y, object.width, 1, object.colors.selected.background, object.colors.selected.text, \" \")\n\9\9\9textColor, textMatchColor = object.colors.selected.text, object.colors.selected.textMatch\n\9\9end\n\n\9\9buffer.drawText(object.x + 1, y, textMatchColor, unicode.sub(object.matchText, 1, object.width - 2))\n\9\9buffer.drawText(object.x + object.matchTextLength + 1, y, textColor, unicode.sub(object.items[i], object.matchTextLength + 1, object.matchTextLength + object.width - object.matchTextLength - 2))\n\n\9\9y = y + 1\n\9\9if y > yEnd then\n\9\9\9break\n\9\9end\n\9end\n\n\9if object.itemCount > object.height then\n\9\9object.scrollBar.x = object.x + object.width - 1\n\9\9object.scrollBar.y = object.y\n\9\9object.scrollBar.height = object.height\n\9\9object.scrollBar.maximumValue = object.itemCount - object.height + 2\n\9\9object.scrollBar.value = object.fromItem\n\9\9object.scrollBar.shownValueCount = object.height\n\n\9\9object.scrollBar:draw()\n\9end\nend\n\nlocal function autoCompleteScroll(application, object, direction)\n\9if object.itemCount >= object.height then\n\9\9object.fromItem = object.fromItem + direction\n\9\9if object.fromItem < 1 then\n\9\9\9object.fromItem = 1\n\9\9elseif object.fromItem > object.itemCount - object.height + 1 then\n\9\9\9object.fromItem = object.itemCount - object.height + 1\n\9\9end\n\9end\nend\n\nlocal function autoCompleteEventHandler(application, object, e1, e2, e3, e4, e5, ...)\n\9if e1 == \"touch\" then\n\9\9object.selectedItem = e4 - object.y + object.fromItem\n\9\9--application:draw()\n\n\9\9if object.onItemSelected then\n\9\9\9os.sleep(0.2)\n\9\9\9object.onItemSelected(application, object, e1, e2, e3, e4, e5, ...)\n\9\9end\n\9elseif e1 == \"scroll\" then\n\9\9autoCompleteScroll(application, object, -e5)\n\9\9--application:draw()\n\9elseif e1 == \"key_down\" then\n\9\9if e4 == 28 then\n\9\9\9if object.onItemSelected then\n\9\9\9\9object.onItemSelected(application, object, e1, e2, e3, e4, e5, ...)\n\9\9\9end\n\9\9elseif e4 == 200 then\n\9\9\9object.selectedItem = object.selectedItem - 1\n\9\9\9if object.selectedItem < 1 then\n\9\9\9\9object.selectedItem = 1\n\9\9\9end\n\n\9\9\9if object.selectedItem == object.fromItem - 1 then\n\9\9\9\9autoCompleteScroll(application, object, -1)\n\9\9\9end\n\n\9\9\9--application:draw()\n\9\9elseif e4 == 208 then\n\9\9\9object.selectedItem = object.selectedItem + 1\n\9\9\9if object.selectedItem > object.itemCount then\n\9\9\9\9object.selectedItem = object.itemCount\n\9\9\9end\n\n\9\9\9if object.selectedItem == object.fromItem + object.height then\n\9\9\9\9autoCompleteScroll(application, object, 1)\n\9\9\9end\n\9\9\9\n\9\9\9--application:draw()\n\9\9end\n\9end\nend\n\nlocal function autoCompleteClear(object)\n\9object.items = {}\n\9object.itemCount = 0\n\9object.fromItem = 1\n\9object.selectedItem = 1\n\9object.height = 0\nend\n\nlocal function autoCompleteMatch(object, variants, text, asKey)\n\9object:clear()\n\9\n\9if asKey then\n\9\9if text then\n\9\9\9for key in pairs(variants) do\n\9\9\9\9if key ~= text and key:match(\"^\" .. text) then\n\9\9\9\9\9table.insert(object.items,key)\n\9\9\9\9end\n\9\9\9end\n\9\9else\n\9\9\9for key in pairs(variants) do\n\9\9\9\9table.insert(object.items, key)\n\9\9\9end\n\9\9end\n\9else\n\9\9if text then\n\9\9\9for i = 1, #variants do\n\9\9\9\9if variants[i] ~= text and variants[i]:match(\"^\" .. text) then\n\9\9\9\9\9table.insert(object.items, variants[i])\n\9\9\9\9end\n\9\9\9end\n\9\9else\n\9\9\9for i = 1, #variants do\n\9\9\9\9table.insert(object.items, variants[i])\n\9\9\9end\n\9\9end\n\9end\n\n\9object.matchText = text or \"\"\n\9object.matchTextLength = unicode.len(object.matchText)\n\n\9table.sort(object.items, function(a, b) return unicode.lower(a) < unicode.lower(b) end)\n\n\9object.itemCount = #object.items\n\9object.height = math.min(object.itemCount, object.maximumHeight)\n\n\9return object\nend\n\nfunction GUI.autoComplete(x, y, width, maximumHeight, backgroundColor, textColor, textMatchColor, backgroundSelectedColor, textSelectedColor, textMatchSelectedColor, scrollBarBackground, scrollBarForeground)\n\9local object = GUI.object(x, y, width, maximumHeight)\n\n\9object.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9text = textColor,\n\9\9\9textMatch = textMatchColor\9\n\9\9},\n\9\9selected = {\n\9\9\9background = backgroundSelectedColor,\n\9\9\9text = textSelectedColor,\n\9\9\9textMatch = textMatchSelectedColor\n\9\9}\n\9}\n\n\9object.maximumHeight = maximumHeight\n\9object.fromItem = 1\n\9object.selectedItem = 1\n\9object.items = {}\n\9object.matchText = \" \"\n\9object.matchTextLength = 1\n\9object.itemCount = 0\n\n\9object.scrollBar = GUI.scrollBar(1, 1, 1, 1, scrollBarBackground, scrollBarForeground, 1, 1, 1, 1, 1, true)\n\n\9object.match = autoCompleteMatch\n\9object.draw = autoCompleteDraw\n\9object.eventHandler = autoCompleteEventHandler\n\9object.clear = autoCompleteClear\n\n\9object:clear()\n\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nlocal function brailleCanvasDraw(brailleCanvas)\n\9local index, background, foreground, symbol\n\9for y = 1, brailleCanvas.height do\n\9\9for x = 1, brailleCanvas.width do\n\9\9\9index = buffer.getIndex(brailleCanvas.x + x - 1, brailleCanvas.y + y - 1)\n\9\9\9background, foreground, symbol = buffer.rawGet(index)\n\9\9\9buffer.rawSet(index, background, brailleCanvas.pixels[y][x][9], brailleCanvas.pixels[y][x][10])\n\9\9end\n\9end\n\n\9return brailleCanvas\nend\n\nlocal function brailleCanvasSet(brailleCanvas, x, y, state, color)\n\9local xReal, yReal = math.ceil(x / 2), math.ceil(y / 4)\n\9\n\9brailleCanvas.pixels[yReal][xReal][(y - (yReal - 1) * 4 - 1) * 2 + x - (xReal - 1) * 2] = state and 1 or 0\n\9brailleCanvas.pixels[yReal][xReal][9] = color or brailleCanvas.pixels[yReal][xReal][9]\n\9brailleCanvas.pixels[yReal][xReal][10] = unicode.char(\n\9\00910240 +\n\9\009128 * brailleCanvas.pixels[yReal][xReal][8] +\n\9\00964 * brailleCanvas.pixels[yReal][xReal][7] +\n\9\00932 * brailleCanvas.pixels[yReal][xReal][6] +\n\9\00916 * brailleCanvas.pixels[yReal][xReal][4] +\n\9\0098 * brailleCanvas.pixels[yReal][xReal][2] +\n\9\0094 * brailleCanvas.pixels[yReal][xReal][5] +\n\9\0092 * brailleCanvas.pixels[yReal][xReal][3] +\n\9\9brailleCanvas.pixels[yReal][xReal][1]\n\9)\n\n\9return brailleCanvas\nend\n\nlocal function brailleCanvasGet(brailleCanvas, x, y)\n\9local xReal, yReal = math.ceil(x / 2), math.ceil(y / 4)\n\9return brailleCanvas.pixels[yReal][xReal][(y - (yReal - 1) * 4 - 1) * 2 + x - (xReal - 1) * 2], brailleCanvas.pixels[yReal][xReal][9], brailleCanvas.pixels[yReal][xReal][10]\nend\n\nlocal function brailleCanvasFill(brailleCanvas, x, y, width, height, state, color)\n\9for j = y, y + height - 1 do\n\9\9for i = x, x + width - 1 do\n\9\9\9brailleCanvas:set(i, j, state, color)\n\9\9end\n\9end\nend\n\nlocal function brailleCanvasClear(brailleCanvas)\n\9for j = 1, brailleCanvas.height * 4 do\n\9\9brailleCanvas.pixels[j] = {}\n\9\9for i = 1, brailleCanvas.width * 2 do\n\9\9\9brailleCanvas.pixels[j][i] = { 0, 0, 0, 0, 0, 0, 0, 0, 0x0, \" \" }\n\9\9end\n\9end\nend\n\nfunction GUI.brailleCanvas(x, y, width, height)\n\9local brailleCanvas = GUI.object(x, y, width, height)\n\9\n\9brailleCanvas.pixels = {}\n\n\9brailleCanvas.get = brailleCanvasGet\n\9brailleCanvas.set = brailleCanvasSet\n\9brailleCanvas.fill = brailleCanvasFill\n\9brailleCanvas.clear = brailleCanvasClear\n\n\9brailleCanvas.draw = brailleCanvasDraw\n\n\9brailleCanvas:clear()\n\n\9return brailleCanvas\nend\n\n--------------------------------------------------------------------------------\n\nlocal function paletteShow(palette)\n\9local application = GUI.application()\n\9\n\9application:addChild(palette)\n\n\9palette.submitButton.onTouch = function()\n\9\9application:stop()\n\9end\n\9palette.cancelButton.onTouch = palette.submitButton.onTouch\n\n\9--application:draw()\n\9application:start()\9\n\n\9return palette.color.integer\nend\n\nfunction GUI.palette(x, y, startColor)\n\9local palette = GUI.window(x, y, 71, 25)\n\9\n\9palette.color = {hsb = {}, rgb = {}}\n\9palette:addChild(GUI.panel(1, 1, palette.width, palette.height, 0xF0F0F0))\n\9\n\9local bigImage = palette:addChild(GUI.image(1, 1, image.create(50, 25)))\n\9local bigCrest = palette:addChild(GUI.object(1, 1, 5, 3))\n\n\9local function paletteDrawBigCrestPixel(x, y, symbol)\n\9\9local background, foreground = buffer.get(x, y)\n\9\9local r, g, b = color.integerToRGB(background)\n\9\9buffer.set(x, y, background, (r + g + b) / 3 >= 127 and 0x0 or 0xFFFFFF, symbol)\n\9end\n\n\9bigCrest.draw = function(object)\n\9\9paletteDrawBigCrestPixel(object.x, object.y + 1, \"\")\n\9\9paletteDrawBigCrestPixel(object.x + 1, object.y + 1, \"\")\n\9\9paletteDrawBigCrestPixel(object.x + 3, object.y + 1, \"\")\n\9\9paletteDrawBigCrestPixel(object.x + 4, object.y + 1, \"\")\n\9\9paletteDrawBigCrestPixel(object.x + 2, object.y, \"\")\n\9\9paletteDrawBigCrestPixel(object.x + 2, object.y + 2, \"\")\n\9end\n\9bigCrest.passScreenEvents = true\n\9\n\9local miniImage = palette:addChild(GUI.image(53, 1, image.create(3, 25)))\n\9\n\9local miniCrest = palette:addChild(GUI.object(52, 1, 5, 1))\n\9miniCrest.draw = function(object)\n\9\9buffer.drawText(object.x, object.y, 0x0, \">\")\n\9\9buffer.drawText(object.x + 4, object.y, 0x0, \"<\")\n\9end\n\n\9local colorPanel = palette:addChild(GUI.panel(58, 2, 12, 3, 0x0))\n\9palette.submitButton = palette:addChild(GUI.roundedButton(58, 6, 12, 1, 0x4B4B4B, 0xFFFFFF, 0x2D2D2D, 0xFFFFFF, \"OK\"))\n\9palette.cancelButton = palette:addChild(GUI.roundedButton(58, 8, 12, 1, 0xFFFFFF, 0x696969, 0x2D2D2D, 0xFFFFFF, \"Cancel\"))\n\n\9local function paletteRefreshBigImage()\n\9\9local saturationStep, brightnessStep, saturation, brightness = 1 / bigImage.width, 1 / bigImage.height, 0, 1\n\9\9for j = 1, bigImage.height do\n\9\9\9for i = 1, bigImage.width do\n\9\9\9\9image.set(bigImage.image, i, j, color.optimize(color.HSBToInteger(palette.color.hsb.hue, saturation, brightness)), 0x0, 0x0, \" \")\n\9\9\9\9saturation = saturation + saturationStep\n\9\9\9end\n\9\9\9saturation, brightness = 0, brightness - brightnessStep\n\9\9end\n\9end\n\n\9local function paletteRefreshMiniImage()\n\9\9local hueStep, hue = 360 / miniImage.height, 0\n\9\9for j = 1, miniImage.height do\n\9\9\9for i = 1, miniImage.width do\n\9\9\9\9image.set(miniImage.image, i, j, color.optimize(color.HSBToInteger(hue, 1, 1)), 0x0, 0, \" \")\n\9\9\9end\n\9\9\9hue = hue + hueStep\n\9\9end\n\9end\n\n\9local function paletteUpdateCrestsCoordinates()\n\9\9bigCrest.localX = math.floor((bigImage.width - 1) * palette.color.hsb.saturation) - 1\n\9\9bigCrest.localY = math.floor((bigImage.height - 1) - (bigImage.height - 1) * palette.color.hsb.brightness)\n\9\9miniCrest.localY = math.ceil(palette.color.hsb.hue / 360 * miniImage.height + 0.5)\n\9end\n\n\9local inputs\n\n\9local function paletteUpdateInputs()\n\9\9inputs[1].text = tostring(palette.color.rgb.red)\n\9\9inputs[2].text = tostring(palette.color.rgb.green)\n\9\9inputs[3].text = tostring(palette.color.rgb.blue)\n\9\9inputs[4].text = tostring(math.floor(palette.color.hsb.hue))\n\9\9inputs[5].text = tostring(math.floor(palette.color.hsb.saturation * 100))\n\9\9inputs[6].text = tostring(math.floor(palette.color.hsb.brightness * 100))\n\9\9inputs[7].text = string.format(\"%06X\", palette.color.integer)\n\9\9colorPanel.colors.background = palette.color.integer\n\9end\n\n\9local function paletteSwitchColorFromHex(hex)\n\9\9palette.color.integer = hex\n\9\9palette.color.rgb.red, palette.color.rgb.green, palette.color.rgb.blue = color.integerToRGB(hex)\n\9\9palette.color.hsb.hue, palette.color.hsb.saturation, palette.color.hsb.brightness = color.RGBToHSB(palette.color.rgb.red, palette.color.rgb.green, palette.color.rgb.blue)\n\9\9paletteUpdateInputs()\n\9end\n\n\9local function paletteSwitchColorFromHsb(hue, saturation, brightness)\n\9\9palette.color.hsb.hue, palette.color.hsb.saturation, palette.color.hsb.brightness = hue, saturation, brightness\n\9\9palette.color.rgb.red, palette.color.rgb.green, palette.color.rgb.blue = color.HSBToRGB(hue, saturation, brightness)\n\9\9palette.color.integer = color.RGBToInteger(palette.color.rgb.red, palette.color.rgb.green, palette.color.rgb.blue)\n\9\9paletteUpdateInputs()\n\9end\n\n\9local function paletteSwitchColorFromRgb(red, green, blue)\n\9\9palette.color.rgb.red, palette.color.rgb.green, palette.color.rgb.blue = red, green, blue\n\9\9palette.color.hsb.hue, palette.color.hsb.saturation, palette.color.hsb.brightness = color.RGBToHSB(red, green, blue)\n\9\9palette.color.integer = color.RGBToInteger(red, green, blue)\n\9\9paletteUpdateInputs()\n\9end\n\n\9local function onAnyInputFinished()\n\9\9paletteRefreshBigImage()\n\9\9paletteUpdateCrestsCoordinates()\n\9\9palette.firstParent:draw()\n\9end\n\n\9local function onHexInputFinished()\n\9\9paletteSwitchColorFromHex(tonumber(\"0x\" .. inputs[7].text))\n\9\9onAnyInputFinished()\n\9end\n\n\9local function onRgbInputFinished()\n\9\9paletteSwitchColorFromRgb(tonumber(inputs[1].text), tonumber(inputs[2].text), tonumber(inputs[3].text))\n\9\9onAnyInputFinished()\n\9end\n\n\9local function onHsbInputFinished()\n\9\9paletteSwitchColorFromHsb(tonumber(inputs[4].text), tonumber(inputs[5].text) / 100, tonumber(inputs[6].text) / 100)\n\9\9onAnyInputFinished()\n\9end\n\n\9local function rgbValidaror(text)\n\9\9local number = tonumber(text) if number and number >= 0 and number <= 255 then return true end\n\9end\n\n\9local function hValidator(text)\n\9\9local number = tonumber(text) if number and number >= 0 and number <= 359 then return true end\n\9end\n\n\9local function sbValidator(text)\n\9\9local number = tonumber(text) if number and number >= 0 and number <= 100 then return true end\n\9end\n\n\9local function hexValidator(text)\n\9\9if string.match(text, \"^[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]$\") then\n\9\9\9return true\n\9\9end\n\9end\n\n\9inputs = {\n\9\9{ shortcut = \"R:\", validator = rgbValidaror, onInputFinished = onRgbInputFinished },\n\9\9{ shortcut = \"G:\", validator = rgbValidaror, onInputFinished = onRgbInputFinished },\n\9\9{ shortcut = \"B:\", validator = rgbValidaror, onInputFinished = onRgbInputFinished },\n\9\9{ shortcut = \"H:\", validator = hValidator,   onInputFinished = onHsbInputFinished },\n\9\9{ shortcut = \"S:\", validator = sbValidator,  onInputFinished = onHsbInputFinished },\n\9\9{ shortcut = \"L:\", validator = sbValidator,  onInputFinished = onHsbInputFinished },\n\9\9{ shortcut = \"0x\", validator = hexValidator, onInputFinished = onHexInputFinished }\n\9}\n\n\9local y = 10\n\9for i = 1, #inputs do\n\9\9palette:addChild(GUI.label(58, y, 2, 1, 0x0, inputs[i].shortcut))\n\9\9\n\9\9local validator, onInputFinished = inputs[i].validator, inputs[i].onInputFinished\n\9\9inputs[i] = palette:addChild(GUI.input(61, y, 9, 1, 0xFFFFFF, 0x696969, 0x696969, 0xFFFFFF, 0x0, \"\", \"\", true))\n\9\9inputs[i].validator = validator\n\9\9inputs[i].onInputFinished = onInputFinished\n\9\9\n\9\9y = y + 2\n\9end\n\9\n\9local favourites\n\9if filesystem.exists(GUI.PALETTE_CONFIG_PATH) then\n\9\9favourites = table.fromFile(GUI.PALETTE_CONFIG_PATH)\n\9else\n\9\9favourites = {}\n\9\9for i = 1, 6 do favourites[i] = color.HSBToInteger(math.random(0, 360), 1, 1) end\n\9\9table.toFile(GUI.PALETTE_CONFIG_PATH, favourites)\n\9end\n\n\9local favouritesContainer = palette:addChild(GUI.container(58, 24, 12, 1))\n\9for i = 1, #favourites do\n\9\9favouritesContainer:addChild(GUI.button(i * 2 - 1, 1, 2, 1, favourites[i], 0x0, 0x0, 0x0, \" \")).onTouch = function(application)\n\9\9\9paletteSwitchColorFromHex(favourites[i])\n\9\9\9paletteRefreshBigImage()\n\9\9\9paletteUpdateCrestsCoordinates()\n\9\9\9--application:draw()\n\9\9end\n\9end\n\9\n\9palette:addChild(GUI.button(58, 25, 12, 1, 0xFFFFFF, 0x4B4B4B, 0x2D2D2D, 0xFFFFFF, \"+\")).onTouch = function(application)\n\9\9local favouriteExists = false\n\9\9for i = 1, #favourites do\n\9\9\9if favourites[i] == palette.color.integer then\n\9\9\9\9favouriteExists = true\n\9\9\9\9break\n\9\9\9end\n\9\9end\n\9\9\n\9\9if not favouriteExists then\n\9\9\9table.insert(favourites, 1, palette.color.integer)\n\9\9\9table.remove(favourites, #favourites)\n\9\9\9for i = 1, #favourites do\n\9\9\9\9favouritesContainer.children[i].colors.default.background = favourites[i]\n\9\9\9\9favouritesContainer.children[i].colors.pressed.background = 0x0\n\9\9\9end\n\9\9\9\n\9\9\9table.toFile(GUI.PALETTE_CONFIG_PATH, favourites)\n\n\9\9\9--application:draw()\n\9\9end\n\9end\n\n\9bigImage.eventHandler = function(application, object, e1, e2, e3, e4)\n\9\9if e1 == \"touch\" or e1 == \"drag\" then\n\9\9\9bigCrest.localX, bigCrest.localY = e3 - palette.x - 1, e4 - palette.y\n\9\9\9paletteSwitchColorFromHex(select(3, component.gpu.get(e3, e4)))\n\9\9\9--application:draw()\n\9\9end\n\9end\n\9\n\9miniImage.eventHandler = function(application, object, e1, e2, e3, e4)\n\9\9if e1 == \"touch\" or e1 == \"drag\" then\n\9\9\9miniCrest.localY = e4 - palette.y + 1\n\9\9\9paletteSwitchColorFromHsb((e4 - miniImage.y) * 360 / miniImage.height, palette.color.hsb.saturation, palette.color.hsb.brightness)\n\9\9\9paletteRefreshBigImage()\n\9\9\9--application:draw()\n\9\9end\n\9end\n\n\9palette.show = paletteShow\n\n\9paletteSwitchColorFromHex(startColor)\n\9paletteUpdateCrestsCoordinates()\n\9paletteRefreshBigImage()\n\9paletteRefreshMiniImage()\n\n\9return palette\nend\n\n--------------------------------------------------------------------------------\n\nlocal function textUpdate(object)\n\9object.width = unicode.len(object.text)\n\9return object\nend\n\nlocal function textDraw(object)\n\9object:update()\n\9buffer.drawText(object.x, object.y, object.color, object.text)\n\9return object\nend\n\nfunction GUI.text(x, y, color, text)\n\9local object = GUI.object(x, y, 1, 1)\n\n\9object.text = text\n\9object.color = color\n\9object.update = textUpdate\n\9object.draw = textDraw\n\9object:update()\n\n\9return object\nend\n\n--------------------------------------------------------------------------------\n\nfunction GUI.addBackgroundContainer(parentContainer, addPanel, addLayout, title)\n\9local container = parentContainer:addChild(GUI.container(1, 1, parentContainer.width, parentContainer.height))\n\9\n\9if addPanel then\n\9\9container.panel = container:addChild(GUI.panel(1, 1, container.width, container.height, GUI.BACKGROUND_CONTAINER_PANEL_COLOR, GUI.BACKGROUND_CONTAINER_PANEL_TRANSPARENCY))\n\9\9container.panel.eventHandler = function(parentContainer, object, e1)\n\9\9\9if e1 == \"touch\" then\n\9\9\9\9container:remove()\n\9\9\9\9parentContainer:draw()\n\9\9\9end\n\9\9end\n\9end\n\n\9if addLayout then\n\9\9container.layout = container:addChild(GUI.layout(1, 1, container.width, container.height, 1, 1))\n\n\9\9if title then\n\9\9\9container.label = container.layout:addChild(GUI.label(1, 1, 1, 1, GUI.BACKGROUND_CONTAINER_TITLE_COLOR, title)):setAlignment(GUI.ALIGNMENT_HORIZONTAL_CENTER, GUI.ALIGNMENT_VERTICAL_TOP)\n\9\9end\n\9end\n\n\9return container\nend\n\n--------------------------------------------------------------------------------\n\nlocal function listUpdate(list)\n\9local step, child = false\n\9for i = 1, #list.children do\n\9\9child = list.children[i]\n\9\9--  \n\9\9child.pressed = i == list.selectedItem\n\9\9\n\9\9--  \n\9\9if step then\n\9\9\9child.colors.default = list.colors.alternating\n\9\9else\n\9\9\9child.colors.default = list.colors.default\n\9\9end\n\9\9child.colors.pressed, step = list.colors.selected, not step\n\9\9\n\9\9--  \n\9\9if list.cells[1][1].direction == GUI.DIRECTION_HORIZONTAL then\n\9\9\9if list.offsetMode then\n\9\9\9\9child.width, child.height = list.itemSize * 2 + unicode.len(child.text), list.height\n\9\9\9else\n\9\9\9\9child.width, child.height = list.itemSize, list.height\n\9\9\9end\n\9\9else\n\9\9\9if list.offsetMode then\n\9\9\9\9child.width, child.height = list.width, list.itemSize * 2 + 1\n\9\9\9else\n\9\9\9\9child.width, child.height = list.width, list.itemSize\n\9\9\9end\n\9\9end\n\9end\n\n\9layoutUpdate(list)\nend\n\nlocal function listItemEventHandler(application, item, e1, ...)\n\9if e1 == \"touch\" or e1 == \"drag\" then\n\9\9item.parent.selectedItem = item:indexOf()\n\9\9item.parent:update()\n\9\9--application:draw()\n\n\9\9if item.onTouch then\n\9\9\9item.onTouch(application, item, e1, ...)\n\9\9end\n\9end\nend\n\nlocal function listAddItem(list, text)\n\9local item = list:addChild(pressable(1, 1, 1, 1, 0, 0, 0, 0, 0, 0, text))\n\9\n\9item.switchMode = true\n\9item.eventHandler = listItemEventHandler\n\n\9return item\nend\n\nlocal function listSetAlignment(list, ...)\n\9layoutSetAlignment(list, 1, 1, ...)\n\9return list\nend\n\nlocal function listSetSpacing(list, ...)\n\9layoutSetSpacing(list, 1, 1, ...)\n\9return list\nend\n\nlocal function listSetDirection(list, ...)\n\9layoutSetDirection(list, 1, 1, ...)\n\9return list\nend\n\nlocal function listSetFitting(list, ...)\n\9layoutSetFitting(list, 1, 1, ...)\n\9return list\nend\n\nlocal function listSetMargin(list, ...)\n\9layoutSetMargin(list, 1, 1, ...)\n\9return list\nend\n\nlocal function listGetMargin(list, ...)\n\9return layoutGetMargin(list, 1, 1, ...)\nend\n\nlocal function listGetItem(list, what)\n\9if type(what) == \"number\" then\n\9\9return list.children[what]\n\9else\n\9\9for i = 1, #list.children do\n\9\9\9if list.children[i].text == what then\n\9\9\9\9return list.children[i], i\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function listCount(list)\n\9return #list.children\nend\n\nlocal function listDraw(list)\n\9buffer.drawRectangle(list.x, list.y, list.width, list.height, list.colors.default.background, list.colors.default.text, \" \")\n\9layoutDraw(list)\nend\n\nfunction GUI.list(x, y, width, height, itemSize, spacing, backgroundColor, textColor, backgroundAlternatingColor, textAlternatingColor, backgroundSelectedColor, textSelectedColor, offsetMode)\n\9local list = GUI.layout(x, y, width, height, 1, 1)\n\n\9list.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9text = textColor\n\9\9},\n\9\9alternating = {\n\9\9\9background = backgroundAlternatingColor,\n\9\9\9text = textAlternatingColor\n\9\9},\n\9\9selected = {\n\9\9\9background = backgroundSelectedColor,\n\9\9\9text = textSelectedColor\n\9\9},\n\9}\n\n\9list.passScreenEvents = false\n\9list.selectedItem = 1\n\9list.offsetMode = offsetMode\n\9list.itemSize = itemSize\n\9\n\9list.addItem = listAddItem\n\9list.getItem = listGetItem\n\9list.count = listCount\n\9list.setAlignment = listSetAlignment\n\9list.setSpacing = listSetSpacing\n\9list.setDirection = listSetDirection\n\9list.setFitting = listSetFitting\n\9list.setMargin = listSetMargin\n\9list.getMargin = listGetMargin\n\9list.update = listUpdate\n\9list.draw = listDraw\n\n\9list:setAlignment(GUI.ALIGNMENT_HORIZONTAL_LEFT, GUI.ALIGNMENT_VERTICAL_TOP)\n\9list:setSpacing(spacing)\n\9list:setDirection(GUI.DIRECTION_VERTICAL)\n\n\9return list\nend\n\n---------------------------------------------------------------------------------------------------\n\nlocal function keyAndValueUpdate(object)\n\9object.keyLength, object.valueLength = unicode.len(object.key), unicode.len(object.value)\n\9object.width = object.keyLength + object.valueLength\nend\n\nlocal function keyAndValueDraw(object)\n\9keyAndValueUpdate(object)\n\9buffer.drawText(object.x, object.y, object.colors.key, object.key)\n\9buffer.drawText(object.x + object.keyLength, object.y, object.colors.value, object.value)\nend\n\nfunction GUI.keyAndValue(x, y, keyColor, valueColor, key, value)\n\9local object = GUI.object(x, y, 1, 1)\n\9\n\9object.colors = {\n\9\9key = keyColor,\n\9\9value = valueColor\n\9}\n\9object.key = key\n\9object.value = value\n\n\9object.update = keyAndValueUpdate\n\9object.draw = keyAndValueDraw\n\n\9object:update()\n\n\9return object\nend\n\n---------------------------------------------------------------------------------------------------\n\nfunction GUI.highlightString(x, y, width, fromChar, indentationWidth, patterns, colorScheme, s)\n\9fromChar = fromChar or 1\n\9\n\9local counter, symbols, colors, stringLength, bufferIndex, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, searchFrom, starting, ending = indentationWidth, {}, {}, unicode.len(s), buffer.getIndex(x, y), buffer.getNewFrameTables()\n\9local toChar = math.min(stringLength, fromChar + width - 1)\n\n\9--   \n\9for i = fromChar, toChar do\n\9\9symbols[i] = unicode.sub(s, i, i)\n\9end\n\n\9--      \n\9for j = 1, #patterns, 4 do\n\9\9searchFrom = 1\n\9\9\n\9\9while true do\n\9\9\9starting, ending = string.unicodeFind(s, patterns[j], searchFrom)\n\9\9\9\n\9\9\9if starting then\n\9\9\9\9for i = starting + patterns[j + 2], ending - patterns[j + 3] do\n\9\9\9\9\9colors[i] = colorScheme[patterns[j + 1]]\n\9\9\9\9end\n\9\9\9else\n\9\9\9\9break\n\9\9\9end\n\n\9\9\9searchFrom = ending + 1 - patterns[j + 3]\n\9\9end\n\9end\n\n\9--  \n\9for i = fromChar, toChar do\n\9\9if symbols[i] == \" \" then\n\9\9\9colors[i] = colorScheme.indentation\n\9\9\9\n\9\9\9if counter == indentationWidth then\n\9\9\9\9symbols[i], counter = \"\", 0\n\9\9\9end\n\n\9\9\9counter = counter + 1\n\9\9else\n\9\9\9break\n\9\9end\n\9end\n\n\9--  \n\9for i = fromChar, toChar do\n\9\9newFrameForegrounds[bufferIndex], newFrameSymbols[bufferIndex] = colors[i] or colorScheme.text, symbols[i] or \" \"\n\9\9bufferIndex = bufferIndex + 1\n\9end\nend\n\n--------------------------------------------------------------------------------\n\nlocal function dropDownMenuItemDraw(item)\n\9local yText = item.y + math.floor(item.height / 2)\n\n\9if item.type == 1 then\n\9\9local textColor = item.color or item.parent.parent.colors.default.text\n\n\9\9if item.pressed then\n\9\9\9textColor = item.parent.parent.colors.selected.text\n\9\9\9buffer.drawRectangle(item.x, item.y, item.width, item.height, item.parent.parent.colors.selected.background, textColor, \" \")\n\9\9elseif item.disabled then\n\9\9\9textColor = item.parent.parent.colors.disabled.text\n\9\9end\n\n\9\9buffer.drawText(item.x + 1, yText, textColor, item.text)\n\9\9if item.shortcut then\n\9\9\9buffer.drawText(item.x + item.width - unicode.len(item.shortcut) - 1, yText, textColor, item.shortcut)\n\9\9end\n\9else\n\9\9buffer.drawText(item.x, yText, item.parent.parent.colors.separator, string.rep(\"\", item.width))\n\9end\n\n\9return item\nend\n\nlocal function dropDownMenuReleaseItems(menu)\n\9for i = 1, #menu.itemsContainer.children do\n\9\9menu.itemsContainer.children[i].pressed = false\n\9end\n\n\9return menu\nend\n\nlocal function dropDownMenuItemEventHandler(application, object, e1, ...)\n\9if e1 == \"touch\" then\n\9\9if object.type == 1 and not object.pressed then\n\9\9\9object.pressed = true\n\9\9\9--application:draw()\n\n\9\9\9if object.subMenu then\n\9\9\9\9object.parent.parent.parent:addChild(object.subMenu:releaseItems())\n\9\9\9\9object.subMenu.localX = object.parent.parent.localX + object.parent.parent.width\n\9\9\9\9object.subMenu.localY = object.parent.parent.localY + object.localY - 1\n\9\9\9\9if buffer.getWidth() - object.parent.parent.localX - object.parent.parent.width + 1 < object.subMenu.width then\n\9\9\9\9\9object.subMenu.localX = object.parent.parent.localX - object.subMenu.width\n\9\9\9\9\9object.parent.parent:moveToFront()\n\9\9\9\9end\n\n\9\9\9\9--application:draw()\n\9\9\9else\n\9\9\9\9os.sleep(0.2)\n\n\9\9\9\9object.parent.parent.parent:remove()\n\9\9\9\9\n\9\9\9\9local objectIndex = object:indexOf()\n\9\9\9\9for i = 2, #object.parent.parent.parent.children do\n\9\9\9\9\9if object.parent.parent.parent.children[i].onMenuClosed then\n\9\9\9\9\9\9object.parent.parent.parent.children[i].onMenuClosed(objectIndex)\n\9\9\9\9\9end\n\9\9\9\9end\n\n\9\9\9\9if object.onTouch then\n\9\9\9\9\9object.onTouch()\n\9\9\9\9end\n\n\9\9\9\9--application:draw()\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function dropDownMenuGetHeight(menu)\n\9local height = 0\n\9for i = 1, #menu.itemsContainer.children do\n\9\9height = height + (menu.itemsContainer.children[i].type == 2 and 1 or menu.itemHeight)\n\9end\n\n\9return height\nend\n\nlocal function dropDownMenuReposition(menu)\n\9menu.itemsContainer.width, menu.itemsContainer.height = menu.width, menu.height\n\9menu.prevButton.width, menu.nextButton.width = menu.width, menu.width\n\9menu.nextButton.localY = menu.height\n\n\9local y = menu.itemsContainer.children[1].localY\n\9for i = 1, #menu.itemsContainer.children do\n\9\9menu.itemsContainer.children[i].localY = y\n\9\9menu.itemsContainer.children[i].width = menu.itemsContainer.width\n\9\9y = y + menu.itemsContainer.children[i].height\n\9end\n\n\9menu.prevButton.hidden = menu.itemsContainer.children[1].localY >= 1\n\9menu.nextButton.hidden = menu.itemsContainer.children[#menu.itemsContainer.children].localY + menu.itemsContainer.children[#menu.itemsContainer.children].height - 1 <= menu.height\nend\n\nlocal function dropDownMenuUpdate(menu)\n\9if #menu.itemsContainer.children > 0 then\n\9\9menu.height = math.min(dropDownMenuGetHeight(menu), menu.maximumHeight, buffer.getHeight() - menu.y)\n\9\9dropDownMenuReposition(menu)\n\9end\nend\n\nlocal function dropDownMenuRemoveItem(menu, index)\n\9table.remove(menu.itemsContainer.children, index)\n\n\9menu:update()\n\n\9return menu\nend\n\nlocal function dropDownMenuAddItem(menu, text, disabled, shortcut, color)\n\9local item = menu.itemsContainer:addChild(GUI.object(1, 1, 1, menu.itemHeight))\n\9item.type = 1\n\9item.text = text\n\9item.disabled = disabled\n\9item.shortcut = shortcut\n\9item.color = color\n\9item.draw = dropDownMenuItemDraw\n\9item.eventHandler = dropDownMenuItemEventHandler\n\n\9menu:update()\n\n\9return item\nend\n\nlocal function dropDownMenuAddSeparator(menu)\n\9local item = menu.itemsContainer:addChild(GUI.object(1, 1, 1, 1))\n\9item.type = 2\n\9item.draw = dropDownMenuItemDraw\n\9item.eventHandler = dropDownMenuItemEventHandler\n\n\9menu:update()\n\n\9return item\nend\n\nlocal function dropDownMenuScrollDown(application, menu)\n\9if menu.itemsContainer.children[1].localY < 1 then\n\9\9for i = 1, #menu.itemsContainer.children do\n\9\9\9menu.itemsContainer.children[i].localY = menu.itemsContainer.children[i].localY + 1\n\9\9end\n\n\9\9dropDownMenuReposition(menu)\n\9\9--application:draw()\n\9end\nend\n\nlocal function dropDownMenuScrollUp(application, menu)\n\9if menu.itemsContainer.children[#menu.itemsContainer.children].localY + menu.itemsContainer.children[#menu.itemsContainer.children].height - 1 > menu.height then\n\9\9for i = 1, #menu.itemsContainer.children do\n\9\9\9menu.itemsContainer.children[i].localY = menu.itemsContainer.children[i].localY - 1\n\9\9end\n\n\9\9dropDownMenuReposition(menu)\n\9\9--application:draw()\n\9end\nend\n\nlocal function dropDownMenuEventHandler(application, menu, e1, e2, e3, e4, e5)\n\9if e1 == \"scroll\" then\n\9\9if e5 == 1 then\n\9\9\9dropDownMenuScrollDown(application, menu)\n\9\9else\n\9\9\9dropDownMenuScrollUp(application, menu)\n\9\9end\n\9end\nend\n\nlocal function dropDownMenuPrevButtonOnTouch(application, button)\n\9dropDownMenuScrollDown(application, button.parent)\nend\n\nlocal function dropDownMenuNextButtonOnTouch(application, button)\n\9dropDownMenuScrollUp(application, button.parent)\nend\n\nlocal function dropDownMenuDraw(menu)\n\9buffer.drawRectangle(menu.x, menu.y, menu.width, menu.height, menu.colors.default.background, menu.colors.default.text, \" \", menu.colors.transparency.background)\n\9GUI.drawShadow(menu.x, menu.y, menu.width, menu.height, menu.colors.transparency.shadow, true)\n\9containerDraw(menu)\nend\n\nlocal function dropDownMenuBackgroundObjectEventHandler(application, object, e1)\n\9if e1 == \"touch\" then\n\9\9for i = 2, #object.parent.children do\n\9\9\9if object.parent.children[i].onMenuClosed then\n\9\9\9\9object.parent.children[i].onMenuClosed()\n\9\9\9end\n\9\9end\n\n\9\9object.parent:remove()\n\9\9--application:draw()\n\9end\nend\n\nlocal function dropDownMenuAdd(parentContainer, menu)\n\9local container = parentContainer:addChild(GUI.container(1, 1, parentContainer.width, parentContainer.height))\n\9container:addChild(GUI.object(1, 1, container.width, container.height)).eventHandler = dropDownMenuBackgroundObjectEventHandler\n\9\n\9return container:addChild(menu:releaseItems())\nend\n\nfunction GUI.dropDownMenu(x, y, width, maximumHeight, itemHeight, backgroundColor, textColor, backgroundPressedColor, textPressedColor, disabledColor, separatorColor, backgroundTransparency, shadowTransparency)\n\9local menu = GUI.container(x, y, width, 1)\n\9\n\9menu.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9text = textColor\n\9\9},\n\9\9selected = {\n\9\9\9background = backgroundPressedColor,\n\9\9\9text = textPressedColor\n\9\9},\n\9\9disabled = {\n\9\9\9text = disabledColor\n\9\9},\n\9\9separator = separatorColor,\n\9\9transparency = {\n\9\9\9background = backgroundTransparency,\n\9\9\9shadow = shadowTransparency\n\9\9}\n\9}\n\n\9menu.itemsContainer = menu:addChild(GUI.container(1, 1, menu.width, menu.height))\n\9menu.prevButton = menu:addChild(GUI.button(1, 1, menu.width, 1, backgroundColor, textColor, backgroundPressedColor, textPressedColor, \"\"))\n\9menu.nextButton = menu:addChild(GUI.button(1, 1, menu.width, 1, backgroundColor, textColor, backgroundPressedColor, textPressedColor, \"\"))\n\9menu.prevButton.colors.transparency, menu.nextButton.colors.transparency = backgroundTransparency, backgroundTransparency\n\9menu.prevButton.onTouch = dropDownMenuPrevButtonOnTouch\n\9menu.nextButton.onTouch = dropDownMenuNextButtonOnTouch\n\n\9menu.releaseItems = dropDownMenuReleaseItems\n\9menu.itemHeight = itemHeight\n\9menu.addSeparator = dropDownMenuAddSeparator\n\9menu.addItem = dropDownMenuAddItem\n\9menu.removeItem = dropDownMenuRemoveItem\n\9menu.draw = dropDownMenuDraw\n\9menu.maximumHeight = maximumHeight\n\9menu.eventHandler = dropDownMenuEventHandler\n\9menu.update = dropDownMenuUpdate\n\n\9return menu\nend\n\n--------------------------------------------------------------------------------\n\nlocal function contextMenuUpdate(menu)\n\9if #menu.itemsContainer.children > 0 then\n\9\9local widestItem, widestShortcut = 0, 0\n\9\9for i = 1, #menu.itemsContainer.children do\n\9\9\9if menu.itemsContainer.children[i].type == 1 then\n\9\9\9\9widestItem = math.max(widestItem, unicode.len(menu.itemsContainer.children[i].text))\n\9\9\9\9if menu.itemsContainer.children[i].shortcut then\n\9\9\9\9\9widestShortcut = math.max(widestShortcut, unicode.len(menu.itemsContainer.children[i].shortcut))\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\n\9\9menu.width, menu.height = 2 + widestItem + (widestShortcut > 0 and 3 + widestShortcut or 0), math.min(dropDownMenuGetHeight(menu), menu.maximumHeight)\n\9\9dropDownMenuReposition(menu)\n\n\9\9local bufferWidth, bufferHeight = buffer.getResolution()\n\9\9if menu.x + menu.width + 1 >= bufferWidth then\n\9\9\9menu.localX = bufferWidth - menu.width - 1\n\9\9end\n\9\9if menu.y + menu.height >= bufferHeight then\n\9\9\9menu.localY = bufferHeight - menu.height\n\9\9end\n\9end\nend\n\nlocal contextMenuCreate, contextMenuAddSubMenu\n\ncontextMenuAddSubMenu = function(menu, text, disabled)\n\9local item = menu:addItem(text, disabled, \"\")\n\9item.subMenu = contextMenuCreate(1, 1)\n\9item.subMenu.colors = menu.colors\n\9\n\9return item.subMenu\nend\n\ncontextMenuCreate = function(x, y, backgroundColor, textColor, backgroundPressedColor, textPressedColor, disabledColor, separatorColor, backgroundTransparency, shadowTransparency)\n\9local menu = GUI.dropDownMenu(\n\9\9x,\n\9\9y,\n\9\0091,\n\9\9math.ceil(buffer.getHeight() * 0.5),\n\9\0091,\n\9\9backgroundColor or GUI.CONTEXT_MENU_DEFAULT_BACKGROUND_COLOR,\n\9\9textColor or GUI.CONTEXT_MENU_DEFAULT_TEXT_COLOR,\n\9\9backgroundPressedColor or GUI.CONTEXT_MENU_PRESSED_BACKGROUND_COLOR,\n\9\9textPressedColor or GUI.CONTEXT_MENU_PRESSED_TEXT_COLOR,\n\9\9disabledColor or GUI.CONTEXT_MENU_DISABLED_COLOR,\n\9\9separatorColor or GUI.CONTEXT_MENU_SEPARATOR_COLOR,\n\9\9backgroundTransparency or GUI.CONTEXT_MENU_BACKGROUND_TRANSPARENCY,\n\9\9shadowTransparency or GUI.CONTEXT_MENU_SHADOW_TRANSPARENCY\n\9)\n\n\9menu.update = contextMenuUpdate\n\9menu.addSubMenu = contextMenuAddSubMenu\n\n\9return menu\nend\n\nfunction GUI.addContextMenu(parentContainer, arg1, ...)\n\9if type(arg1) == \"table\" then\n\9\9return dropDownMenuAdd(parentContainer, arg1, ...)\n\9else\n\9\9return dropDownMenuAdd(parentContainer, contextMenuCreate(arg1, ...))\n\9end\nend\n\n--------------------------------------------------------------------------------\n\nlocal function comboBoxDraw(object)\n\9buffer.drawRectangle(object.x, object.y, object.width, object.height, object.colors.default.background, object.colors.default.text, \" \")\n\9if object.dropDownMenu.itemsContainer.children[object.selectedItem] then\n\9\9buffer.drawText(object.x + 1, math.floor(object.y + object.height / 2), object.colors.default.text, string.limit(object.dropDownMenu.itemsContainer.children[object.selectedItem].text, object.width - object.height - 2, \"right\"))\n\9end\n\n\9local width = object.height * 2 - 1\n\9buffer.drawRectangle(object.x + object.width - object.height * 2 + 1, object.y, width, object.height, object.colors.arrow.background, object.colors.arrow.text, \" \")\n\9buffer.drawText(math.floor(object.x + object.width - width / 2), math.floor(object.y + object.height / 2), object.colors.arrow.text, object.pressed and \"\" or \"\")\n\n\9return object\nend\n\nlocal function comboBoxGetItem(object, what)\n\9if type(what) == \"number\" then\n\9\9return object.dropDownMenu.itemsContainer.children[what]\n\9else\n\9\9local children = object.dropDownMenu.itemsContainer.children\n\9\9for i = 1, #children do\n\9\9\9if children[i].text == what then\n\9\9\9\9return children[i], i\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function comboBoxRemoveItem(object, index)\n\9object.dropDownMenu:removeItem(index)\n\9if object.selectedItem > #object.dropDownMenu.itemsContainer.children then\n\9\9object.selectedItem = #object.dropDownMenu.itemsContainer.children\n\9end\nend\n\nlocal function comboBoxCount(object)\n\9return #object.dropDownMenu.itemsContainer.children\nend\n\nlocal function comboBoxClear(object)\n\9object.dropDownMenu.itemsContainer:removeChildren()\n\9object.selectedItem = 1\n\n\9return object\nend\n\nlocal function comboBoxEventHandler(application, object, e1, ...)\n\9if e1 == \"touch\" and #object.dropDownMenu.itemsContainer.children > 0 then\n\9\9object.pressed = true\n\9\9object.dropDownMenu.x, object.dropDownMenu.y, object.dropDownMenu.width = object.x, object.y + object.height, object.width\n\9\9object.dropDownMenu:update()\n\9\9dropDownMenuAdd(application, object.dropDownMenu)\n\9\9--application:draw()\n\9end\nend\n\nlocal function comboBoxAddItem(object, ...)\n\9return object.dropDownMenu:addItem(...)\nend\n\nlocal function comboBoxAddSeparator(object)\n\9return object.dropDownMenu:addSeparator()\nend\n\nfunction GUI.comboBox(x, y, width, itemSize, backgroundColor, textColor, arrowBackgroundColor, arrowTextColor)\n\9local comboBox = GUI.object(x, y, width, itemSize)\n\9\n\9comboBox.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9text = textColor\n\9\9},\n\9\9selected = {\n\9\9\9background = GUI.CONTEXT_MENU_PRESSED_BACKGROUND_COLOR,\n\9\9\9text = GUI.CONTEXT_MENU_PRESSED_TEXT_COLOR\n\9\9},\n\9\9arrow = {\n\9\9\9background = arrowBackgroundColor,\n\9\9\9text = arrowTextColor\n\9\9}\n\9}\n\n\9comboBox.dropDownMenu = GUI.dropDownMenu(\n\9\0091,\n\9\0091,\n\9\0091,\n\9\9math.ceil(buffer.getHeight() * 0.5),\n\9\9itemSize,\n\9\9comboBox.colors.default.background, \n\9\9comboBox.colors.default.text, \n\9\9comboBox.colors.selected.background,\n\9\9comboBox.colors.selected.text,\n\9\9GUI.CONTEXT_MENU_DISABLED_COLOR,\n\9\9GUI.CONTEXT_MENU_SEPARATOR_COLOR,\n\9\9GUI.CONTEXT_MENU_BACKGROUND_TRANSPARENCY, \n\9\9GUI.CONTEXT_MENU_SHADOW_TRANSPARENCY\n\9)\n\n\9comboBox.dropDownMenu.onMenuClosed = function(index)\n\9\9comboBox.pressed = false\n\9\9comboBox.selectedItem = index or comboBox.selectedItem\n\9\9comboBox.firstParent:draw()\n\9\9\n\9\9if index and comboBox.onItemSelected then\n\9\9\9comboBox.onItemSelected(index)\n\9\9end\n\9end\n\n\9comboBox.selectedItem = 1\n\9comboBox.addItem = comboBoxAddItem\n\9comboBox.removeItem = comboBoxRemoveItem\n\9comboBox.addSeparator = comboBoxAddSeparator\n\9comboBox.draw = comboBoxDraw\n\9comboBox.clear = comboBoxClear\n\9comboBox.getItem = comboBoxGetItem\n\9comboBox.count = comboBoxCount\n\9comboBox.eventHandler = comboBoxEventHandler\n\n\9return comboBox\nend\n\n---------------------------------------------------------------------------------------------------\n\nfunction windowDraw(window)\n\9containerDraw(window)\n\9GUI.drawShadow(window.x, window.y, window.width, window.height, GUI.WINDOW_SHADOW_TRANSPARENCY, true)\n\n\9return window\nend\n\nlocal function windowCheck(window, x, y)\n\9local child\n\9for i = #window.children, 1, -1 do\n\9\9child = window.children[i]\n\9\9\n\9\9if\n\9\9\9not child.hidden and\n\9\9\9not child.disabled and\n\9\9\9x >= child.x and\n\9\9\9x < child.x + child.width and\n\9\9\9y >= child.y and\n\9\9\9y < child.y + child.height\n\9\9then\n\9\9\9if not child.passScreenEvents and child.eventHandler then\n\9\9\9\9return true\n\9\9\9elseif child.children then\n\9\9\9\9local result = windowCheck(child, x, y)\n\9\9\9\9if result == true then\n\9\9\9\9\9return true\n\9\9\9\9elseif result == false then\n\9\9\9\9\9return false\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function windowEventHandler(application, window, e1, e2, e3, e4, ...)\n\9if e1 == \"touch\" then\n\9\9if not windowCheck(window, e3, e4) then\n\9\9\9window.lastTouchX, window.lastTouchY = e3, e4\n\9\9end\n\n\9\9if window ~= window.parent.children[#window.parent.children] then\n\9\9\9window:moveToFront()\n\9\9\9\n\9\9\9if window.onFocus then\n\9\9\9\9window.onFocus(application, window, e1, e2, e3, e4, ...)\n\9\9\9end\n\n\9\9\9--application:draw()\n\9\9end\n\9elseif e1 == \"drag\" and window.lastTouchX and not windowCheck(window, e3, e4) then\n\9\9local xOffset, yOffset = e3 - window.lastTouchX, e4 - window.lastTouchY\n\9\9if xOffset ~= 0 or yOffset ~= 0 then\n\9\9\9window.localX, window.localY = window.localX + xOffset, window.localY + yOffset\n\9\9\9window.lastTouchX, window.lastTouchY = e3, e4\n\9\9\9\n\9\9\9--application:draw()\n\9\9end\n\9elseif e1 == \"drop\" then\n\9\9window.lastTouchX, window.lastTouchY = nil, nil\n\9end\nend\n\nlocal function windowResize(window, width, height)\n\9window.width, window.height = width, height\n\9if window.onResize then\n\9\9window.onResize(width, height)\n\9end\n\n\9return window\nend\n\nlocal function windowMaximize(window)\n\9if window.maximized then\n\9\9window.localX, window.localY = window.oldGeometryX, window.oldGeometryY\n\9\9window:resize(window.oldGeometryWidth, window.oldGeometryHeight)\n\9else\n\9\9window.oldGeometryX, window.oldGeometryY, window.oldGeometryWidth, window.oldGeometryHeight = window.localX, window.localY, window.width, window.height\n\9\9window.localX, window.localY = 1, 1\n\9\9window:resize(window.parent.width, window.parent.height)\n\9end\n\n\9window.maximized = not window.maximized\n\9window.firstParent:draw()\nend\n\nlocal function windowMinimize(window)\n\9window.hidden = not window.hidden\n\9window.firstParent:draw()\nend\n\nlocal function windowClose(window)\n\9window:remove()\n\9window.firstParent:draw()\nend\n\nfunction GUI.window(x, y, width, height)\n\9local window = GUI.container(x, y, width, height)\n\9\n\9window.passScreenEvents = false\n\n\9window.resize = windowResize\n\9window.maximize = windowMaximize\n\9window.minimize = windowMinimize\n\9window.close = windowClose\n\9window.eventHandler = windowEventHandler\n\9window.draw = windowDraw\n\n\9return window\nend\n\nfunction GUI.filledWindow(x, y, width, height, backgroundColor)\n\9local window = GUI.window(x, y, width, height)\n\n\9window.backgroundPanel = window:addChild(GUI.panel(1, 1, width, height, backgroundColor))\n\9window.actionButtons = window:addChild(GUI.actionButtons(2, 2, true))\n\n\9return window\nend\n\nfunction GUI.titledWindow(x, y, width, height, title, addTitlePanel)\n\9local window = GUI.filledWindow(x, y, width, height, GUI.WINDOW_BACKGROUND_PANEL_COLOR)\n\n\9if addTitlePanel then\n\9\9window.titlePanel = window:addChild(GUI.panel(1, 1, width, 1, GUI.WINDOW_TITLE_BACKGROUND_COLOR))\n\9\9window.backgroundPanel.localY, window.backgroundPanel.height = 2, window.height - 1\n\9end\n\n\9window.titleLabel = window:addChild(GUI.label(1, 1, width, height, GUI.WINDOW_TITLE_TEXT_COLOR, title)):setAlignment(GUI.ALIGNMENT_HORIZONTAL_CENTER, GUI.ALIGNMENT_VERTICAL_TOP)\n\9window.actionButtons.localY = 1\n\9window.actionButtons:moveToFront()\n\n\9return window\nend\n\nfunction GUI.tabbedWindow(x, y, width, height, ...)\n\9local window = GUI.filledWindow(x, y, width, height, GUI.WINDOW_BACKGROUND_PANEL_COLOR)\n\n\9window.tabBar = window:addChild(GUI.tabBar(1, 1, window.width, 3, 2, 0, GUI.WINDOW_TAB_BAR_DEFAULT_BACKGROUND_COLOR, GUI.WINDOW_TAB_BAR_DEFAULT_TEXT_COLOR, GUI.WINDOW_TAB_BAR_DEFAULT_BACKGROUND_COLOR, GUI.WINDOW_TAB_BAR_DEFAULT_TEXT_COLOR, GUI.WINDOW_TAB_BAR_SELECTED_BACKGROUND_COLOR, GUI.WINDOW_TAB_BAR_SELECTED_TEXT_COLOR, true))\n\9\n\9window.backgroundPanel.localY, window.backgroundPanel.height = 4, window.height - 3\n\9window.actionButtons:moveToFront()\n\9window.actionButtons.localY = 2\n\n\9return window\nend\n\n---------------------------------------------------------------------------------------------------\n\nfunction GUI.tabBar(...)\n\9local tabBar = GUI.list(...)\n\n\9tabBar:setDirection(GUI.DIRECTION_HORIZONTAL)\n\9tabBar:setAlignment(GUI.ALIGNMENT_HORIZONTAL_CENTER, GUI.ALIGNMENT_VERTICAL_TOP)\n\n\9return tabBar\nend\n\n--------------------------------------------------------------------------------\n\nlocal function menuDraw(menu)\n\9buffer.drawRectangle(menu.x, menu.y, menu.width, 1, menu.colors.default.background, menu.colors.default.text, \" \", menu.colors.transparency)\n\9layoutDraw(menu)\nend\n\nlocal function menuAddItem(menu, text, textColor)\n\9local item = menu:addChild(pressable(1, 1, unicode.len(text) + 2, 1, nil, textColor or menu.colors.default.text, menu.colors.selected.background, menu.colors.selected.text, 0x0, 0x0, text))\n\9item.eventHandler = pressableEventHandler\n\n\9return item\nend\n\nlocal function menuGetItem(menu, what)\n\9if type(what) == \"number\" then\n\9\9return menu.children[what]\n\9else\n\9\9for i = 1, #menu.children do\n\9\9\9if menu.children[i].text == what then\n\9\9\9\9return menu.children[i], i\n\9\9\9end\n\9\9end\n\9end\nend\n\nlocal function menuContextMenuItemOnTouch(application, item)\n\9item.contextMenu.x, item.contextMenu.y = item.x, item.y + 1\n\9dropDownMenuAdd(application, item.contextMenu)\n\n\9--application:draw()\nend\n\nlocal function menuAddContextMenu(menu, ...)\n\9local item = menu:addItem(...)\n\n\9item.switchMode = true\n\9item.onTouch = menuContextMenuItemOnTouch\n\9item.contextMenu = contextMenuCreate(1, 1)\n\9item.contextMenu.onMenuClosed = function()\n\9\9item.pressed = false\n\9\9item.firstParent:draw()\n\9end\n\n\9return item.contextMenu\nend\n\nfunction GUI.menu(x, y, width, backgroundColor, textColor, backgroundPressedColor, textPressedColor, backgroundTransparency)\n\9local menu = GUI.layout(x, y, width, 1, 1, 1)\n\9\n\9menu.colors = {\n\9\9default = {\n\9\9\9background = backgroundColor,\n\9\9\9text = textColor,\n\9\9},\n\9\9selected = {\n\9\9\9background = backgroundPressedColor,\n\9\9\9text = textPressedColor,\n\9\9},\n\9\9transparency = backgroundTransparency\n\9}\n\9\n\9menu.passScreenEvents = false\n\9menu.addContextMenu = menuAddContextMenu\n\9menu.addItem = menuAddItem\n\9menu.getItem = menuGetItem\n\9menu.draw = menuDraw\n\n\9menu:setDirection(1, 1, GUI.DIRECTION_HORIZONTAL)\n\9menu:setAlignment(1, 1, GUI.ALIGNMENT_HORIZONTAL_LEFT, GUI.ALIGNMENT_VERTICAL_TOP)\n\9menu:setSpacing(1, 1, 0)\n\9menu:setMargin(1, 1, 1, 0)\n\n\9return menu\nend\n\n---------------------------------------------------------------------------------------------------\n\nlocal function progressIndicatorDraw(self)\n\9local color = self.active and (self.position == 1 and self.colors.secondary or self.colors.primary) or self.colors.passive\n\9buffer.drawText(self.x + 1, self.y, color, \"\")\n\9buffer.drawText(self.x + 2, self.y, color, \"\")\n\n\9color = self.active and (self.position == 2 and self.colors.secondary or self.colors.primary) or self.colors.passive\n\9buffer.drawText(self.x + 3, self.y + 1, color, \"\")\n\9buffer.drawText(self.x + 2, self.y + 1, color, \"\")\n\n\9color = self.active and (self.position == 3 and self.colors.secondary or self.colors.primary) or self.colors.passive\n\9buffer.drawText(self.x + 1, self.y + 2, color, \"\")\n\9buffer.drawText(self.x + 2, self.y + 2, color, \"\")\n\n\9color = self.active and (self.position == 4 and self.colors.secondary or self.colors.primary) or self.colors.passive\n\9buffer.drawText(self.x, self.y + 1, color, \"\")\n\9buffer.drawText(self.x + 1, self.y + 1, color, \"\")\nend\n\nlocal function progressIndicatorRoll(self)\n\9self.position = self.position + 1\n\9if self.position > 4 then\n\9\9self.position = 1\n\9end\nend\n\nlocal function progressIndicatorReset(self, state)\n\9self.active = state\n\9self.position = 1\nend\n\nfunction GUI.progressIndicator(x, y, passiveColor, primaryColor, secondaryColor)\n\9local object = GUI.object(x, y, 4, 3)\n\9\n\9object.colors = {\n\9\9passive = passiveColor,\n\9\9primary = primaryColor,\n\9\9secondary = secondaryColor\n\9}\n\n\9object.active = false\n\9object.reset = progressIndicatorReset\n\9object.draw = progressIndicatorDraw\n\9object.roll = progressIndicatorRoll\n\n\9object:reset()\n\n\9return object\nend\n\n---------------------------------------------------------------------------------------------------\n\nreturn GUI\n",["./libs/thirdParty/OCIF.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are possibly made some changes if needed to fit in to the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/Image>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nOCIF Copyright (c) 2018 Igor Timofeev\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\n\13\nlocal args = {...}\13\nlocal image = args[1]\13\n\13\nlocal bit32 = require(\"bit32\")\13\nrequire(\"libs/thirdParty/AdvancedLua\")\13\nlocal unicode = require(\"unicode\")\13\nlocal fs = require(\"filesystem\")\13\nlocal color = require(\"libs/thirdParty/color\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal module = {}\13\nlocal OCIFSignature = \"OCIF\"\13\nlocal encodingMethods = {\13\n\9load = {},\13\n\9save = {}\13\n}\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function writeByteArrayToFile(file, byteArray)\13\n\9for i = 1, #byteArray do\13\n\9\9file:write(string.char(byteArray[i]))\13\n\9end\13\nend\13\n\13\nlocal function readNumberFromFile(file, countOfBytes)\13\n\9local byteArray = {}\13\n\9for i = 1, countOfBytes do\13\n\9\9table.insert(byteArray, string.byte(file:read(1)))\13\n\9end\13\n\13\n\9return bit32.byteArrayToNumber(byteArray)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nencodingMethods.save[5] = function(file, picture)\13\n\9for i = 1, #picture[3] do\13\n\9\9file:write(string.char(color.to8Bit(picture[3][i])))\13\n\9\9file:write(string.char(color.to8Bit(picture[4][i])))\13\n\9\9file:write(string.char(math.floor(picture[5][i] * 255)))\13\n\9\9writeByteArrayToFile(file, {string.byte(picture[6][i], 1, 6)})\13\n\9end\13\nend\13\n\13\nencodingMethods.load[5] = function(file, picture)\13\n\9picture[1] = readNumberFromFile(file, 2)\13\n\9picture[2] = readNumberFromFile(file, 2)\13\n\13\n\9for i = 1, image.getWidth(picture) * image.getHeight(picture) do\13\n\9\9table.insert(picture[3], color.to24Bit(string.byte(file:read(1))))\13\n\9\9table.insert(picture[4], color.to24Bit(string.byte(file:read(1))))\13\n\9\9table.insert(picture[5], string.byte(file:read(1)) / 255)\13\n\9\9table.insert(picture[6], fs.readUnicodeChar(file))\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nencodingMethods.save[6] = function(file, picture)\13\n\9-- Grouping picture by it's alphas, symbols and colors\13\n\9local groupedPicture = image.group(picture, true)\13\n\9-- Writing 1 byte for alphas array size\13\n\9file:write(string.char(table.size(groupedPicture)))\13\n\13\n\9for alpha in pairs(groupedPicture) do\13\n\9\9-- Writing 1 byte for current alpha value\13\n\9\9file:write(string.char(math.floor(alpha * 255)))\13\n\9\9-- Writing 2 bytes for symbols array size\13\n\9\9writeByteArrayToFile(file, bit32.numberToFixedSizeByteArray(table.size(groupedPicture[alpha]), 2))\13\n\13\n\9\9for symbol in pairs(groupedPicture[alpha]) do\13\n\9\9\9-- Writing N bytes for current unicode symbol value\13\n\9\9\9writeByteArrayToFile(file, { string.byte(symbol, 1, 6) })\13\n\9\9\9-- Writing 1 byte for backgrounds array size\13\n\9\9\9file:write(string.char(table.size(groupedPicture[alpha][symbol])))\13\n\13\n\9\9\9for background in pairs(groupedPicture[alpha][symbol]) do\13\n\9\9\9\9-- Writing 1 byte for background color value (compressed by color)\13\n\9\9\9\9file:write(string.char(background))\13\n\9\9\9\9-- Writing 1 byte for foregrounds array size\13\n\9\9\9\9file:write(string.char(table.size(groupedPicture[alpha][symbol][background])))\13\n\13\n\9\9\9\9for foreground in pairs(groupedPicture[alpha][symbol][background]) do\13\n\9\9\9\9\9-- Writing 1 byte for foreground color value (compressed by color)\13\n\9\9\9\9\9file:write(string.char(foreground))\13\n\9\9\9\9\9-- Writing 1 byte for y array size\13\n\9\9\9\9\9file:write(string.char(table.size(groupedPicture[alpha][symbol][background][foreground])))\13\n\9\9\9\9\9\13\n\9\9\9\9\9for y in pairs(groupedPicture[alpha][symbol][background][foreground]) do\13\n\9\9\9\9\9\9-- Writing 1 byte for current y value\13\n\9\9\9\9\9\9file:write(string.char(y))\13\n\9\9\9\9\9\9-- Writing 1 byte for x array size\13\n\9\9\9\9\9\9file:write(string.char(#groupedPicture[alpha][symbol][background][foreground][y]))\13\n\13\n\9\9\9\9\9\9for x = 1, #groupedPicture[alpha][symbol][background][foreground][y] do\13\n\9\9\9\9\9\9\9file:write(string.char(groupedPicture[alpha][symbol][background][foreground][y][x]))\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nencodingMethods.load[6] = function(file, picture)\13\n\9picture[1] = string.byte(file:read(1))\13\n\9picture[2] = string.byte(file:read(1))\13\n\13\n\9local currentAlpha, currentSymbol, currentBackground, currentForeground, currentY, currentX\13\n\9local alphaSize, symbolSize, backgroundSize, foregroundSize, ySize, xSize\13\n\13\n\9alphaSize = string.byte(file:read(1))\13\n\9\13\n\9for alpha = 1, alphaSize do\13\n\9\9currentAlpha = string.byte(file:read(1)) / 255\13\n\9\9symbolSize = readNumberFromFile(file, 2)\13\n\9\9\13\n\9\9for symbol = 1, symbolSize do\13\n\9\9\9currentSymbol = fs.readUnicodeChar(file)\13\n\9\9\9backgroundSize = string.byte(file:read(1))\13\n\9\9\9\13\n\9\9\9for background = 1, backgroundSize do\13\n\9\9\9\9currentBackground = color.to24Bit(string.byte(file:read(1)))\13\n\9\9\9\9foregroundSize = string.byte(file:read(1))\13\n\9\9\9\9\13\n\9\9\9\9for foreground = 1, foregroundSize do\13\n\9\9\9\9\9currentForeground = color.to24Bit(string.byte(file:read(1)))\13\n\9\9\9\9\9ySize = string.byte(file:read(1))\13\n\9\9\9\9\9\13\n\9\9\9\9\9for y = 1, ySize do\13\n\9\9\9\9\9\9currentY = string.byte(file:read(1))\13\n\9\9\9\9\9\9xSize = string.byte(file:read(1))\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9for x = 1, xSize do\13\n\9\9\9\9\9\9\9currentX = string.byte(file:read(1))\13\n\9\9\9\9\9\9\9image.set(picture, currentX, currentY, currentBackground, currentForeground, currentAlpha, currentSymbol)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nfunction module.load(path)\13\n\9local file, reason = io.open(path, \"rb\")\13\n\9if file then\13\n\9\9local readedSignature = file:read(#OCIFSignature)\13\n\9\9if readedSignature == OCIFSignature then\13\n\9\9\9local encodingMethod = string.byte(file:read(1))\13\n\9\9\9if encodingMethods.load[encodingMethod] then\13\n\9\9\9\9local picture = {1, 1, {}, {}, {}, {}}\13\n\9\9\9\9encodingMethods.load[encodingMethod](file, picture)\13\n\13\n\9\9\9\9file:close()\13\n\9\9\9\9return picture\13\n\9\9\9else\13\n\9\9\9\9file:close()\13\n\9\9\9\9return false, \"Failed to load OCIF image: encoding method \\\"\" .. tostring(encodingMethod) .. \"\\\" is not supported\"\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9file:close()\13\n\9\9\9return false, \"Failed to load OCIF image: binary signature \\\"\" .. tostring(readedSignature) .. \"\\\" is not valid\"\13\n\9\9end\13\n\9else\13\n\9\9return false, \"Failed to open file \\\"\" .. tostring(path) .. \"\\\" for reading: \" .. tostring(reason)\13\n\9end\13\nend\13\n\13\nfunction module.save(path, picture, encodingMethod)\13\n\9encodingMethod = encodingMethod or 6\13\n\9\13\n\9local file, reason = io.open(path, \"wb\")\13\n\9if file then\9\13\n\9\9if encodingMethods.save[encodingMethod] then\13\n\9\9\9file:write(OCIFSignature, string.char(encodingMethod), string.char(picture[1]), string.char(picture[2]))\13\n\9\9\9encodingMethods.save[encodingMethod](file, picture)\13\n\9\9\9\13\n\9\9\9file:close()\13\n\9\9\9return true\13\n\9\9else\13\n\9\9\9file:close()\13\n\9\9\9return false, \"Failed to save file as OCIF image: encoding method \\\"\" .. tostring(encodingMethod) .. \"\\\" is not supported\"\13\n\9\9end\13\n\9else\13\n\9\9return false, \"Failed to open file for writing: \" .. tostring(reason)\13\n\9end\13\nend\13\n--------------------------------------------------------------------------------\13\n\13\nreturn module",["./libs/thirdParty/DoubleBuffering_v0.7.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are made some changes to provide the best possible performance in combination with the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (NosPo version) Copyright (c) 2019-2020 NosPo Studio\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\nlocal version = \"v0.7\" --NosPo version.\13\n\13\nlocal component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\nlocal color = require(\"libs/thirdParty/color\")\13\nlocal image = require(\"libs/thirdParty/image\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal bufferWidth, bufferHeight\13\nlocal currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nlocal drawLimitX1, drawLimitX2, drawLimitY1, drawLimitY2\13\nlocal GPUProxy, GPUProxyGetResolution, GPUProxySetResolution, GPUProxyBind, GPUProxyGetBackground, GPUProxyGetForeground, GPUProxySetBackground, GPUProxySetForeground, GPUProxyGet, GPUProxySet, GPUProxyFill\13\n\13\nlocal mathCeil, mathFloor, mathModf, mathAbs = math.ceil, math.floor, math.modf, math.abs\13\nlocal tableInsert, tableConcat = table.insert, table.concat\13\nlocal colorBlend = color.blend\13\nlocal unicodeLen, unicodeSub = unicode.len, unicode.sub\13\n\13\nlocal drawAreas, nonDrawAreas = {}, {} --drawAreas == pixelWhiteList, nonDrawAreas == pixelBlackList\13\nlocal drawAreasAreWhitelist = true\13\nlocal drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nlocal bufferOnly = false\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getIndex(x, y)\13\n\9return bufferWidth * (y - 1) + x\13\nend\13\nlocal function getCoordinates(index)\13\n\9return index % bufferWidth, math.floor(index / bufferWidth) +1\13\nend\13\n\13\nlocal function getCurrentFrameTables()\13\n\9return currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function getNewFrameTables()\13\n\9return newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function setCurrentFrameTables(b, f, s, w, h)\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\nlocal function setNewFrameTables(b, f, s, w, h)\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\n\13\nlocal function setBufferOnly(b)\13\n\9bufferOnly = b\13\nend\13\nlocal function getBufferOnly()\13\n\9return bufferOnly\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function setDrawLimit(x1, y1, x2, y2)\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = x1, y1, x2, y2\13\nend\13\n\13\nlocal function resetDrawLimit()\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = 1, 1, bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getDrawLimit()\13\n\9return drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2\13\nend\13\n\13\nlocal function setDrawAreas(areas)\13\n\9drawAreas = areas\13\nend\13\nlocal function resetDrawAreas()\13\n\9drawAreas = {}\13\nend\13\nlocal function getDrawAreas()\13\n\9return drawAreas\13\nend\13\nlocal function setNonDrawAreas(areas)\13\n\9nonDrawAreas = areas\13\nend\13\nlocal function resetNonDrawAreas()\13\n\9nonDrawAreas = {}\13\nend\13\nlocal function getNonDrawAreas()\13\n\9return nonDrawAreas\13\nend\13\n\13\nlocal function setDrawAreaOffset(x, y)\13\n\9drawAreaOffsetX = x or drawAreaOffsetX\13\n\9drawAreaOffsetY = y or drawAreaOffsetY\13\n\9\13\nend\13\nlocal function getDrawAreaOffset()\13\n\9return drawAreaOffsetX, drawAreaOffsetY\13\nend\13\nlocal function resetDrawAreaOffset()\13\n\9drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nend\13\n\13\nlocal function isDrawable(x, y)\13\n\9local drawable = true\13\n\9\13\n\9if #drawAreas == 0 and #nonDrawAreas == 0 then\13\n\9\9--return true\13\n\9end\13\n\9\13\n\9for _, a in pairs(drawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = true\13\n\9\9\9break\13\n\9\9end\13\n\9\9drawable = false\13\n\9end\13\n\9for _, a in pairs(nonDrawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = false\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9return drawable\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function flush(width, height)\13\n\9if not width or not height then\13\n\9\9width, height = GPUProxyGetResolution()\13\n\9end\13\n\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = {}, {}, {}, {}, {}, {}\13\n\9bufferWidth = width\13\n\9bufferHeight = height\13\n\9resetDrawLimit()\13\n\13\n\9for y = 1, bufferHeight do\13\n\9\9for x = 1, bufferWidth do\13\n\9\9\9tableInsert(currentFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(currentFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(currentFrameSymbols, \" \")\13\n\13\n\9\9\9tableInsert(newFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(newFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(newFrameSymbols, \" \")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function setResolution(width, height)\13\n\9GPUProxySetResolution(width, height)\13\n\9flush(width, height)\13\nend\13\n\13\nlocal function getResolution()\13\n\9return bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getWidth()\13\n\9return bufferWidth\13\nend\13\n\13\nlocal function getHeight()\13\n\9return bufferHeight\13\nend\13\n\13\nlocal function bindScreen(...)\13\n\9GPUProxyBind(...)\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\nlocal function getGPUProxy()\13\n\9return GPUProxy\13\nend\13\n\13\nlocal function updateGPUProxyMethods()\13\n\9GPUProxyGet = GPUProxy.get\13\n\9GPUProxyGetResolution = GPUProxy.getResolution\13\n\9GPUProxyGetBackground = GPUProxy.getBackground\13\n\9GPUProxyGetForeground = GPUProxy.getForeground\13\n\13\n\9GPUProxySet = GPUProxy.set\13\n\9GPUProxySetResolution = GPUProxy.setResolution\13\n\9GPUProxySetBackground = GPUProxy.setBackground\13\n\9GPUProxySetForeground = GPUProxy.setForeground\13\n\13\n\9GPUProxyBind = GPUProxy.bind\13\n\9GPUProxyFill = GPUProxy.fill\13\nend\13\n\13\nlocal function bindGPU(address)\13\n\9GPUProxy = component.proxy(address)\13\n\9updateGPUProxyMethods()\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function rawSet(index, background, foreground, symbol)\13\n\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9if bufferOnly then\13\n\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9end\13\nend\13\n\13\nlocal function rawGet(index)\13\n\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\nend\13\n\13\nlocal function get(x, y)\13\n\9if x >= 1 and y >= 1 and x <= bufferWidth and y <= bufferHeight then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9else\13\n\9\9return 0x000000, 0x000000, \" \"\13\n\9end\13\nend\13\n\13\nlocal function set(x, y, background, foreground, symbol)\13\n\9if x >= drawLimitX1 and y >= drawLimitY1 and x <= drawLimitX2 and y <= drawLimitY2 and isDrawable(x, y) then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9if bufferOnly then\13\n\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawRectangle(x, y, width, height, background, foreground, symbol, transparency) \13\n\9local index, indexStepOnReachOfSquareWidth = bufferWidth * (y - 1) + x, bufferWidth - width\13\n\9for j = y, y + height - 1 do\13\n\9\9if j >= drawLimitY1 and j <= drawLimitY2 then\13\n\9\9\9for i = x, x + width - 1 do\13\n\9\9\9\9if i >= drawLimitX1 and i <= drawLimitX2 and isDrawable(i, j) then\13\n\9\9\9\9\9if transparency then\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9colorBlend(newFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9colorBlend(newFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9index = index + 1\13\n\9\9\9end\13\n\13\n\9\9\9index = index + indexStepOnReachOfSquareWidth\13\n\9\9else\13\n\9\9\9index = index + bufferWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clear(color, transparency)\13\n\9drawRectangle(1, 1, bufferWidth, bufferHeight, color or 0x0, 0x000000, \" \", transparency)\13\nend\13\n\13\nlocal function copy(x, y, width, height, current)\13\n\9local copyArray, index = { width, height }\13\n\9local rawCopyArray = { width, height }\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, newFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameSymbols[index])\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameForegrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameSymbols[index])\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, \" \")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return copyArray, rawCopyArray\13\nend\13\n\13\nlocal function paste(startX, startY, picture, currentPicture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\9\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9newFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9\9if currentPicture ~= nil then\13\n\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = currentPicture[pictureIndex]\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = currentPicture[pictureIndex + 1]\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = currentPicture[pictureIndex + 2]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function copyCurrent(x, y, width, height)\13\n\9local copyArray, index = { width, height }\13\n\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameSymbols[index])\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return copyArray\13\nend\13\n\13\nlocal function pasteCurrent(startX, startY, picture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9currentFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function directCopy(x, y, width, height, tx, ty, current, actualBuffer)\13\n\9local index\13\n\9local imageWidth = width\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (ty - 1) + tx, 3, bufferWidth - imageWidth\13\n\9\13\n\9local newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols\13\n\9\13\n\9if actualBuffer then\13\n\9\9newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9else\13\n\9\9newBackgrounds, newForegrounds, newSymbols = {table.unpack(newFrameBackgrounds)}, {table.unpack(newFrameForegrounds)}, {table.unpack(newFrameSymbols)}\13\n\9\13\n\9\13\n\9\9if current or bufferOnly then\13\n\9\9\9currentBackgrounds, currentForegrounds, currentSymbols = {table.unpack(currentFrameBackgrounds)}, {table.unpack(currentFrameForegrounds)}, {table.unpack(currentFrameSymbols)}\13\n\9\9end\13\n\9end\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9local newX, newY = getCoordinates(bufferIndex)\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(ewX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9newForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9newSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = currentFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = currentFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = currentFrameSymbols[index]\13\n\9\9\9\9\9\9--[[\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\9]]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(newX, newY) then\13\n\9\9\9\9\9newBackgrounds[newIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[newIndex] = 0x0\13\n\9\9\9\9\9newSymbols[newIndex] = \" \"\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9end\13\n\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9end\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = newBackgrounds, newForegrounds, newSymbols\13\n\9if current or bufferOnly then\13\n\9\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols = currentBackgrounds, currentForegrounds, currentSymbols\13\n\9end\13\nend\13\n\13\nlocal function rasterizeLine(x1, y1, x2, y2, method)\13\n\9local inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = x1, x2, y1, y2, false, mathAbs(x2 - x1), mathAbs(y2 - y1)\13\n\9if inLoopValueDelta < outLoopValueDelta then\13\n\9\9inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = y1, y2, x1, x2, true, outLoopValueDelta, inLoopValueDelta\13\n\9end\13\n\13\n\9if outLoopValueFrom > outLoopValueTo then\13\n\9\9outLoopValueFrom, outLoopValueTo = outLoopValueTo, outLoopValueFrom\13\n\9\9inLoopValueFrom, inLoopValueTo = inLoopValueTo, inLoopValueFrom\13\n\9end\13\n\13\n\9local outLoopValue, outLoopValueCounter, outLoopValueTriggerIncrement = outLoopValueFrom, 1, inLoopValueDelta / outLoopValueDelta\13\n\9local outLoopValueTrigger = outLoopValueTriggerIncrement\13\n\9for inLoopValue = inLoopValueFrom, inLoopValueTo, inLoopValueFrom < inLoopValueTo and 1 or -1 do\13\n\9\9if isReversed then\13\n\9\9\9method(outLoopValue, inLoopValue)\13\n\9\9else\13\n\9\9\9method(inLoopValue, outLoopValue)\13\n\9\9end\13\n\13\n\9\9outLoopValueCounter = outLoopValueCounter + 1\13\n\9\9if outLoopValueCounter > outLoopValueTrigger then\13\n\9\9\9outLoopValue, outLoopValueTrigger = outLoopValue + 1, outLoopValueTrigger + outLoopValueTriggerIncrement\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function rasterizeEllipse(centerX, centerY, radiusX, radiusY, method)\13\n\9local function rasterizeEllipsePoints(XP, YP)\13\n\9\9method(centerX + XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY - YP)\13\n\9\9method(centerX + XP, centerY - YP) \13\n\9end\13\n\13\n\9local x, y, changeX, changeY, ellipseError, twoASquare, twoBSquare = radiusX, 0, radiusY * radiusY * (1 - 2 * radiusX), radiusX * radiusX, 0, 2 * radiusX * radiusX, 2 * radiusY * radiusY\13\n\9local stoppingX, stoppingY = twoBSquare * radiusX, 0\13\n\13\n\9while stoppingX >= stoppingY do\13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9y, stoppingY, ellipseError = y + 1, stoppingY + twoASquare, ellipseError + changeY\13\n\9\9changeY = changeY + twoASquare\13\n\13\n\9\9if (2 * ellipseError + changeX) > 0 then\13\n\9\9\9x, stoppingX, ellipseError = x - 1, stoppingX - twoBSquare, ellipseError + changeX\13\n\9\9\9changeX = changeX + twoBSquare\13\n\9\9end\13\n\9end\13\n\13\n\9x, y, changeX, changeY, ellipseError, stoppingX, stoppingY = 0, radiusY, radiusY * radiusY, radiusX * radiusX * (1 - 2 * radiusY), 0, 0, twoASquare * radiusY\13\n\13\n\9while stoppingX <= stoppingY do \13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9x, stoppingX, ellipseError = x + 1, stoppingX + twoBSquare, ellipseError + changeX\13\n\9\9changeX = changeX + twoBSquare\13\n\9\9\13\n\9\9if (2 * ellipseError + changeY) > 0 then\13\n\9\9\9y, stoppingY, ellipseError = y - 1, stoppingY - twoASquare, ellipseError + changeY\13\n\9\9\9changeY = changeY + twoASquare\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawLine(x1, y1, x2, y2, background, foreground, symbol)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawEllipse(centerX, centerY, radiusX, radiusY, background, foreground, symbol)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawText(x, y, textColor, data, transparency)\13\n\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9local charIndex, bufferIndex = 1, bufferWidth * (y - 1) + x\13\n\9\9\13\n\9\9for charIndex = 1, unicodeLen(data) do\13\n\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9if transparency then\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9end\13\n\9\9\9\9else\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9newFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\13\n\9\9\9x, bufferIndex = x + 1, bufferIndex + 1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawImage(startX, startY, picture, blendForeground)\13\n\9local bufferIndex, pictureIndex, imageWidth, backgrounds, foregrounds, alphas, symbols = bufferWidth * (startY - 1) + startX, 1, picture[1], picture[3], picture[4], picture[5], picture[6]\13\n\9local bufferIndexStepOnReachOfImageWidth = bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9if alphas[pictureIndex] == 0 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex], newFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex], currentFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] > 0 and alphas[pictureIndex] < 1 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if blendForeground then\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] == 1 and symbols[pictureIndex] ~= \" \" then\13\n\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 1\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(x, y, width, height, color)\13\n\9local stringUp, stringDown, x2 = \"\" .. string.rep(\"\", width - 2) .. \"\", \"\" .. string.rep(\"\", width - 2) .. \"\", x + width - 1\13\n\9\13\n\9drawText(x, y, color, stringUp); y = y + 1\13\n\9for i = 1, height - 2 do\13\n\9\9drawText(x, y, color, \"\")\13\n\9\9drawText(x2, y, color, \"\")\13\n\9\9y = y + 1\13\n\9end\13\n\9drawText(x, y, color, stringDown)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function semiPixelRawSet(index, color, yPercentTwoEqualsZero, internalRun) --ToDo\13\n\9local upperPixel, lowerPixel, bothPixel = \"\", \"\", \" \"\13\n\9local backgroundBuffer, foregroundBuffer, symbolBuffer = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\n\9\13\n\9if internalRun then\13\n\9\9backgroundBuffer, foregroundBuffer, symbolBuffer = currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9end\13\n\9\13\n\9local background, foreground, symbol = backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index]\13\n\13\n\9if yPercentTwoEqualsZero then\13\n\9\9if symbol == upperPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9end\13\n\9else\13\n\9\9if symbol == lowerPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9end\13\n\9end\13\n\9\13\n\9if bufferOnly and not internalRun then\13\n\9\9semiPixelRawSet(index, color, yPercentTwoEqualsZero, true)\13\n\9end\13\nend\13\n\13\nlocal function semiPixelSet(x, y, color)\13\n\9local yFixed = mathCeil(y / 2)\13\n\9if x >= drawLimitX1 and yFixed >= drawLimitY1 and x <= drawLimitX2 and yFixed <= drawLimitY2 and isDrawable(x, yFixed) then\13\n\9\9semiPixelRawSet(bufferWidth * (yFixed - 1) + x, color, y % 2 == 0)\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelRectangle(x, y, width, height, color)\13\n\9local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = bufferWidth * (mathCeil(y / 2) - 1) + x, (bufferWidth - width), width\13\n\9for j = y, y + height - 1 do\13\n\9\9jPercentTwoEqualsZero = j % 2 == 0\13\n\9\9\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9jFixed = mathCeil(j / 2)\13\n\9\9\9semiPixelRawSet(index, color, jPercentTwoEqualsZero)\13\n\9\9\9index = index + 1\13\n\9\9end\13\n\13\n\9\9if jPercentTwoEqualsZero then\13\n\9\9\9index = index + indexStepForward\13\n\9\9else\13\n\9\9\9index = index - indexStepBackward\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelLine(x1, y1, x2, y2, color)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\nlocal function drawSemiPixelEllipse(centerX, centerY, radiusX, radiusY, color)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getPointTimedPosition(firstPoint, secondPoint, time)\13\n\9return {\13\n\9\9x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,\13\n\9\9y = firstPoint.y + (secondPoint.y - firstPoint.y) * time\13\n\9}\13\nend\13\n\13\nlocal function getConnectionPoints(points, time)\13\n\9local connectionPoints = {}\13\n\9for point = 1, #points - 1 do\13\n\9\9tableInsert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))\13\n\9end\13\n\9return connectionPoints\13\nend\13\n\13\nlocal function getMainPointPosition(points, time)\13\n\9if #points > 1 then\13\n\9\9return getMainPointPosition(getConnectionPoints(points, time), time)\13\n\9else\13\n\9\9return points[1]\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelCurve(points, color, precision)\13\n\9local linePoints = {}\13\n\9for time = 0, 1, precision or 0.01 do\13\n\9\9tableInsert(linePoints, getMainPointPosition(points, time))\13\n\9end\13\n\9\13\n\9for point = 1, #linePoints - 1 do\13\n\9\9drawSemiPixelLine(mathFloor(linePoints[point].x), mathFloor(linePoints[point].y), mathFloor(linePoints[point + 1].x), mathFloor(linePoints[point + 1].y), color)\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function drawChanges(force)\13\n\9local index, indexStepOnEveryLine, changes = bufferWidth * (drawLimitY1 - 1) + drawLimitX1, (bufferWidth - drawLimitX2 + drawLimitX1 - 1), {}\13\n\9local x, equalChars, equalCharsIndex, charX, charIndex, currentForeground\13\n\9local currentFrameBackground, currentFrameForeground, currentFrameSymbol, changesCurrentFrameBackground, changesCurrentFrameBackgroundCurrentFrameForeground\13\n\13\n\9local changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\13\n\9for y = drawLimitY1, drawLimitY2 do\13\n\9\9x = drawLimitX1\13\n\9\9while x <= drawLimitX2 do\9\9\9\13\n\9\9\9-- Determine if some pixel data was changed (or if <force> argument was passed)\13\n\9\9\9if\13\n\9\9\9\9currentFrameBackgrounds[index] ~= newFrameBackgrounds[index] or\13\n\9\9\9\9currentFrameForegrounds[index] ~= newFrameForegrounds[index] or\13\n\9\9\9\9currentFrameSymbols[index] ~= newFrameSymbols[index] or\13\n\9\9\9\9force\13\n\9\9\9then\13\n\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9currentFrameBackground, currentFrameForeground, currentFrameSymbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9\9\9\9currentFrameBackgrounds[index] = currentFrameBackground\13\n\9\9\9\9currentFrameForegrounds[index] = currentFrameForeground\13\n\9\9\9\9currentFrameSymbols[index] = currentFrameSymbol\13\n\13\n\9\9\9\9-- Look for pixels with equal chars from right of current pixel\13\n\9\9\9\9equalChars, equalCharsIndex, charX, charIndex = {currentFrameSymbol}, 2, x + 1, index + 1\13\n\9\9\9\9while charX <= drawLimitX2 do\13\n\9\9\9\9\9-- Pixels becomes equal only if they have same background and (whitespace char or same foreground)\13\n\9\9\9\9\9if\9\13\n\9\9\9\9\9\9currentFrameBackground == newFrameBackgrounds[charIndex] and\13\n\9\9\9\9\9\9(\13\n\9\9\9\9\9\9\9newFrameSymbols[charIndex] == \" \" or\13\n\9\9\9\9\9\9\9currentFrameForeground == newFrameForegrounds[charIndex]\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9\9 \9currentFrameBackgrounds[charIndex] = newFrameBackgrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameForegrounds[charIndex] = newFrameForegrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameSymbols[charIndex] = newFrameSymbols[charIndex]\13\n\13\n\9\9\9\9\9 \9equalChars[equalCharsIndex], equalCharsIndex = currentFrameSymbols[charIndex], equalCharsIndex + 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9charX, charIndex = charX + 1, charIndex + 1\13\n\9\9\9\9end\13\n\13\n\9\9\9\9-- Group pixels that need to be drawn by background and foreground\13\n\9\9\9\9changes[currentFrameBackground] = changes[currentFrameBackground] or {}\13\n\9\9\9\9changesCurrentFrameBackground = changes[currentFrameBackground]\13\n\9\9\9\9changesCurrentFrameBackground[currentFrameForeground] = changesCurrentFrameBackground[currentFrameForeground] or {index = 1}\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground = changesCurrentFrameBackground[currentFrameForeground]\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForegroundIndex = changesCurrentFrameBackgroundCurrentFrameForeground.index\13\n\9\9\9\9\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = x, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = y, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = tableConcat(equalChars), changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9\13\n\9\9\9\9x, index, changesCurrentFrameBackgroundCurrentFrameForeground.index = x + equalCharsIndex - 2, index + equalCharsIndex - 2, changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\9\9\9end\13\n\13\n\9\9\9x, index = x + 1, index + 1\13\n\9\9end\13\n\13\n\9\9index = index + indexStepOnEveryLine\13\n\9end\13\n\9\13\n\9-- Draw grouped pixels on screen\13\n\9for background, foregrounds in pairs(changes) do\13\n\9\9GPUProxySetBackground(background)\13\n\13\n\9\9for foreground, pixels in pairs(foregrounds) do\13\n\9\9\9if currentForeground ~= foreground then\13\n\9\9\9\9GPUProxySetForeground(foreground)\13\n\9\9\9\9currentForeground = foreground\13\n\9\9\9end\13\n\13\n\9\9\9for i = 1, #pixels, 3 do\13\n\9\9\9\9GPUProxySet(pixels[i], pixels[i + 1], pixels[i + 2])\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9changes = nil\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nbindGPU(component.getPrimary(\"gpu\").address)\13\n\13\nreturn {\13\n\9getCoordinates = getCoordinates,\13\n\9getIndex = getIndex,\13\n\9setDrawLimit = setDrawLimit,\13\n\9resetDrawLimit = resetDrawLimit,\13\n\9getDrawLimit = getDrawLimit,\13\n\9flush = flush,\13\n\9setResolution = setResolution,\13\n\9bindScreen = bindScreen,\13\n\9bindGPU = bindGPU,\13\n\9getGPUProxy = getGPUProxy,\13\n\9getResolution = getResolution,\13\n\9getWidth = getWidth,\13\n\9getHeight = getHeight,\13\n\9getCurrentFrameTables = getCurrentFrameTables,\13\n\9getNewFrameTables = getNewFrameTables,\13\n\9setCurrentFrameTables = setCurrentFrameTables,\13\n\9setNewFrameTables = setNewFrameTables,\13\n\9setBufferOnly = setBufferOnly,\13\n\9getBufferOnly = getBufferOnly,\13\n\13\n\9rawSet = rawSet,\13\n\9rawGet = rawGet,\13\n\9get = get,\13\n\9set = set,\13\n\9clear = clear,\13\n\9copy = copy,\13\n\9paste = paste,\13\n\9directCopy = directCopy,\13\n\9copyCurrent = copyCurrent,\13\n\9pasteCurrent = pasteCurrent,\13\n\9rasterizeLine = rasterizeLine,\13\n\9rasterizeEllipse = rasterizeEllipse,\13\n\9semiPixelRawSet = semiPixelRawSet,\13\n\9semiPixelSet = semiPixelSet,\13\n\9drawChanges = drawChanges,\13\n\13\n\9drawRectangle = drawRectangle,\13\n\9drawLine = drawLine,\13\n\9drawEllipse = drawEllipse,\13\n\9drawText = drawText,\13\n\9drawImage = drawImage,\13\n\9drawFrame = drawFrame,\13\n\13\n\9drawSemiPixelRectangle = drawSemiPixelRectangle,\13\n\9drawSemiPixelLine = drawSemiPixelLine,\13\n\9drawSemiPixelEllipse = drawSemiPixelEllipse,\13\n\9drawSemiPixelCurve = drawSemiPixelCurve,\13\n\9\13\n\9setDrawAreas = setDrawAreas,\13\n\9resetDrawAreas = resetDrawAreas,\13\n\9getDrawAreas = getDrawAreas,\13\n\9setNonDrawAreas = setNonDrawAreas,\13\n\9resetNonDrawAreas = resetNonDrawAreas,\13\n\9getNonDrawAreas = getNonDrawAreas,\13\n\9\13\n\9setDrawAreaOffset = setDrawAreaOffset,\13\n\9getDrawAreaOffset = getDrawAreaOffset,\13\n\9resetDrawAreaOffset = resetDrawAreaOffset,\13\n}",["./libs/thirdParty/LIP.lua"] = "--[[\13\n\9Copyright (c) 2012 Carreras Nicolas\13\n\9\13\n\9Permission is hereby granted, free of charge, to any person obtaining a copy\13\n\9of this software and associated documentation files (the \"Software\"), to deal\13\n\9in the Software without restriction, including without limitation the rights\13\n\9to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\n\9copies of the Software, and to permit persons to whom the Software is\13\n\9furnished to do so, subject to the following conditions:\13\n\9\13\n\9The above copyright notice and this permission notice shall be included in all\13\n\9copies or substantial portions of the Software.\13\n\9\13\n\9THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\n\9IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\n\9FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\n\9AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\n\9LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\n\9OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\n\9SOFTWARE.\13\n--]]\13\n--- Lua INI Parser.\13\n-- It has never been that simple to use INI files with Lua.\13\n--@author Dynodzzo\13\n\13\nlocal LIP = {};\13\n\13\n--- Returns a table containing all the data from the INI file.\13\n--@param fileName The name of the INI file to parse. [string]\13\n--@return The table containing all data from the INI file. [table]\13\nfunction LIP.load(fileName)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9local file = assert(io.open(fileName, 'r'), 'Error loading file : ' .. fileName);\13\n\9local data = {};\13\n\9local section;\13\n\9for line in file:lines() do\13\n\9\9local tempSection = line:match('^%[([^%[%]]+)%]$');\13\n\9\9if(tempSection)then\13\n\9\9\9section = tonumber(tempSection) and tonumber(tempSection) or tempSection;\13\n\9\9\9data[section] = data[section] or {};\13\n\9\9end\13\n\9\9local param, value = line:match('^([%w|_]+)%s-=%s-(.+)$');\13\n\9\9if(param and value ~= nil)then\13\n\9\9\9if(tonumber(value))then\13\n\9\9\9\9value = tonumber(value);\13\n\9\9\9elseif(value == 'true')then\13\n\9\9\9\9value = true;\13\n\9\9\9elseif(value == 'false')then\13\n\9\9\9\9value = false;\13\n\9\9\9end\13\n\9\9\9if(tonumber(param))then\13\n\9\9\9\9param = tonumber(param);\13\n\9\9\9end\13\n\9\9\9data[section][param] = value;\13\n\9\9end\13\n\9end\13\n\9file:close();\13\n\9return data;\13\nend\13\n\13\n--- Saves all the data from a table to an INI file.\13\n--@param fileName The name of the INI file to fill. [string]\13\n--@param data The table containing all the data to store. [table]\13\nfunction LIP.save(fileName, data)\13\n\9assert(type(fileName) == 'string', 'Parameter \"fileName\" must be a string.');\13\n\9assert(type(data) == 'table', 'Parameter \"data\" must be a table.');\13\n\9local file = assert(io.open(fileName, 'w+b'), 'Error loading file :' .. fileName);\13\n\9local contents = '';\13\n\9for section, param in pairs(data) do\13\n\9\9contents = contents .. ('[%s]\\n'):format(section);\13\n\9\9for key, value in pairs(param) do\13\n\9\9\9contents = contents .. ('%s=%s\\n'):format(key, tostring(value));\13\n\9\9end\13\n\9\9contents = contents .. '\\n';\13\n\9end\13\n\9file:write(contents);\13\n\9file:close();\13\nend\13\n\13\nreturn LIP;",["./libs/thirdParty/DoubleBuffering.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are made some changes to provide the best possible performance in combination with the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (NosPo version) Copyright (c) 2019-2020 NosPo Studio\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\nlocal version = \"v0.8\" --NosPo version.\13\n\13\nlocal component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\nlocal color = require(\"libs/thirdParty/color\")\13\nlocal image = require(\"libs/thirdParty/image\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal bufferWidth, bufferHeight\13\nlocal currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nlocal drawLimitX1, drawLimitX2, drawLimitY1, drawLimitY2\13\nlocal GPUProxy, GPUProxyGetResolution, GPUProxySetResolution, GPUProxyBind, GPUProxyGetBackground, GPUProxyGetForeground, GPUProxySetBackground, GPUProxySetForeground, GPUProxyGet, GPUProxySet, GPUProxyFill\13\n\13\nlocal mathCeil, mathFloor, mathModf, mathAbs = math.ceil, math.floor, math.modf, math.abs\13\nlocal tableInsert, tableConcat = table.insert, table.concat\13\nlocal colorBlend = color.blend\13\nlocal unicodeLen, unicodeSub = unicode.len, unicode.sub\13\n\13\nlocal drawAreas, nonDrawAreas = {}, {} --drawAreas == pixelWhiteList, nonDrawAreas == pixelBlackList\13\nlocal drawAreasAreWhitelist = true\13\nlocal drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nlocal bufferOnly = false\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getIndex(x, y)\13\n\9return bufferWidth * (y - 1) + x\13\nend\13\nlocal function getCoordinates(index)\13\n\9return index % bufferWidth, math.floor(index / bufferWidth) +1\13\nend\13\n\13\nlocal function getCurrentFrameTables()\13\n\9return currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function getNewFrameTables()\13\n\9return newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight\13\nend\13\nlocal function setCurrentFrameTables(b, f, s, w, h)\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\nlocal function setNewFrameTables(b, f, s, w, h)\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, bufferWidth, bufferHeight = b, f, s, w, h\13\nend\13\n\13\nlocal function setBufferOnly(b)\13\n\9bufferOnly = b\13\nend\13\nlocal function getBufferOnly()\13\n\9return bufferOnly\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function setDrawLimit(x1, y1, x2, y2)\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = x1, y1, x2, y2\13\nend\13\n\13\nlocal function resetDrawLimit()\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = 1, 1, bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getDrawLimit()\13\n\9return drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2\13\nend\13\n\13\nlocal function setDrawAreas(areas)\13\n\9drawAreas = areas\13\nend\13\nlocal function resetDrawAreas()\13\n\9drawAreas = {}\13\nend\13\nlocal function getDrawAreas()\13\n\9return drawAreas\13\nend\13\nlocal function setNonDrawAreas(areas)\13\n\9nonDrawAreas = areas\13\nend\13\nlocal function resetNonDrawAreas()\13\n\9nonDrawAreas = {}\13\nend\13\nlocal function getNonDrawAreas()\13\n\9return nonDrawAreas\13\nend\13\n\13\nlocal function setDrawAreaOffset(x, y)\13\n\9drawAreaOffsetX = x or drawAreaOffsetX\13\n\9drawAreaOffsetY = y or drawAreaOffsetY\13\n\9\13\nend\13\nlocal function getDrawAreaOffset()\13\n\9return drawAreaOffsetX, drawAreaOffsetY\13\nend\13\nlocal function resetDrawAreaOffset()\13\n\9drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nend\13\n\13\nlocal function isDrawable(x, y)\13\n\9local drawable = true\13\n\9\13\n\9if #drawAreas == 0 and #nonDrawAreas == 0 then\13\n\9\9--return true\13\n\9end\13\n\9\13\n\9for _, a in pairs(drawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = true\13\n\9\9\9break\13\n\9\9end\13\n\9\9drawable = false\13\n\9end\13\n\9for _, a in pairs(nonDrawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = false\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9return drawable\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function flush(width, height)\13\n\9if not width or not height then\13\n\9\9width, height = GPUProxyGetResolution()\13\n\9end\13\n\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = {}, {}, {}, {}, {}, {}\13\n\9bufferWidth = width\13\n\9bufferHeight = height\13\n\9resetDrawLimit()\13\n\13\n\9for y = 1, bufferHeight do\13\n\9\9for x = 1, bufferWidth do\13\n\9\9\9tableInsert(currentFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(currentFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(currentFrameSymbols, \" \")\13\n\13\n\9\9\9tableInsert(newFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(newFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(newFrameSymbols, \" \")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function setResolution(width, height)\13\n\9GPUProxySetResolution(width, height)\13\n\9flush(width, height)\13\nend\13\n\13\nlocal function getResolution()\13\n\9return bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getWidth()\13\n\9return bufferWidth\13\nend\13\n\13\nlocal function getHeight()\13\n\9return bufferHeight\13\nend\13\n\13\nlocal function bindScreen(...)\13\n\9GPUProxyBind(...)\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\nlocal function getGPUProxy()\13\n\9return GPUProxy\13\nend\13\n\13\nlocal function updateGPUProxyMethods()\13\n\9GPUProxyGet = GPUProxy.get\13\n\9GPUProxyGetResolution = GPUProxy.getResolution\13\n\9GPUProxyGetBackground = GPUProxy.getBackground\13\n\9GPUProxyGetForeground = GPUProxy.getForeground\13\n\13\n\9GPUProxySet = GPUProxy.set\13\n\9GPUProxySetResolution = GPUProxy.setResolution\13\n\9GPUProxySetBackground = GPUProxy.setBackground\13\n\9GPUProxySetForeground = GPUProxy.setForeground\13\n\13\n\9GPUProxyBind = GPUProxy.bind\13\n\9GPUProxyFill = GPUProxy.fill\13\nend\13\n\13\nlocal function bindGPU(address)\13\n\9GPUProxy = component.proxy(address)\13\n\9updateGPUProxyMethods()\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function rawSet(index, background, foreground, symbol)\13\n\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9if bufferOnly then\13\n\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9end\13\nend\13\n\13\nlocal function rawGet(index)\13\n\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\nend\13\n\13\nlocal function get(x, y)\13\n\9if x >= 1 and y >= 1 and x <= bufferWidth and y <= bufferHeight then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9else\13\n\9\9return 0x000000, 0x000000, \" \"\13\n\9end\13\nend\13\n\13\nlocal function set(x, y, background, foreground, symbol)\13\n\9if x >= drawLimitX1 and y >= drawLimitY1 and x <= drawLimitX2 and y <= drawLimitY2 and isDrawable(x, y) then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9if bufferOnly then\13\n\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawRectangle(x, y, width, height, background, foreground, symbol, transparency) \13\n\9local index, indexStepOnReachOfSquareWidth = bufferWidth * (y - 1) + x, bufferWidth - width\13\n\9for j = y, y + height - 1 do\13\n\9\9if j >= drawLimitY1 and j <= drawLimitY2 then\13\n\9\9\9for i = x, x + width - 1 do\13\n\9\9\9\9if i >= drawLimitX1 and i <= drawLimitX2 and isDrawable(i, j) then\13\n\9\9\9\9\9if transparency then\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9colorBlend(newFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9colorBlend(newFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9\9colorBlend(currentFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[index], currentFrameForegrounds[index], currentFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9index = index + 1\13\n\9\9\9end\13\n\13\n\9\9\9index = index + indexStepOnReachOfSquareWidth\13\n\9\9else\13\n\9\9\9index = index + bufferWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clear(color, transparency)\13\n\9drawRectangle(1, 1, bufferWidth, bufferHeight, color or 0x0, 0x000000, \" \", transparency)\13\nend\13\n\13\nlocal function copy(x, y, width, height, current)\13\n\9local copyArray, index = { width, height }\13\n\9local rawCopyArray = { width, height }\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, newFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameSymbols[index])\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameForegrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameSymbols[index])\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, \" \")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return copyArray, rawCopyArray\13\nend\13\n\13\nlocal function paste(startX, startY, picture, currentPicture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\9\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9newFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9\9if currentPicture ~= nil then\13\n\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = currentPicture[pictureIndex]\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = currentPicture[pictureIndex + 1]\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = currentPicture[pictureIndex + 2]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function copyCurrent(x, y, width, height)\13\n\9local copyArray, index = { width, height }\13\n\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameSymbols[index])\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return copyArray\13\nend\13\n\13\nlocal function pasteCurrent(startX, startY, picture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9currentFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function directCopy(x, y, width, height, tx, ty, current, actualBuffer)\13\n\9local index\13\n\9local imageWidth = width\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (ty - 1) + tx, 3, bufferWidth - imageWidth\13\n\9\13\n\9local newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols\13\n\9\13\n\9if actualBuffer then\13\n\9\9newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9else\13\n\9\9newBackgrounds, newForegrounds, newSymbols = {table.unpack(newFrameBackgrounds)}, {table.unpack(newFrameForegrounds)}, {table.unpack(newFrameSymbols)}\13\n\9\13\n\9\13\n\9\9if current or bufferOnly then\13\n\9\9\9currentBackgrounds, currentForegrounds, currentSymbols = {table.unpack(currentFrameBackgrounds)}, {table.unpack(currentFrameForegrounds)}, {table.unpack(currentFrameSymbols)}\13\n\9\9end\13\n\9end\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9local newX, newY = getCoordinates(bufferIndex)\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(ewX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9newForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9newSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = currentFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = currentFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = currentFrameSymbols[index]\13\n\9\9\9\9\9\9--[[\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\9]]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(newX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9newSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9--[[\13\n\9\9\9\9\9newBackgrounds[newIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[newIndex] = 0x0\13\n\9\9\9\9\9newSymbols[newIndex] = \" \"\13\n\9\9\9\9\9]]\13\n\9\9\9\9\9if current or bufferOnly then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9end\13\n\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9end\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = newBackgrounds, newForegrounds, newSymbols\13\n\9if current or bufferOnly then\13\n\9\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols = currentBackgrounds, currentForegrounds, currentSymbols\13\n\9end\13\nend\13\n\13\nlocal function rasterizeLine(x1, y1, x2, y2, method)\13\n\9local inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = x1, x2, y1, y2, false, mathAbs(x2 - x1), mathAbs(y2 - y1)\13\n\9if inLoopValueDelta < outLoopValueDelta then\13\n\9\9inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = y1, y2, x1, x2, true, outLoopValueDelta, inLoopValueDelta\13\n\9end\13\n\13\n\9if outLoopValueFrom > outLoopValueTo then\13\n\9\9outLoopValueFrom, outLoopValueTo = outLoopValueTo, outLoopValueFrom\13\n\9\9inLoopValueFrom, inLoopValueTo = inLoopValueTo, inLoopValueFrom\13\n\9end\13\n\13\n\9local outLoopValue, outLoopValueCounter, outLoopValueTriggerIncrement = outLoopValueFrom, 1, inLoopValueDelta / outLoopValueDelta\13\n\9local outLoopValueTrigger = outLoopValueTriggerIncrement\13\n\9for inLoopValue = inLoopValueFrom, inLoopValueTo, inLoopValueFrom < inLoopValueTo and 1 or -1 do\13\n\9\9if isReversed then\13\n\9\9\9method(outLoopValue, inLoopValue)\13\n\9\9else\13\n\9\9\9method(inLoopValue, outLoopValue)\13\n\9\9end\13\n\13\n\9\9outLoopValueCounter = outLoopValueCounter + 1\13\n\9\9if outLoopValueCounter > outLoopValueTrigger then\13\n\9\9\9outLoopValue, outLoopValueTrigger = outLoopValue + 1, outLoopValueTrigger + outLoopValueTriggerIncrement\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function rasterizeEllipse(centerX, centerY, radiusX, radiusY, method)\13\n\9local function rasterizeEllipsePoints(XP, YP)\13\n\9\9method(centerX + XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY - YP)\13\n\9\9method(centerX + XP, centerY - YP) \13\n\9end\13\n\13\n\9local x, y, changeX, changeY, ellipseError, twoASquare, twoBSquare = radiusX, 0, radiusY * radiusY * (1 - 2 * radiusX), radiusX * radiusX, 0, 2 * radiusX * radiusX, 2 * radiusY * radiusY\13\n\9local stoppingX, stoppingY = twoBSquare * radiusX, 0\13\n\13\n\9while stoppingX >= stoppingY do\13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9y, stoppingY, ellipseError = y + 1, stoppingY + twoASquare, ellipseError + changeY\13\n\9\9changeY = changeY + twoASquare\13\n\13\n\9\9if (2 * ellipseError + changeX) > 0 then\13\n\9\9\9x, stoppingX, ellipseError = x - 1, stoppingX - twoBSquare, ellipseError + changeX\13\n\9\9\9changeX = changeX + twoBSquare\13\n\9\9end\13\n\9end\13\n\13\n\9x, y, changeX, changeY, ellipseError, stoppingX, stoppingY = 0, radiusY, radiusY * radiusY, radiusX * radiusX * (1 - 2 * radiusY), 0, 0, twoASquare * radiusY\13\n\13\n\9while stoppingX <= stoppingY do \13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9x, stoppingX, ellipseError = x + 1, stoppingX + twoBSquare, ellipseError + changeX\13\n\9\9changeX = changeX + twoBSquare\13\n\9\9\13\n\9\9if (2 * ellipseError + changeY) > 0 then\13\n\9\9\9y, stoppingY, ellipseError = y - 1, stoppingY - twoASquare, ellipseError + changeY\13\n\9\9\9changeY = changeY + twoASquare\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawLine(x1, y1, x2, y2, background, foreground, symbol)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawEllipse(centerX, centerY, radiusX, radiusY, background, foreground, symbol)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawText(x, y, textColor, data, transparency)\13\n\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9local charIndex, bufferIndex = 1, bufferWidth * (y - 1) + x\13\n\9\9\13\n\9\9for charIndex = 1, unicodeLen(data) do\13\n\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9if transparency then\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9\9end\13\n\9\9\9\9else\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9newFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\13\n\9\9\9x, bufferIndex = x + 1, bufferIndex + 1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawImage(startX, startY, picture, blendForeground)\13\n\9local bufferIndex, pictureIndex, imageWidth, backgrounds, foregrounds, alphas, symbols = bufferWidth * (startY - 1) + startX, 1, picture[1], picture[3], picture[4], picture[5], picture[6]\13\n\9local bufferIndexStepOnReachOfImageWidth = bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9if alphas[pictureIndex] == 0 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex], newFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex], currentFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] > 0 and alphas[pictureIndex] < 1 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = colorBlend(currentFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if blendForeground then\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = colorBlend(currentFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9\9end\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] == 1 and symbols[pictureIndex] ~= \" \" then\13\n\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9if bufferOnly then\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 1\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(x, y, width, height, color)\13\n\9local stringUp, stringDown, x2 = \"\" .. string.rep(\"\", width - 2) .. \"\", \"\" .. string.rep(\"\", width - 2) .. \"\", x + width - 1\13\n\9\13\n\9drawText(x, y, color, stringUp); y = y + 1\13\n\9for i = 1, height - 2 do\13\n\9\9drawText(x, y, color, \"\")\13\n\9\9drawText(x2, y, color, \"\")\13\n\9\9y = y + 1\13\n\9end\13\n\9drawText(x, y, color, stringDown)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function semiPixelRawSet(index, color, yPercentTwoEqualsZero, internalRun) --ToDo\13\n\9local upperPixel, lowerPixel, bothPixel = \"\", \"\", \" \"\13\n\9local backgroundBuffer, foregroundBuffer, symbolBuffer = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\n\9\13\n\9if internalRun then\13\n\9\9backgroundBuffer, foregroundBuffer, symbolBuffer = currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9end\13\n\9\13\n\9local background, foreground, symbol = backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index]\13\n\13\n\9if yPercentTwoEqualsZero then\13\n\9\9if symbol == upperPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, lowerPixel\13\n\9\9end\13\n\9else\13\n\9\9if symbol == lowerPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9backgroundBuffer[index], foregroundBuffer[index], symbolBuffer[index] = background, color, upperPixel\13\n\9\9end\13\n\9end\13\n\9\13\n\9if bufferOnly and not internalRun then\13\n\9\9semiPixelRawSet(index, color, yPercentTwoEqualsZero, true)\13\n\9end\13\nend\13\n\13\nlocal function semiPixelSet(x, y, color)\13\n\9local yFixed = mathCeil(y / 2)\13\n\9if x >= drawLimitX1 and yFixed >= drawLimitY1 and x <= drawLimitX2 and yFixed <= drawLimitY2 and isDrawable(x, yFixed) then\13\n\9\9semiPixelRawSet(bufferWidth * (yFixed - 1) + x, color, y % 2 == 0)\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelRectangle(x, y, width, height, color)\13\n\9local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = bufferWidth * (mathCeil(y / 2) - 1) + x, (bufferWidth - width), width\13\n\9for j = y, y + height - 1 do\13\n\9\9jPercentTwoEqualsZero = j % 2 == 0\13\n\9\9\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9jFixed = mathCeil(j / 2)\13\n\9\9\9semiPixelRawSet(index, color, jPercentTwoEqualsZero)\13\n\9\9\9index = index + 1\13\n\9\9end\13\n\13\n\9\9if jPercentTwoEqualsZero then\13\n\9\9\9index = index + indexStepForward\13\n\9\9else\13\n\9\9\9index = index - indexStepBackward\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelLine(x1, y1, x2, y2, color)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\nlocal function drawSemiPixelEllipse(centerX, centerY, radiusX, radiusY, color)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getPointTimedPosition(firstPoint, secondPoint, time)\13\n\9return {\13\n\9\9x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,\13\n\9\9y = firstPoint.y + (secondPoint.y - firstPoint.y) * time\13\n\9}\13\nend\13\n\13\nlocal function getConnectionPoints(points, time)\13\n\9local connectionPoints = {}\13\n\9for point = 1, #points - 1 do\13\n\9\9tableInsert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))\13\n\9end\13\n\9return connectionPoints\13\nend\13\n\13\nlocal function getMainPointPosition(points, time)\13\n\9if #points > 1 then\13\n\9\9return getMainPointPosition(getConnectionPoints(points, time), time)\13\n\9else\13\n\9\9return points[1]\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelCurve(points, color, precision)\13\n\9local linePoints = {}\13\n\9for time = 0, 1, precision or 0.01 do\13\n\9\9tableInsert(linePoints, getMainPointPosition(points, time))\13\n\9end\13\n\9\13\n\9for point = 1, #linePoints - 1 do\13\n\9\9drawSemiPixelLine(mathFloor(linePoints[point].x), mathFloor(linePoints[point].y), mathFloor(linePoints[point + 1].x), mathFloor(linePoints[point + 1].y), color)\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function drawChanges(force)\13\n\9local index, indexStepOnEveryLine, changes = bufferWidth * (drawLimitY1 - 1) + drawLimitX1, (bufferWidth - drawLimitX2 + drawLimitX1 - 1), {}\13\n\9local x, equalChars, equalCharsIndex, charX, charIndex, currentForeground\13\n\9local currentFrameBackground, currentFrameForeground, currentFrameSymbol, changesCurrentFrameBackground, changesCurrentFrameBackgroundCurrentFrameForeground\13\n\13\n\9local changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\13\n\9for y = drawLimitY1, drawLimitY2 do\13\n\9\9x = drawLimitX1\13\n\9\9while x <= drawLimitX2 do\9\9\9\13\n\9\9\9-- Determine if some pixel data was changed (or if <force> argument was passed)\13\n\9\9\9if\13\n\9\9\9\9currentFrameBackgrounds[index] ~= newFrameBackgrounds[index] or\13\n\9\9\9\9currentFrameForegrounds[index] ~= newFrameForegrounds[index] or\13\n\9\9\9\9currentFrameSymbols[index] ~= newFrameSymbols[index] or\13\n\9\9\9\9force\13\n\9\9\9then\13\n\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9currentFrameBackground, currentFrameForeground, currentFrameSymbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9\9\9\9currentFrameBackgrounds[index] = currentFrameBackground\13\n\9\9\9\9currentFrameForegrounds[index] = currentFrameForeground\13\n\9\9\9\9currentFrameSymbols[index] = currentFrameSymbol\13\n\13\n\9\9\9\9-- Look for pixels with equal chars from right of current pixel\13\n\9\9\9\9equalChars, equalCharsIndex, charX, charIndex = {currentFrameSymbol}, 2, x + 1, index + 1\13\n\9\9\9\9while charX <= drawLimitX2 do\13\n\9\9\9\9\9-- Pixels becomes equal only if they have same background and (whitespace char or same foreground)\13\n\9\9\9\9\9if\9\13\n\9\9\9\9\9\9currentFrameBackground == newFrameBackgrounds[charIndex] and\13\n\9\9\9\9\9\9(\13\n\9\9\9\9\9\9\9newFrameSymbols[charIndex] == \" \" or\13\n\9\9\9\9\9\9\9currentFrameForeground == newFrameForegrounds[charIndex]\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9\9 \9currentFrameBackgrounds[charIndex] = newFrameBackgrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameForegrounds[charIndex] = newFrameForegrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameSymbols[charIndex] = newFrameSymbols[charIndex]\13\n\13\n\9\9\9\9\9 \9equalChars[equalCharsIndex], equalCharsIndex = currentFrameSymbols[charIndex], equalCharsIndex + 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9charX, charIndex = charX + 1, charIndex + 1\13\n\9\9\9\9end\13\n\13\n\9\9\9\9-- Group pixels that need to be drawn by background and foreground\13\n\9\9\9\9changes[currentFrameBackground] = changes[currentFrameBackground] or {}\13\n\9\9\9\9changesCurrentFrameBackground = changes[currentFrameBackground]\13\n\9\9\9\9changesCurrentFrameBackground[currentFrameForeground] = changesCurrentFrameBackground[currentFrameForeground] or {index = 1}\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground = changesCurrentFrameBackground[currentFrameForeground]\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForegroundIndex = changesCurrentFrameBackgroundCurrentFrameForeground.index\13\n\9\9\9\9\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = x, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = y, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = tableConcat(equalChars), changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9\13\n\9\9\9\9x, index, changesCurrentFrameBackgroundCurrentFrameForeground.index = x + equalCharsIndex - 2, index + equalCharsIndex - 2, changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\9\9\9end\13\n\13\n\9\9\9x, index = x + 1, index + 1\13\n\9\9end\13\n\13\n\9\9index = index + indexStepOnEveryLine\13\n\9end\13\n\9\13\n\9-- Draw grouped pixels on screen\13\n\9for background, foregrounds in pairs(changes) do\13\n\9\9GPUProxySetBackground(background)\13\n\13\n\9\9for foreground, pixels in pairs(foregrounds) do\13\n\9\9\9if currentForeground ~= foreground then\13\n\9\9\9\9GPUProxySetForeground(foreground)\13\n\9\9\9\9currentForeground = foreground\13\n\9\9\9end\13\n\13\n\9\9\9for i = 1, #pixels, 3 do\13\n\9\9\9\9GPUProxySet(pixels[i], pixels[i + 1], pixels[i + 2])\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9changes = nil\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nbindGPU(component.getPrimary(\"gpu\").address)\13\n\13\nreturn {\13\n\9getCoordinates = getCoordinates,\13\n\9getIndex = getIndex,\13\n\9setDrawLimit = setDrawLimit,\13\n\9resetDrawLimit = resetDrawLimit,\13\n\9getDrawLimit = getDrawLimit,\13\n\9flush = flush,\13\n\9setResolution = setResolution,\13\n\9bindScreen = bindScreen,\13\n\9bindGPU = bindGPU,\13\n\9getGPUProxy = getGPUProxy,\13\n\9getResolution = getResolution,\13\n\9getWidth = getWidth,\13\n\9getHeight = getHeight,\13\n\9getCurrentFrameTables = getCurrentFrameTables,\13\n\9getNewFrameTables = getNewFrameTables,\13\n\9setCurrentFrameTables = setCurrentFrameTables,\13\n\9setNewFrameTables = setNewFrameTables,\13\n\9setBufferOnly = setBufferOnly,\13\n\9getBufferOnly = getBufferOnly,\13\n\13\n\9rawSet = rawSet,\13\n\9rawGet = rawGet,\13\n\9get = get,\13\n\9set = set,\13\n\9clear = clear,\13\n\9copy = copy,\13\n\9paste = paste,\13\n\9directCopy = directCopy,\13\n\9copyCurrent = copyCurrent,\13\n\9pasteCurrent = pasteCurrent,\13\n\9rasterizeLine = rasterizeLine,\13\n\9rasterizeEllipse = rasterizeEllipse,\13\n\9semiPixelRawSet = semiPixelRawSet,\13\n\9semiPixelSet = semiPixelSet,\13\n\9drawChanges = drawChanges,\13\n\13\n\9drawRectangle = drawRectangle,\13\n\9drawLine = drawLine,\13\n\9drawEllipse = drawEllipse,\13\n\9drawText = drawText,\13\n\9drawImage = drawImage,\13\n\9drawFrame = drawFrame,\13\n\13\n\9drawSemiPixelRectangle = drawSemiPixelRectangle,\13\n\9drawSemiPixelLine = drawSemiPixelLine,\13\n\9drawSemiPixelEllipse = drawSemiPixelEllipse,\13\n\9drawSemiPixelCurve = drawSemiPixelCurve,\13\n\9\13\n\9setDrawAreas = setDrawAreas,\13\n\9resetDrawAreas = resetDrawAreas,\13\n\9getDrawAreas = getDrawAreas,\13\n\9setNonDrawAreas = setNonDrawAreas,\13\n\9resetNonDrawAreas = resetNonDrawAreas,\13\n\9getNonDrawAreas = getNonDrawAreas,\13\n\9\13\n\9setDrawAreaOffset = setDrawAreaOffset,\13\n\9getDrawAreaOffset = getDrawAreaOffset,\13\n\9resetDrawAreaOffset = resetDrawAreaOffset,\13\n}",["./libs/thirdParty/color.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are possibly made some changes if needed to fit in to the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/Color>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\ncolor Copyright (c) 2018 \13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\n\13\nlocal computer = require(\"computer\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal palette = {0x000000, 0x000040, 0x000080, 0x0000BF, 0x0000FF, 0x002400, 0x002440, 0x002480, 0x0024BF, 0x0024FF, 0x004900, 0x004940, 0x004980, 0x0049BF, 0x0049FF, 0x006D00, 0x006D40, 0x006D80, 0x006DBF, 0x006DFF, 0x009200, 0x009240, 0x009280, 0x0092BF, 0x0092FF, 0x00B600, 0x00B640, 0x00B680, 0x00B6BF, 0x00B6FF, 0x00DB00, 0x00DB40, 0x00DB80, 0x00DBBF, 0x00DBFF, 0x00FF00, 0x00FF40, 0x00FF80, 0x00FFBF, 0x00FFFF, 0x0F0F0F, 0x1E1E1E, 0x2D2D2D, 0x330000, 0x330040, 0x330080, 0x3300BF, 0x3300FF, 0x332400, 0x332440, 0x332480, 0x3324BF, 0x3324FF, 0x334900, 0x334940, 0x334980, 0x3349BF, 0x3349FF, 0x336D00, 0x336D40, 0x336D80, 0x336DBF, 0x336DFF, 0x339200, 0x339240, 0x339280, 0x3392BF, 0x3392FF, 0x33B600, 0x33B640, 0x33B680, 0x33B6BF, 0x33B6FF, 0x33DB00, 0x33DB40, 0x33DB80, 0x33DBBF, 0x33DBFF, 0x33FF00, 0x33FF40, 0x33FF80, 0x33FFBF, 0x33FFFF, 0x3C3C3C, 0x4B4B4B, 0x5A5A5A, 0x660000, 0x660040, 0x660080, 0x6600BF, 0x6600FF, 0x662400, 0x662440, 0x662480, 0x6624BF, 0x6624FF, 0x664900, 0x664940, 0x664980, 0x6649BF, 0x6649FF, 0x666D00, 0x666D40, 0x666D80, 0x666DBF, 0x666DFF, 0x669200, 0x669240, 0x669280, 0x6692BF, 0x6692FF, 0x66B600, 0x66B640, 0x66B680, 0x66B6BF, 0x66B6FF, 0x66DB00, 0x66DB40, 0x66DB80, 0x66DBBF, 0x66DBFF, 0x66FF00, 0x66FF40, 0x66FF80, 0x66FFBF, 0x66FFFF, 0x696969, 0x787878, 0x878787, 0x969696, 0x990000, 0x990040, 0x990080, 0x9900BF, 0x9900FF, 0x992400, 0x992440, 0x992480, 0x9924BF, 0x9924FF, 0x994900, 0x994940, 0x994980, 0x9949BF, 0x9949FF, 0x996D00, 0x996D40, 0x996D80, 0x996DBF, 0x996DFF, 0x999200, 0x999240, 0x999280, 0x9992BF, 0x9992FF, 0x99B600, 0x99B640, 0x99B680, 0x99B6BF, 0x99B6FF, 0x99DB00, 0x99DB40, 0x99DB80, 0x99DBBF, 0x99DBFF, 0x99FF00, 0x99FF40, 0x99FF80, 0x99FFBF, 0x99FFFF, 0xA5A5A5, 0xB4B4B4, 0xC3C3C3, 0xCC0000, 0xCC0040, 0xCC0080, 0xCC00BF, 0xCC00FF, 0xCC2400, 0xCC2440, 0xCC2480, 0xCC24BF, 0xCC24FF, 0xCC4900, 0xCC4940, 0xCC4980, 0xCC49BF, 0xCC49FF, 0xCC6D00, 0xCC6D40, 0xCC6D80, 0xCC6DBF, 0xCC6DFF, 0xCC9200, 0xCC9240, 0xCC9280, 0xCC92BF, 0xCC92FF, 0xCCB600, 0xCCB640, 0xCCB680, 0xCCB6BF, 0xCCB6FF, 0xCCDB00, 0xCCDB40, 0xCCDB80, 0xCCDBBF, 0xCCDBFF, 0xCCFF00, 0xCCFF40, 0xCCFF80, 0xCCFFBF, 0xCCFFFF, 0xD2D2D2, 0xE1E1E1, 0xF0F0F0, 0xFF0000, 0xFF0040, 0xFF0080, 0xFF00BF, 0xFF00FF, 0xFF2400, 0xFF2440, 0xFF2480, 0xFF24BF, 0xFF24FF, 0xFF4900, 0xFF4940, 0xFF4980, 0xFF49BF, 0xFF49FF, 0xFF6D00, 0xFF6D40, 0xFF6D80, 0xFF6DBF, 0xFF6DFF, 0xFF9200, 0xFF9240, 0xFF9280, 0xFF92BF, 0xFF92FF, 0xFFB600, 0xFFB640, 0xFFB680, 0xFFB6BF, 0xFFB6FF, 0xFFDB00, 0xFFDB40, 0xFFDB80, 0xFFDBBF, 0xFFDBFF, 0xFFFF00, 0xFFFF40, 0xFFFF80, 0xFFFFBF, 0xFFFFFF}\13\nlocal mathFloor, mathMax, mathMin, mathModf = math.floor, math.max, math.min, math.modf\13\nlocal integerToRGB, RGBToInteger, blend, transition, to8Bit\13\n\13\nlocal color = {}\13\n\13\n--------------------------------------------------------------------------------\13\n\13\n-- Optimized Lua 5.3 bitwise support\13\nif computer.getArchitecture and computer.getArchitecture() == \"Lua 5.3\" then\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9return integerColor >> 16, integerColor >> 8 & 0xFF, integerColor & 0xFF\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r << 16 | g << 8 | b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9return\13\n\9\9\9\9\9((color2 >> 16) * invertedTransparency + (color1 >> 16) * transparency) // 1 << 16 |\13\n\9\9\9\9\9((color2 >> 8 & 0xFF) * invertedTransparency + (color1 >> 8 & 0xFF) * transparency) // 1 << 8 |\13\n\9\9\9\9\9((color2 & 0xFF) * invertedTransparency + (color1 & 0xFF) * transparency) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1, g1, b1 = color1 >> 16, color1 >> 8 & 0xFF, color1 & 0xFF\13\n\9\9\9\9return\13\n\9\9\9\9\9(r1 + ((color2 >> 16) - r1) * position) // 1 << 16 |\13\n\9\9\9\9\9(g1 + ((color2 >> 8 & 0xFF) - g1) * position) // 1 << 8 |\13\n\9\9\9\9\9(b1 + ((color2 & 0xFF) - b1) * position) // 1\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local r, g, b, closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = color24Bit >> 16, color24Bit >> 8 & 0xFF, color24Bit & 0xFF, mathHuge, 1\13\n\13\n\9\9\9\9for i = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[i]\13\n\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return i - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR, paletteG, paletteB = paletteColor >> 16, paletteColor >> 8 & 0xFF, paletteColor & 0xFF\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, i\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nelse\13\n\9integerToRGB, RGBToInteger, blend, transition, to8Bit = load([[\13\n\9\9local mathHuge, palette = math.huge, select(1, ...)\13\n\13\n\9\9return\13\n\9\9\9function(integerColor)\13\n\9\9\9\9local r = integerColor / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (integerColor - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\13\n\9\9\9\9return r, g, integerColor - r * 65536 - g * 256\13\n\9\9\9end,\13\n\13\n\9\9\9function(r, g, b)\13\n\9\9\9\9return r * 65536 + g * 256 + b\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, transparency)\13\n\9\9\9\9local invertedTransparency = 1 - transparency\13\n\9\9\9\9\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r2 * invertedTransparency + r1 * transparency,\13\n\9\9\9\9\9g2 * invertedTransparency + g1 * transparency,\13\n\9\9\9\9\9(color2 - r2 * 65536 - g2 * 256) * invertedTransparency + (color1 - r1 * 65536 - g1 * 256) * transparency\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color1, color2, position)\13\n\9\9\9\9local r1 = color1 / 65536\13\n\9\9\9\9r1 = r1 - r1 % 1\13\n\9\9\9\9local g1 = (color1 - r1 * 65536) / 256\13\n\9\9\9\9g1 = g1 - g1 % 1\13\n\9\9\9\9local b1 = color1 - r1 * 65536 - g1 * 256\13\n\13\n\9\9\9\9local r2 = color2 / 65536\13\n\9\9\9\9r2 = r2 - r2 % 1\13\n\9\9\9\9local g2 = (color2 - r2 * 65536) / 256\13\n\9\9\9\9g2 = g2 - g2 % 1\13\n\13\n\9\9\9\9local r, g, b =\13\n\9\9\9\9\9r1 + (r2 - r1) * position,\13\n\9\9\9\9\9g1 + (g2 - g1) * position,\13\n\9\9\9\9\9b1 + (color2 - r2 * 65536 - g2 * 256 - b1) * position\13\n\13\n\9\9\9\9return\13\n\9\9\9\9\9(r - r % 1) * 65536 +\13\n\9\9\9\9\9(g - g % 1) * 256 +\13\n\9\9\9\9\9(b - b % 1)\13\n\9\9\9end,\13\n\13\n\9\9\9function(color24Bit)\13\n\9\9\9\9local closestDelta, closestIndex, delta, paletteColor, paletteR, paletteG, paletteB = mathHuge, 1\13\n\13\n\9\9\9\9local r = color24Bit / 65536\13\n\9\9\9\9r = r - r % 1\13\n\9\9\9\9local g = (color24Bit - r * 65536) / 256\13\n\9\9\9\9g = g - g % 1\13\n\9\9\9\9local b = color24Bit - r * 65536 - g * 256\13\n\13\n\9\9\9\9for index = 1, #palette do\13\n\9\9\9\9\9paletteColor = palette[index]\13\n\9\9\9\9\9if color24Bit == paletteColor then\13\n\9\9\9\9\9\9return index - 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9paletteR = paletteColor / 65536\13\n\9\9\9\9\9\9paletteR = paletteR - paletteR % 1\13\n\9\9\9\9\9\9paletteG = (paletteColor - paletteR * 65536) / 256\13\n\9\9\9\9\9\9paletteG = paletteG - paletteG % 1\13\n\9\9\9\9\9\9paletteB = paletteColor - paletteR * 65536 - paletteG * 256\13\n\13\n\9\9\9\9\9\9delta = (paletteR - r) ^ 2 + (paletteG - g) ^ 2 + (paletteB - b) ^ 2\13\n\9\9\9\9\9\9if delta < closestDelta then\13\n\9\9\9\9\9\9\9closestDelta, closestIndex = delta, index\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9return closestIndex - 1\13\n\9\9\9end\13\n\9]])(palette)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function RGBToHSB(r, g, b)\13\n\9local max, min = mathMax(r, g, b), mathMin(r, g, b)\13\n\13\n\9if max == min then\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g >= b then\13\n\9\9return 60 * (g - b) / (max - min), max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == r and g < b then\13\n\9\9return 60 * (g - b) / (max - min) + 360, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == g then\13\n\9\9return 60 * (b - r) / (max - min) + 120, max == 0 and 0 or (1 - min / max), max / 255\13\n\9elseif max == b then\13\n\9\9return 60 * (r - g) / (max - min) + 240, max == 0 and 0 or (1 - min / max), max / 255\13\n\9else\13\n\9\9return 0, max == 0 and 0 or (1 - min / max), max / 255\13\n\9end\13\nend\13\n\13\nlocal function HSBToRGB(h, s, b)\13\n\9local integer, fractional = mathModf(h / 60)\9\13\n\9local p, q, t = b * (1 - s), b * (1 - s * fractional), b * (1 - (1 - fractional) * s)\13\n\13\n\9if integer == 0 then\13\n\9\9return mathFloor(b * 255), mathFloor(t * 255), mathFloor(p * 255)\13\n\9elseif integer == 1 then\13\n\9\9return mathFloor(q * 255), mathFloor(b * 255), mathFloor(p * 255)\13\n\9elseif integer == 2 then\13\n\9\9return mathFloor(p * 255), mathFloor(b * 255), mathFloor(t * 255)\13\n\9elseif integer == 3 then\13\n\9\9return mathFloor(p * 255), mathFloor(q * 255), mathFloor(b * 255)\13\n\9elseif integer == 4 then\13\n\9\9return mathFloor(t * 255), mathFloor(p * 255), mathFloor(b * 255)\13\n\9else\13\n\9\9return mathFloor(b * 255), mathFloor(p * 255), mathFloor(q * 255)\13\n\9end\13\nend\13\n\13\nlocal function integerToHSB(integerColor)\13\n\9return RGBToHSB(integerToRGB(integerColor))\13\nend\13\n\13\nlocal function HSBToInteger(h, s, b)\13\n\9return RGBToInteger(HSBToRGB(h, s, b))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function to24Bit(color8Bit)\13\n\9return palette[color8Bit + 1]\13\nend\13\n\13\nlocal function optimize(color24Bit)\13\n\9return to24Bit(to8Bit(color24Bit))\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nreturn {\13\n\9RGBToInteger = RGBToInteger,\13\n\9integerToRGB = integerToRGB,\13\n\9RGBToHSB = RGBToHSB,\13\n\9HSBToRGB = HSBToRGB,\13\n\9integerToHSB = integerToHSB,\13\n\9HSBToInteger = HSBToInteger,\13\n\9blend = blend,\13\n\9transition = transition,\13\n\9to8Bit = to8Bit,\13\n\9to24Bit = to24Bit,\13\n\9optimize = optimize,\13\n}",["./libs/thirdParty/DoubleBuffering - Copy.lua"] = "--[[\13\n\9This libary is third pary content by IgorTimofeev wich is licensed under the MIT License.\13\n\9\13\n\9There are made some changes to provide the best possible performance in combination with the NosGa Engine (<https://github.com/NosPo-Studio/NosGa-Engine>).\13\n\9\13\n\9Original source code repo: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n]]\13\n\13\n--[[\13\nMIT License\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (NosPo version) Copyright (c) 2019-2020 NosPo Studio\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\13\n]]\13\nlocal version = \"v0.6\" --NosPo version.\13\n\13\nlocal component = require(\"component\")\13\nlocal unicode = require(\"unicode\")\13\nlocal color = require(\"libs/thirdParty/color\")\13\nlocal image = require(\"libs/thirdParty/image\")\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal bufferWidth, bufferHeight\13\nlocal currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nlocal drawLimitX1, drawLimitX2, drawLimitY1, drawLimitY2\13\nlocal GPUProxy, GPUProxyGetResolution, GPUProxySetResolution, GPUProxyBind, GPUProxyGetBackground, GPUProxyGetForeground, GPUProxySetBackground, GPUProxySetForeground, GPUProxyGet, GPUProxySet, GPUProxyFill\13\n\13\nlocal mathCeil, mathFloor, mathModf, mathAbs = math.ceil, math.floor, math.modf, math.abs\13\nlocal tableInsert, tableConcat = table.insert, table.concat\13\nlocal colorBlend = color.blend\13\nlocal unicodeLen, unicodeSub = unicode.len, unicode.sub\13\n\13\nlocal drawAreas, nonDrawAreas = {}, {} --drawAreas == pixelWhiteList, nonDrawAreas == pixelBlackList\13\nlocal drawAreasAreWhitelist = true\13\nlocal drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getIndex(x, y)\13\n\9return bufferWidth * (y - 1) + x\13\nend\13\n\13\nlocal function getCoordinates(index)\13\n\9return index % bufferWidth, math.floor(index / bufferWidth) +1\13\nend\13\n\13\nlocal function getCurrentFrameTables()\13\n\9return currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\nend\13\n\13\nlocal function getNewFrameTables()\13\n\9return newFrameBackgrounds, newFrameForegrounds, newFrameSymbols\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function setDrawLimit(x1, y1, x2, y2)\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = x1, y1, x2, y2\13\nend\13\n\13\nlocal function resetDrawLimit()\13\n\9drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2 = 1, 1, bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getDrawLimit()\13\n\9return drawLimitX1, drawLimitY1, drawLimitX2, drawLimitY2\13\nend\13\n\13\nlocal function setDrawAreas(areas)\13\n\9drawAreas = areas\13\nend\13\nlocal function resetDrawAreas()\13\n\9drawAreas = {}\13\nend\13\nlocal function getDrawAreas()\13\n\9return drawAreas\13\nend\13\nlocal function setNonDrawAreas(areas)\13\n\9nonDrawAreas = areas\13\nend\13\nlocal function resetNonDrawAreas()\13\n\9nonDrawAreas = {}\13\nend\13\nlocal function getNonDrawAreas()\13\n\9return nonDrawAreas\13\nend\13\n\13\nlocal function setDrawAreaOffset(x, y)\13\n\9drawAreaOffsetX = x or drawAreaOffsetX\13\n\9drawAreaOffsetY = y or drawAreaOffsetY\13\n\9\13\nend\13\nlocal function getDrawAreaOffset()\13\n\9return drawAreaOffsetX, drawAreaOffsetY\13\nend\13\nlocal function resetDrawAreaOffset()\13\n\9drawAreaOffsetX, drawAreaOffsetY = 0, 0\13\nend\13\n\13\nlocal function isDrawable(x, y)\13\n\9local drawable = true\13\n\9\13\n\9if #drawAreas == 0 and #nonDrawAreas == 0 then\13\n\9\9--return true\13\n\9end\13\n\9\13\n\9for _, a in pairs(drawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = true\13\n\9\9\9break\13\n\9\9end\13\n\9\9drawable = false\13\n\9end\13\n\9for _, a in pairs(nonDrawAreas) do\9\13\n\9\9if x >= a[1] + drawAreaOffsetX and x <= a[3] + drawAreaOffsetX and y >= a[2] + drawAreaOffsetY and y <= a[4] + drawAreaOffsetY then\13\n\9\9\9drawable = false\13\n\9\9\9break\13\n\9\9end\13\n\9end\13\n\9\13\n\9return drawable\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function flush(width, height)\13\n\9if not width or not height then\13\n\9\9width, height = GPUProxyGetResolution()\13\n\9end\13\n\13\n\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols, newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = {}, {}, {}, {}, {}, {}\13\n\9bufferWidth = width\13\n\9bufferHeight = height\13\n\9resetDrawLimit()\13\n\13\n\9for y = 1, bufferHeight do\13\n\9\9for x = 1, bufferWidth do\13\n\9\9\9tableInsert(currentFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(currentFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(currentFrameSymbols, \" \")\13\n\13\n\9\9\9tableInsert(newFrameBackgrounds, 0x010101)\13\n\9\9\9tableInsert(newFrameForegrounds, 0xFEFEFE)\13\n\9\9\9tableInsert(newFrameSymbols, \" \")\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function setResolution(width, height)\13\n\9GPUProxySetResolution(width, height)\13\n\9flush(width, height)\13\nend\13\n\13\nlocal function getResolution()\13\n\9return bufferWidth, bufferHeight\13\nend\13\n\13\nlocal function getWidth()\13\n\9return bufferWidth\13\nend\13\n\13\nlocal function getHeight()\13\n\9return bufferHeight\13\nend\13\n\13\nlocal function bindScreen(...)\13\n\9GPUProxyBind(...)\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\nlocal function getGPUProxy()\13\n\9return GPUProxy\13\nend\13\n\13\nlocal function updateGPUProxyMethods()\13\n\9GPUProxyGet = GPUProxy.get\13\n\9GPUProxyGetResolution = GPUProxy.getResolution\13\n\9GPUProxyGetBackground = GPUProxy.getBackground\13\n\9GPUProxyGetForeground = GPUProxy.getForeground\13\n\13\n\9GPUProxySet = GPUProxy.set\13\n\9GPUProxySetResolution = GPUProxy.setResolution\13\n\9GPUProxySetBackground = GPUProxy.setBackground\13\n\9GPUProxySetForeground = GPUProxy.setForeground\13\n\13\n\9GPUProxyBind = GPUProxy.bind\13\n\9GPUProxyFill = GPUProxy.fill\13\nend\13\n\13\nlocal function bindGPU(address)\13\n\9GPUProxy = component.proxy(address)\13\n\9updateGPUProxyMethods()\13\n\9flush(GPUProxyGetResolution())\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function rawSet(index, background, foreground, symbol)\13\n\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\nend\13\n\13\nlocal function rawGet(index)\13\n\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\nend\13\n\13\nlocal function get(x, y)\13\n\9if x >= 1 and y >= 1 and x <= bufferWidth and y <= bufferHeight then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9return newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9else\13\n\9\9return 0x000000, 0x000000, \" \"\13\n\9end\13\nend\13\n\13\nlocal function set(x, y, background, foreground, symbol)\13\n\9if x >= drawLimitX1 and y >= drawLimitY1 and x <= drawLimitX2 and y <= drawLimitY2 and isDrawable(x, y) then\13\n\9\9local index = bufferWidth * (y - 1) + x\13\n\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9end\13\nend\13\n\13\nlocal function drawRectangle(x, y, width, height, background, foreground, symbol, transparency) \13\n\9local index, indexStepOnReachOfSquareWidth = bufferWidth * (y - 1) + x, bufferWidth - width\13\n\9for j = y, y + height - 1 do\13\n\9\9if j >= drawLimitY1 and j <= drawLimitY2 then\13\n\9\9\9for i = x, x + width - 1 do\13\n\9\9\9\9if i >= drawLimitX1 and i <= drawLimitX2 and isDrawable(i, j) then\13\n\9\9\9\9\9if transparency then\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index] =\13\n\9\9\9\9\9\9\9colorBlend(newFrameBackgrounds[index], background, transparency),\13\n\9\9\9\9\9\9\9colorBlend(newFrameForegrounds[index], background, transparency)\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, foreground, symbol\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9index = index + 1\13\n\9\9\9end\13\n\13\n\9\9\9index = index + indexStepOnReachOfSquareWidth\13\n\9\9else\13\n\9\9\9index = index + bufferWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function clear(color, transparency)\13\n\9drawRectangle(1, 1, bufferWidth, bufferHeight, color or 0x0, 0x000000, \" \", transparency)\13\nend\13\n\13\nlocal function copy(x, y, width, height, current)\13\n\9local copyArray, index = { width, height }\13\n\9local rawCopyArray = { width, height }\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, newFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, newFrameSymbols[index])\13\n\9\9\9\9if current then\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameForegrounds[index])\13\n\9\9\9\9\9tableInsert(rawCopyArray, currentFrameSymbols[index])\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9\9if current then\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, 0x0)\13\n\9\9\9\9\9tableInsert(rawCopyArray, \" \")\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return copyArray, rawCopyArray\13\nend\13\n\13\nlocal function paste(startX, startY, picture, currentPicture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\9\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9newFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9\9if currentPicture ~= nil then\13\n\9\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = currentPicture[pictureIndex]\13\n\9\9\9\9\9\9currentFrameForegrounds[bufferIndex] = currentPicture[pictureIndex + 1]\13\n\9\9\9\9\9\9currentFrameSymbols[bufferIndex] = currentPicture[pictureIndex + 2]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function copyCurrent(x, y, width, height)\13\n\9local copyArray, index = { width, height }\13\n\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9tableInsert(copyArray, currentFrameBackgrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameForegrounds[index])\13\n\9\9\9\9tableInsert(copyArray, currentFrameSymbols[index])\13\n\9\9\9else\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, 0x0)\13\n\9\9\9\9tableInsert(copyArray, \" \")\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9return copyArray\13\nend\13\n\13\nlocal function pasteCurrent(startX, startY, picture)\13\n\9local imageWidth = picture[1]\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (startY - 1) + startX, 3, bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9currentFrameBackgrounds[bufferIndex] = picture[pictureIndex]\13\n\9\9\9\9\9currentFrameForegrounds[bufferIndex] = picture[pictureIndex + 1]\13\n\9\9\9\9\9currentFrameSymbols[bufferIndex] = picture[pictureIndex + 2]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth * 3\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function directCopy(x, y, width, height, tx, ty, current, actualBuffer)\13\n\9local index\13\n\9local imageWidth = width\13\n\9local bufferIndex, pictureIndex, bufferIndexStepOnReachOfImageWidth = bufferWidth * (ty - 1) + tx, 3, bufferWidth - imageWidth\13\n\9\13\n\9local newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols\13\n\9\13\n\9if actualBuffer then\13\n\9\9newBackgrounds, newForegrounds, newSymbols, currentBackgrounds, currentForegrounds, currentSymbols = newFrameBackgrounds, newFrameForegrounds, newFrameSymbols, currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols\13\n\9else\13\n\9\9newBackgrounds, newForegrounds, newSymbols = {table.unpack(newFrameBackgrounds)}, {table.unpack(newFrameForegrounds)}, {table.unpack(newFrameSymbols)}\13\n\9\13\n\9\13\n\9\9if current then\13\n\9\9\9currentBackgrounds, currentForegrounds, currentSymbols = {table.unpack(currentFrameBackgrounds)}, {table.unpack(currentFrameForegrounds)}, {table.unpack(currentFrameSymbols)}\13\n\9\9end\13\n\9end\13\n\9\13\n\9for j = y, y + height - 1 do\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9local newX, newY = getCoordinates(bufferIndex)\13\n\9\9\9if i >= 1 and j >= 1 and i <= bufferWidth and j <= bufferHeight then\13\n\9\9\9\9index = bufferWidth * (j - 1) + i\13\n\9\9\9\9\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(ewX, newY) then\13\n\9\9\9\9\9newBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9newForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9newSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = currentFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = currentFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = currentFrameSymbols[index]\13\n\9\9\9\9\9\9--[[\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = newFrameBackgrounds[index]\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = newFrameForegrounds[index]\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = newFrameSymbols[index]\13\n\9\9\9\9\9\9]]\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9else\13\n\9\9\9\9if newY >= drawLimitY1 and newY <= drawLimitY2 and newX >= drawLimitX1 and newX <= drawLimitX2 and isDrawable(newX, newY) then\13\n\9\9\9\9\9newBackgrounds[newIndex] = 0x0\13\n\9\9\9\9\9newForegrounds[newIndex] = 0x0\13\n\9\9\9\9\9newSymbols[newIndex] = \" \"\13\n\9\9\9\9\9\13\n\9\9\9\9\9if current then\13\n\9\9\9\9\9\9currentBackgrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentForegrounds[bufferIndex] = 0x0\13\n\9\9\9\9\9\9currentSymbols[bufferIndex] = \" \"\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 3\13\n\9\9end\13\n\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9end\13\n\9newFrameBackgrounds, newFrameForegrounds, newFrameSymbols = newBackgrounds, newForegrounds, newSymbols\13\n\9if current then\13\n\9\9currentFrameBackgrounds, currentFrameForegrounds, currentFrameSymbols = currentBackgrounds, currentForegrounds, currentSymbols\13\n\9end\13\nend\13\n\13\nlocal function rasterizeLine(x1, y1, x2, y2, method)\13\n\9local inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = x1, x2, y1, y2, false, mathAbs(x2 - x1), mathAbs(y2 - y1)\13\n\9if inLoopValueDelta < outLoopValueDelta then\13\n\9\9inLoopValueFrom, inLoopValueTo, outLoopValueFrom, outLoopValueTo, isReversed, inLoopValueDelta, outLoopValueDelta = y1, y2, x1, x2, true, outLoopValueDelta, inLoopValueDelta\13\n\9end\13\n\13\n\9if outLoopValueFrom > outLoopValueTo then\13\n\9\9outLoopValueFrom, outLoopValueTo = outLoopValueTo, outLoopValueFrom\13\n\9\9inLoopValueFrom, inLoopValueTo = inLoopValueTo, inLoopValueFrom\13\n\9end\13\n\13\n\9local outLoopValue, outLoopValueCounter, outLoopValueTriggerIncrement = outLoopValueFrom, 1, inLoopValueDelta / outLoopValueDelta\13\n\9local outLoopValueTrigger = outLoopValueTriggerIncrement\13\n\9for inLoopValue = inLoopValueFrom, inLoopValueTo, inLoopValueFrom < inLoopValueTo and 1 or -1 do\13\n\9\9if isReversed then\13\n\9\9\9method(outLoopValue, inLoopValue)\13\n\9\9else\13\n\9\9\9method(inLoopValue, outLoopValue)\13\n\9\9end\13\n\13\n\9\9outLoopValueCounter = outLoopValueCounter + 1\13\n\9\9if outLoopValueCounter > outLoopValueTrigger then\13\n\9\9\9outLoopValue, outLoopValueTrigger = outLoopValue + 1, outLoopValueTrigger + outLoopValueTriggerIncrement\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function rasterizeEllipse(centerX, centerY, radiusX, radiusY, method)\13\n\9local function rasterizeEllipsePoints(XP, YP)\13\n\9\9method(centerX + XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY + YP)\13\n\9\9method(centerX - XP, centerY - YP)\13\n\9\9method(centerX + XP, centerY - YP) \13\n\9end\13\n\13\n\9local x, y, changeX, changeY, ellipseError, twoASquare, twoBSquare = radiusX, 0, radiusY * radiusY * (1 - 2 * radiusX), radiusX * radiusX, 0, 2 * radiusX * radiusX, 2 * radiusY * radiusY\13\n\9local stoppingX, stoppingY = twoBSquare * radiusX, 0\13\n\13\n\9while stoppingX >= stoppingY do\13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9y, stoppingY, ellipseError = y + 1, stoppingY + twoASquare, ellipseError + changeY\13\n\9\9changeY = changeY + twoASquare\13\n\13\n\9\9if (2 * ellipseError + changeX) > 0 then\13\n\9\9\9x, stoppingX, ellipseError = x - 1, stoppingX - twoBSquare, ellipseError + changeX\13\n\9\9\9changeX = changeX + twoBSquare\13\n\9\9end\13\n\9end\13\n\13\n\9x, y, changeX, changeY, ellipseError, stoppingX, stoppingY = 0, radiusY, radiusY * radiusY, radiusX * radiusX * (1 - 2 * radiusY), 0, 0, twoASquare * radiusY\13\n\13\n\9while stoppingX <= stoppingY do \13\n\9\9rasterizeEllipsePoints(x, y)\13\n\9\9\13\n\9\9x, stoppingX, ellipseError = x + 1, stoppingX + twoBSquare, ellipseError + changeX\13\n\9\9changeX = changeX + twoBSquare\13\n\9\9\13\n\9\9if (2 * ellipseError + changeY) > 0 then\13\n\9\9\9y, stoppingY, ellipseError = y - 1, stoppingY - twoASquare, ellipseError + changeY\13\n\9\9\9changeY = changeY + twoASquare\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawLine(x1, y1, x2, y2, background, foreground, symbol)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawEllipse(centerX, centerY, radiusX, radiusY, background, foreground, symbol)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9set(x, y, background, foreground, symbol)\13\n\9end)\13\nend\13\n\13\nlocal function drawText(x, y, textColor, data, transparency)\13\n\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9local charIndex, bufferIndex = 1, bufferWidth * (y - 1) + x\13\n\9\9\13\n\9\9for charIndex = 1, unicodeLen(data) do\13\n\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9if transparency then\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], textColor, transparency)\13\n\9\9\9\9else\13\n\9\9\9\9\9newFrameForegrounds[bufferIndex] = textColor\13\n\9\9\9\9end\13\n\13\n\9\9\9\9newFrameSymbols[bufferIndex] = unicodeSub(data, charIndex, charIndex)\13\n\9\9\9end\13\n\13\n\9\9\9x, bufferIndex = x + 1, bufferIndex + 1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawImage(startX, startY, picture, blendForeground)\13\n\9local bufferIndex, pictureIndex, imageWidth, backgrounds, foregrounds, alphas, symbols = bufferWidth * (startY - 1) + startX, 1, picture[1], picture[3], picture[4], picture[5], picture[6]\13\n\9local bufferIndexStepOnReachOfImageWidth = bufferWidth - imageWidth\13\n\13\n\9for y = startY, startY + picture[2] - 1 do\13\n\9\9if y >= drawLimitY1 and y <= drawLimitY2 then\13\n\9\9\9for x = startX, startX + imageWidth - 1 do\13\n\9\9\9\9if x >= drawLimitX1 and x <= drawLimitX2 and isDrawable(x, y) then\13\n\9\9\9\9\9if alphas[pictureIndex] == 0 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex], newFrameForegrounds[bufferIndex] = backgrounds[pictureIndex], foregrounds[pictureIndex]\13\n\9\9\9\9\9elseif alphas[pictureIndex] > 0 and alphas[pictureIndex] < 1 then\13\n\9\9\9\9\9\9newFrameBackgrounds[bufferIndex] = colorBlend(newFrameBackgrounds[bufferIndex], backgrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9\13\n\9\9\9\9\9\9if blendForeground then\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = colorBlend(newFrameForegrounds[bufferIndex], foregrounds[pictureIndex], alphas[pictureIndex])\13\n\9\9\9\9\9\9else\13\n\9\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9\9end\13\n\9\9\9\9\9elseif alphas[pictureIndex] == 1 and symbols[pictureIndex] ~= \" \" then\13\n\9\9\9\9\9\9newFrameForegrounds[bufferIndex] = foregrounds[pictureIndex]\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9newFrameSymbols[bufferIndex] = symbols[pictureIndex]\13\n\9\9\9\9end\13\n\13\n\9\9\9\9bufferIndex, pictureIndex = bufferIndex + 1, pictureIndex + 1\13\n\9\9\9end\13\n\13\n\9\9\9bufferIndex = bufferIndex + bufferIndexStepOnReachOfImageWidth\13\n\9\9else\13\n\9\9\9bufferIndex, pictureIndex = bufferIndex + bufferWidth, pictureIndex + imageWidth\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawFrame(x, y, width, height, color)\13\n\9local stringUp, stringDown, x2 = \"\" .. string.rep(\"\", width - 2) .. \"\", \"\" .. string.rep(\"\", width - 2) .. \"\", x + width - 1\13\n\9\13\n\9drawText(x, y, color, stringUp); y = y + 1\13\n\9for i = 1, height - 2 do\13\n\9\9drawText(x, y, color, \"\")\13\n\9\9drawText(x2, y, color, \"\")\13\n\9\9y = y + 1\13\n\9end\13\n\9drawText(x, y, color, stringDown)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function semiPixelRawSet(index, color, yPercentTwoEqualsZero)\13\n\9local upperPixel, lowerPixel, bothPixel = \"\", \"\", \" \"\13\n\9local background, foreground, symbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\13\n\9if yPercentTwoEqualsZero then\13\n\9\9if symbol == upperPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, lowerPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, lowerPixel\13\n\9\9end\13\n\9else\13\n\9\9if symbol == lowerPixel then\13\n\9\9\9if color == foreground then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, bothPixel\13\n\9\9\9else\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = color, foreground, symbol\13\n\9\9\9end\13\n\9\9elseif symbol == bothPixel then\13\n\9\9\9if color ~= background then\13\n\9\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, upperPixel\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index] = background, color, upperPixel\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function semiPixelSet(x, y, color)\13\n\9local yFixed = mathCeil(y / 2)\13\n\9if x >= drawLimitX1 and yFixed >= drawLimitY1 and x <= drawLimitX2 and yFixed <= drawLimitY2 and isDrawable(x, yFixed) then\13\n\9\9semiPixelRawSet(bufferWidth * (yFixed - 1) + x, color, y % 2 == 0)\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelRectangle(x, y, width, height, color)\13\n\9local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = bufferWidth * (mathCeil(y / 2) - 1) + x, (bufferWidth - width), width\13\n\9for j = y, y + height - 1 do\13\n\9\9jPercentTwoEqualsZero = j % 2 == 0\13\n\9\9\13\n\9\9for i = x, x + width - 1 do\13\n\9\9\9jFixed = mathCeil(j / 2)\13\n\9\9\9semiPixelRawSet(index, color, jPercentTwoEqualsZero)\13\n\9\9\9index = index + 1\13\n\9\9end\13\n\13\n\9\9if jPercentTwoEqualsZero then\13\n\9\9\9index = index + indexStepForward\13\n\9\9else\13\n\9\9\9index = index - indexStepBackward\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelLine(x1, y1, x2, y2, color)\13\n\9rasterizeLine(x1, y1, x2, y2, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\nlocal function drawSemiPixelEllipse(centerX, centerY, radiusX, radiusY, color)\13\n\9rasterizeEllipse(centerX, centerY, radiusX, radiusY, function(x, y)\13\n\9\9semiPixelSet(x, y, color)\13\n\9end)\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function getPointTimedPosition(firstPoint, secondPoint, time)\13\n\9return {\13\n\9\9x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,\13\n\9\9y = firstPoint.y + (secondPoint.y - firstPoint.y) * time\13\n\9}\13\nend\13\n\13\nlocal function getConnectionPoints(points, time)\13\n\9local connectionPoints = {}\13\n\9for point = 1, #points - 1 do\13\n\9\9tableInsert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))\13\n\9end\13\n\9return connectionPoints\13\nend\13\n\13\nlocal function getMainPointPosition(points, time)\13\n\9if #points > 1 then\13\n\9\9return getMainPointPosition(getConnectionPoints(points, time), time)\13\n\9else\13\n\9\9return points[1]\13\n\9end\13\nend\13\n\13\nlocal function drawSemiPixelCurve(points, color, precision)\13\n\9local linePoints = {}\13\n\9for time = 0, 1, precision or 0.01 do\13\n\9\9tableInsert(linePoints, getMainPointPosition(points, time))\13\n\9end\13\n\9\13\n\9for point = 1, #linePoints - 1 do\13\n\9\9drawSemiPixelLine(mathFloor(linePoints[point].x), mathFloor(linePoints[point].y), mathFloor(linePoints[point + 1].x), mathFloor(linePoints[point + 1].y), color)\13\n\9end\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nlocal function drawChanges(force)\13\n\9local index, indexStepOnEveryLine, changes = bufferWidth * (drawLimitY1 - 1) + drawLimitX1, (bufferWidth - drawLimitX2 + drawLimitX1 - 1), {}\13\n\9local x, equalChars, equalCharsIndex, charX, charIndex, currentForeground\13\n\9local currentFrameBackground, currentFrameForeground, currentFrameSymbol, changesCurrentFrameBackground, changesCurrentFrameBackgroundCurrentFrameForeground\13\n\13\n\9local changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\13\n\9for y = drawLimitY1, drawLimitY2 do\13\n\9\9x = drawLimitX1\13\n\9\9while x <= drawLimitX2 do\9\9\9\13\n\9\9\9-- Determine if some pixel data was changed (or if <force> argument was passed)\13\n\9\9\9if\13\n\9\9\9\9currentFrameBackgrounds[index] ~= newFrameBackgrounds[index] or\13\n\9\9\9\9currentFrameForegrounds[index] ~= newFrameForegrounds[index] or\13\n\9\9\9\9currentFrameSymbols[index] ~= newFrameSymbols[index] or\13\n\9\9\9\9force\13\n\9\9\9then\13\n\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9currentFrameBackground, currentFrameForeground, currentFrameSymbol = newFrameBackgrounds[index], newFrameForegrounds[index], newFrameSymbols[index]\13\n\9\9\9\9currentFrameBackgrounds[index] = currentFrameBackground\13\n\9\9\9\9currentFrameForegrounds[index] = currentFrameForeground\13\n\9\9\9\9currentFrameSymbols[index] = currentFrameSymbol\13\n\13\n\9\9\9\9-- Look for pixels with equal chars from right of current pixel\13\n\9\9\9\9equalChars, equalCharsIndex, charX, charIndex = {currentFrameSymbol}, 2, x + 1, index + 1\13\n\9\9\9\9while charX <= drawLimitX2 do\13\n\9\9\9\9\9-- Pixels becomes equal only if they have same background and (whitespace char or same foreground)\13\n\9\9\9\9\9if\9\13\n\9\9\9\9\9\9currentFrameBackground == newFrameBackgrounds[charIndex] and\13\n\9\9\9\9\9\9(\13\n\9\9\9\9\9\9\9newFrameSymbols[charIndex] == \" \" or\13\n\9\9\9\9\9\9\9currentFrameForeground == newFrameForegrounds[charIndex]\13\n\9\9\9\9\9\9)\13\n\9\9\9\9\9then\13\n\9\9\9\9\9\9-- Make pixel at both frames equal\13\n\9\9\9\9\9 \9currentFrameBackgrounds[charIndex] = newFrameBackgrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameForegrounds[charIndex] = newFrameForegrounds[charIndex]\13\n\9\9\9\9\9 \9currentFrameSymbols[charIndex] = newFrameSymbols[charIndex]\13\n\13\n\9\9\9\9\9 \9equalChars[equalCharsIndex], equalCharsIndex = currentFrameSymbols[charIndex], equalCharsIndex + 1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\13\n\9\9\9\9\9charX, charIndex = charX + 1, charIndex + 1\13\n\9\9\9\9end\13\n\13\n\9\9\9\9-- Group pixels that need to be drawn by background and foreground\13\n\9\9\9\9changes[currentFrameBackground] = changes[currentFrameBackground] or {}\13\n\9\9\9\9changesCurrentFrameBackground = changes[currentFrameBackground]\13\n\9\9\9\9changesCurrentFrameBackground[currentFrameForeground] = changesCurrentFrameBackground[currentFrameForeground] or {index = 1}\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground = changesCurrentFrameBackground[currentFrameForeground]\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForegroundIndex = changesCurrentFrameBackgroundCurrentFrameForeground.index\13\n\9\9\9\9\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = x, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = y, changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9changesCurrentFrameBackgroundCurrentFrameForeground[changesCurrentFrameBackgroundCurrentFrameForegroundIndex], changesCurrentFrameBackgroundCurrentFrameForegroundIndex = tableConcat(equalChars), changesCurrentFrameBackgroundCurrentFrameForegroundIndex + 1\13\n\9\9\9\9\13\n\9\9\9\9x, index, changesCurrentFrameBackgroundCurrentFrameForeground.index = x + equalCharsIndex - 2, index + equalCharsIndex - 2, changesCurrentFrameBackgroundCurrentFrameForegroundIndex\13\n\9\9\9end\13\n\13\n\9\9\9x, index = x + 1, index + 1\13\n\9\9end\13\n\13\n\9\9index = index + indexStepOnEveryLine\13\n\9end\13\n\9\13\n\9-- Draw grouped pixels on screen\13\n\9for background, foregrounds in pairs(changes) do\13\n\9\9GPUProxySetBackground(background)\13\n\13\n\9\9for foreground, pixels in pairs(foregrounds) do\13\n\9\9\9if currentForeground ~= foreground then\13\n\9\9\9\9GPUProxySetForeground(foreground)\13\n\9\9\9\9currentForeground = foreground\13\n\9\9\9end\13\n\13\n\9\9\9for i = 1, #pixels, 3 do\13\n\9\9\9\9GPUProxySet(pixels[i], pixels[i + 1], pixels[i + 2])\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\13\n\9changes = nil\13\nend\13\n\13\n--------------------------------------------------------------------------------\13\n\13\nbindGPU(component.getPrimary(\"gpu\").address)\13\n\13\nreturn {\13\n\9getCoordinates = getCoordinates,\13\n\9getIndex = getIndex,\13\n\9setDrawLimit = setDrawLimit,\13\n\9resetDrawLimit = resetDrawLimit,\13\n\9getDrawLimit = getDrawLimit,\13\n\9flush = flush,\13\n\9setResolution = setResolution,\13\n\9bindScreen = bindScreen,\13\n\9bindGPU = bindGPU,\13\n\9getGPUProxy = getGPUProxy,\13\n\9getResolution = getResolution,\13\n\9getWidth = getWidth,\13\n\9getHeight = getHeight,\13\n\9getCurrentFrameTables = getCurrentFrameTables,\13\n\9getNewFrameTables = getNewFrameTables,\13\n\13\n\9rawSet = rawSet,\13\n\9rawGet = rawGet,\13\n\9get = get,\13\n\9set = set,\13\n\9clear = clear,\13\n\9copy = copy,\13\n\9paste = paste,\13\n\9directCopy = directCopy,\13\n\9copyCurrent = copyCurrent,\13\n\9pasteCurrent = pasteCurrent,\13\n\9rasterizeLine = rasterizeLine,\13\n\9rasterizeEllipse = rasterizeEllipse,\13\n\9semiPixelRawSet = semiPixelRawSet,\13\n\9semiPixelSet = semiPixelSet,\13\n\9drawChanges = drawChanges,\13\n\13\n\9drawRectangle = drawRectangle,\13\n\9drawLine = drawLine,\13\n\9drawEllipse = drawEllipse,\13\n\9drawText = drawText,\13\n\9drawImage = drawImage,\13\n\9drawFrame = drawFrame,\13\n\13\n\9drawSemiPixelRectangle = drawSemiPixelRectangle,\13\n\9drawSemiPixelLine = drawSemiPixelLine,\13\n\9drawSemiPixelEllipse = drawSemiPixelEllipse,\13\n\9drawSemiPixelCurve = drawSemiPixelCurve,\13\n\9\13\n\9setDrawAreas = setDrawAreas,\13\n\9resetDrawAreas = resetDrawAreas,\13\n\9getDrawAreas = getDrawAreas,\13\n\9setNonDrawAreas = setNonDrawAreas,\13\n\9resetNonDrawAreas = resetNonDrawAreas,\13\n\9getNonDrawAreas = getNonDrawAreas,\13\n\9\13\n\9setDrawAreaOffset = setDrawAreaOffset,\13\n\9getDrawAreaOffset = getDrawAreaOffset,\13\n\9resetDrawAreaOffset = resetDrawAreaOffset,\13\n}",["./libs/thirdParty/"] = 0,["./libs/dbgpu_api - Copy.lua"] = "--[[\13\n\9!The api is not complete yet!\13\n\9\13\n\9This is a little api to make the DoubleBuffering libarry by IgorTimofeev acting like a normal OC gpu.\13\n\9\13\n\9With the default settings it is acting (nearly) exacly like a normal OC gpu (so its basicly useless).\13\n\9To get the full effect of the DoubleBuffering you should deactivate directDraw but then you manually need to use the drawChanges function.\13\n\9\13\n\9DoubleBuffering source: <https://github.com/IgorTimofeev/DoubleBuffering>\13\n\9DoubleBuffering Copyright (c) 2018 Igor Timofeev\13\n\9\13\n\9dbgpu_api Copyright (c) 2019 NosPo Studio\13\n\9\13\n    dbgpu_api is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    dbgpu_api is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with dbgpu_api.  If not, see <https://www.gnu.org/licenses/>.\9\13\n]]\13\n\13\nlocal version = \"v0.2d\"\13\n\13\nlocal args = ...\13\nlocal path = args.path or \"\"\13\n\13\nlocal buffer = require(path .. \"/DoubleBuffering\")\13\nlocal gpu = require(\"component\").gpu\13\nlocal unicode = require(\"unicode\")\13\n\13\nlocal ut = require(\"libs/UT\")\13\n\13\nlocal lastBackground = gpu.getBackground()\13\nlocal lastForeground = gpu.getForeground()\13\n\13\nlocal currentVBuffer = gpu.getActiveBuffer()\13\nlocal cpuBuffers = {}\13\n\13\nlocal function flushBuffer(id, w, h)\13\n\9cpuBuffers[id] = {\13\n\9\9drawLimit = {1, 1, w, h},\13\n\9\9current = {{}, {}, {}, w, h},\13\n\9\9new = {{}, {}, {}, w, h},\13\n\9}\13\n\9\13\n\9for y = 1, h do\13\n\9\9for x = 1, w do\13\n\9\9\9table.insert(cpuBuffers[id].current[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].current[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].current[3], \" \")\13\n\9\13\n\9\9\9table.insert(cpuBuffers[id].new[1], 0x010101)\13\n\9\9\9table.insert(cpuBuffers[id].new[2], 0xFEFEFE)\13\n\9\9\9table.insert(cpuBuffers[id].new[3], \" \")\13\n\9\9end\13\n\9end\13\nend\13\nlocal function setBuffer(id)\13\n\9cpuBuffers[currentVBuffer].drawLimit = {buffer.getDrawLimit()}\13\n\9\13\n\9buffer.setCurrentFrameTables(cpuBuffers[id].current[1], cpuBuffers[id].current[2], cpuBuffers[id].current[3], cpuBuffers[id].current[4], cpuBuffers[id].current[5])\13\n\9buffer.setNewFrameTables(cpuBuffers[id].new[1], cpuBuffers[id].new[2], cpuBuffers[id].new[3], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9buffer.setDrawLimit(cpuBuffers[id].drawLimit[1], cpuBuffers[id].drawLimit[2], cpuBuffers[id].drawLimit[3], cpuBuffers[id].drawLimit[4])\13\n\9\13\n\9currentVBuffer = id\13\nend\13\n\13\nlocal function parseArgs(...) --ripped from UT_v0.6\13\n\9for _, a in pairs({...}) do\13\n\9\9if a ~= nil then\13\n\9\9\9return a\13\n\9\9end\13\n\9end\13\nend\13\n\13\nlocal function getSubFunc(s)\13\n\9if #s ~= unicode.len(s) then\13\n\9\9return unicode.sub\13\n\9else\13\n\9\9return string.sub\13\n\9end\13\nend\13\n\13\nlocal dbgpu = {\13\n\9directDraw = parseArgs(args.directDraw, true),\13\n\9forceDraw = parseArgs(args.forceDraw, false),\13\n\9rawCopy = parseArgs(args.rawCopy, false),\13\n\9actualRawCopy = parseArgs(args.actualRawCopy, args.rawCopy),\13\n\9version = version,\13\n\9buffer = buffer,\13\n}\13\n\13\nlocal function draw()\13\n\9if dbgpu.directDraw then\13\n\9\9buffer.drawChanges(dbgpu.forceDraw)\13\n\9end\13\nend\13\n\13\nfunction dbgpu.set(x, y, s, v)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9if v then\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x, y +i -1, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9else\13\n\9\9for i = 1, unicode.len(s) do\13\n\9\9\9buffer.set(x +i -1, y, lastBackground, lastForeground, sub(s, i, i))\13\n\9\9end\13\n\9end\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.fill(x, y, sx, sy, s)\13\n\9s = tostring(s)\13\n\9local sub = getSubFunc(s)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9sx = math.floor(sx)\13\n\9sy = math.floor(sy)\13\n\9s = sub(s, 0, 1)\13\n\9buffer.drawRectangle(x, y, sx, sy, lastBackground, lastForeground, s)\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.copy(x, y, sx, sy, tx, ty)\13\n\9x = math.floor(x)\13\n\9y = math.floor(y)\13\n\9tx = math.floor(tx)\13\n\9ty = math.floor(ty)\13\n\9\13\n\9if sx * sy > 3200 then\13\n\9\9buffer.directCopy(x, y, sx, sy, tx +x, ty +y, dbgpu.rawCopy)\13\n\9else\13\n\9\9local data, rawData = buffer.copy(x, y, sx, sy, dbgpu.rawCopy)\13\n\9\9buffer.paste(tx +x, ty +y, data, rawData)\13\n\9end\13\n\9\13\n\9if dbgpu.rawCopy and dbgpu.actualRawCopy then\9\9\13\n\9\9gpu.copy(x, y, sx, sy, tx, ty)\13\n\9end\9\13\n\9draw()\13\nend\13\n\13\nfunction dbgpu.getBackground()\13\n\9return lastBackground\13\nend\13\nfunction dbgpu.getForeground()\13\n\9return lastForeground\13\nend\13\n\13\nfunction dbgpu.setBackground(c)\13\n\9lastBackground = c\13\n\9--return gpu.setBackground(c)\13\nend\13\nfunction dbgpu.setForeground(c)\13\n\9lastForeground = c\13\n\9--return gpu.setForeground(c)\13\nend\13\n\13\nfunction dbgpu.setResolution(x, y)\13\n\9buffer.setResolution(x, y)\13\nend\13\nfunction dbgpu.getResolution()\13\n\9return buffer.getResolution()\13\nend\13\n\13\nfunction dbgpu.drawChanges(f)\13\n\9buffer.drawChanges(f)\13\nend\13\n\13\nfunction dbgpu.drawImage(x, y, image)\13\n\9buffer.drawImage(x, y, image)\13\nend\13\n\13\nfunction dbgpu.getActiveBuffer()\13\n\9return currentVBuffer\13\nend\13\nfunction dbgpu.setActiveBuffer(id, force)\13\n\9if id == currentVBuffer or force then\13\n\9\9return false, \"Buffer is set already\"\13\n\9else\13\n\9\9local suc = gpu.setActiveBuffer(id)\13\n\9\9\13\n\9\9if suc ~= nil then\13\n\9\9\9\13\n\9\9\9setBuffer(id)\13\n\9\9\9\13\n\9\9\9do\13\n\9\9\9\9local b = buffer.getNewFrameTables()\13\n\9\9\9\9local b2 = cpuBuffers[id].new[1]\13\n\9\9\9\9\13\n\9\9\9\9--print(b, b2, b == b2)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9--print(\"T\", id)\13\n\9\9\9--print(cpuBuffers[0], cpuBuffers[1])\13\n\9\9\9--print(#cpuBuffers[0].new[1], #cpuBuffers[1].new[1], cpuBuffers[id].new[4], cpuBuffers[id].new[5])\13\n\9\9end\13\n\9\9return id\13\n\9end\13\nend\13\n--debug/dbgpuVBufferTest.lua > logs/test.log\13\nfunction dbgpu.allocateBuffer(w, h)\13\n\9local id = gpu.allocateBuffer(w, h)\13\n\9if type(id) == \"number\" then\13\n\9\9flushBuffer(id, w, h)\13\n\9end\13\n\9return id\13\nend\13\nfunction dbgpu.freeBuffer(id)\13\n\9cpuBuffers[id] = nil\13\n\9return gpu.freeBuffer(id)\13\nend\13\nfunction dbgpu.bitblt(...)\13\n\9return gpu.bitblt(...)\13\nend\13\nfunction dbgpu.freeAllBuffers()\13\n\9currentVBuffer = 0\13\n\9return gpu.freeAllBuffers()\13\nend\13\n\13\n--===== init =====--\13\nlocal resX, resY = gpu.getResolution()\13\nflushBuffer(0, resX, resY)\13\nsetBuffer(0)\13\n\13\n\13\nreturn dbgpu",["./libs/ocgf.lua"] = "--[[\13\n    ocgf Copyright (C) 2019 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[OpenComputersGamingFramework:\13\n\9ToDo:\13\n\9\13\n\9WIP:\13\n]]\13\n\13\nlocal OCGF = {version = \"v1.3\"} \13\nOCGF.__index = OCGF\13\n\13\n--===== local vars =====--\13\nlocal ut = require(\"libs/UT\")\13\nlocal serialization = require(\"serialization\")\13\n\13\n--===== local aliaces =====--\13\nlocal tableInsert = table.insert\13\nlocal mathMin = math.min\13\nlocal mathMax = math.max\13\nlocal mathFloor = math.floor\13\nlocal mathAbs = math.abs\13\nlocal pairs = pairs\13\nlocal ipairs = ipairs\13\nlocal tostring = tostring\13\nlocal tonumber = tonumber\13\n\13\n--===== Functions =====--\13\nlocal function posSizeCheck(this)\13\n\9if this.sizeX == nil or this.sizeY == nil then\13\n\9\9return false, \"No sizeX or sizeY given\"\13\n\9end\13\n\9if this.posX == nil or this.posY == nil then\13\n\9\9return false, \"No posX or posY given\"\13\n\9end\13\n\9return this\13\nend\13\n\13\nlocal function posEqualizer(args, x, y)\13\n\9local posX = ut.parseArgs(args.x, args.posX, 0) +x\13\n\9local posY = ut.parseArgs(args.y, args.posY, 0) +y\13\n\9return posX, posY\13\nend\13\n\13\nlocal function calculateStiffness(speed, stiffness)\13\n\9if speed > 0 then\13\n\9\9return mathMax(speed - stiffness, 0)\13\n\9else\13\n\9\9return mathMin(speed + stiffness, 0)\13\n\9end\13\nend\13\n\13\nlocal function calculateCollision(this, oc, c) --ownCollider, (other) collider\13\n\9local sides = {false, false, false, false} -- -x, x, -y, y\13\n\9local disMap = {0, 0, 0, 0}\13\n\9\13\n\9disMap[1] = (c.posX + c.sizeX) - oc.posX\13\n\9disMap[2] = (oc.posX + oc.sizeX) - c.posX\13\n\9disMap[3] = (c.posY + c.sizeY) - oc.posY\13\n\9disMap[4] = (oc.posY + oc.sizeY) - c.posY\13\n\9\13\n\9local nearest, dis = 0, 2^32\13\n\9for i, d in ipairs(disMap) do\13\n\9\9if d <= dis then --change <= to == if you want x collision \"priorized\".\13\n\9\9\9dis = d\13\n\9\9\9nearest = i\13\n\9\9end\13\n\9end\13\n\9sides[nearest] = true\13\n\9\13\n\9if sides[1] then\13\n\9\9this.speedX = mathMax(0, this.speedX)\13\n\9\9this.gameObject:move(disMap[nearest], 0, false)\13\n\9elseif sides[2] then\13\n\9\9this.speedX = mathMin(0, this.speedX)\13\n\9\9this.gameObject:move(-disMap[nearest], 0, false)\13\n\9elseif sides[3] then\13\n\9\9this.speedY = mathMax(0, this.speedY)\13\n\9\9this.gameObject:move(0, disMap[nearest], false)\13\n\9elseif sides[4] then\13\n\9\9this.speedY = mathMin(0, this.speedY)\13\n\9\9this.gameObject:move(0, -disMap[nearest], false)\13\n\9end\13\n\9\13\n\9return sides\13\n\9\13\n\9--print(serialization.serialize({mathFloor(disMap[1]), mathFloor(disMap[2]), mathFloor(disMap[3]), mathFloor(disMap[4])}))\13\n\9--print(serialization.serialize(sides))\13\nend\13\n\13\nlocal function setLastPos(this, slp, x, y)\13\n\9x = x or this.posX\13\n\9y = y or this.posY\13\n\9slp = ut.parseArgs(slp, true)\13\n\9if slp then\13\n\9\9this.lastPosX, this.lastPosY = this.posX, this.posY\13\n\9end\13\nend\13\n\13\n--===== MainClass =====--\13\nfunction OCGF.initiate(args)\13\n\9local this = setmetatable({}, OCGF)\13\n\9args = args or {}\13\n\9\13\n\9this.component = require(\"component\")\13\n\9this.gpu = args.gpu or this.component.gpu\13\n\9this.db = ut.parseArgs(args.db, args.doubleBuffering, args.DoubleBuffering)\13\n\9this.ut = require(\"libs/UT\")\13\n\9this.oclrl = args.oclrl or require(\13\n\9\9args.ocglPath or \"libs/oclrl\"\13\n\9).initiate(\13\n\9\9this.gpu\13\n\9)\13\n\9this.ocal = args.ocal or require(\13\n\9\9args.ocglPath or \"libs/ocal\"\13\n\9).initiate(\13\n\9\9this.ocal\13\n\9)\13\n\9\13\n\9this.resX, this.resY = this.gpu.getResolution()\13\n\9\13\n\9return this\13\nend\13\n\13\n\13\n--===== GameObject (parent of other game objects) =====--\13\nOCGF.GameObject = {widgetType = \"GameObject\"}\13\nOCGF.GameObject.__index = OCGF.GameObject\13\n\13\nfunction OCGF.GameObject.new(ocgf, args)\13\n\9local this = setmetatable({}, OCGF.GameObject)\13\n\9args = args or {}\13\n\9this.ocgf = ocgf\13\n\9\13\n\9this.drawTrigger = ut.parseArgs(args.dt, args.drawTrigger, false)\13\n\9this.drawCollider = ut.parseArgs(args.dc, args.drawCollider, false)\13\n\9this.log = args.logFunc or args.logFunction or function() end --WIP\13\n\9\13\n\9this.posX = ut.parseArgs(args.x, args.posX, 0)\13\n\9this.posY = ut.parseArgs(args.y, args.posY, 0)\13\n\9this.lastPosX = this.posX\13\n\9this.lastPosY = this.posY\13\n\9\13\n\9this.parent = args.parent\13\n\9\13\n\9this.attachedTo = nil --Will be the attached GameObject after using GameObject.attach().\13\n\9\13\n\9this.boxTrigger = {}\13\n\9this.boxCollider = {}\13\n\9this.rigidBodys = {}\13\n\9this.sprites = {}\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCGF.GameObject.setLastPos(this, x, y)\13\n\9setLastPos(this, nil, x + (o.posX - this.posX), y + (o.posY - this.posY))\13\n\9for i, o in ipairs(this.boxTrigger) do\13\n\9\9setLastPos(o, nil, x + (o.posX - this.posX), y + (o.posY - this.posY))\13\n\9end\13\n\9for i, o in ipairs(this.boxCollider) do\13\n\9\9setLastPos(o, nil, x + (o.posX - this.posX), y + (o.posY - this.posY))\13\n\9end\13\n\9for i, o in ipairs(this.sprites) do\13\n\9\9setLastPos(o, nil, x + (o.posX - this.posX), y + (o.posY - this.posY))\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.stop(this)\13\n\9for _, rb in ipairs(this.rigidBodys) do\13\n\9\9rb.speedX = 0\13\n\9\9rb.speedY = 0\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.setSpeed(this, x, y)\13\n\9for _, rb in ipairs(this.rigidBodys) do\13\n\9\9rb.speedX = x\13\n\9\9rb.speedY = y\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.getSpeed(this)\13\n\9for _, rb in ipairs(this.rigidBodys) do\13\n\9\9return rb.speedX, rb.speedY\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.addForce(this, x, y, maxSpeed)\13\n\9maxSpeed = maxSpeed or 2^32\13\n\9for _, rb in ipairs(this.rigidBodys) do\13\n\9\9if x ~= 0 then\13\n\9\9\9if rb.speedX + x >= maxSpeed then\13\n\9\9\9\9rb.speedX = maxSpeed\13\n\9\9\9elseif rb.speedX + x <= -maxSpeed then\13\n\9\9\9\9rb.speedX = -maxSpeed\13\n\9\9\9else\13\n\9\9\9\9rb.speedX = rb.speedX +x\13\n\9\9\9end\13\n\9\9end\13\n\9\9if y ~= 0 then\13\n\9\9\9if rb.speedY + y >= maxSpeed then\13\n\9\9\9\9rb.speedY = maxSpeed\13\n\9\9\9elseif rb.speedY + y <= -maxSpeed then\13\n\9\9\9\9rb.speedY = -maxSpeed\13\n\9\9\9else\13\n\9\9\9\9rb.speedY = rb.speedY +y\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.addSprite(this, args)\13\n\9args.x, args.y = posEqualizer(args, this.posX, this.posY)\13\n\9local obj = OCGF.Sprite.new(this, args)\13\n\9tableInsert(this.sprites, obj)\13\n\9return obj\13\nend\13\n\13\nfunction OCGF.GameObject.addBoxCollider(this, args)\13\n\9args.x, args.y = posEqualizer(args, this.posX, this.posY)\13\n\9args.isCollider = true\13\n\9local obj = OCGF.BoxTrigger.new(this, args)\13\n\9tableInsert(this.boxCollider, obj)\13\n\9return obj\13\nend\13\n\13\nfunction OCGF.GameObject.addBoxTrigger(this, args)\13\n\9args.x, args.y = posEqualizer(args, this.posX, this.posY)\13\n\9local obj = OCGF.BoxTrigger.new(this, args)\13\n\9tableInsert(this.boxTrigger, obj)\13\n\9return obj\13\nend\13\n\13\nfunction OCGF.GameObject.addRigidBody(this, args)\13\n\9local obj = OCGF.RigidBody.new(this, args)\13\n\9tableInsert(this.rigidBodys, obj)\13\n\9return obj\13\nend\13\n\13\nfunction OCGF.GameObject.onCollision(this, gameObject, selfCall)\13\n\9--this.log(\"GO: Collision: \" .. tostring(selfCall))\13\nend\13\n\13\nfunction OCGF.GameObject.onTrigger(this, gameObject, selfCall)\13\n\9--this.log(\"GO: Trigger: \" .. tostring(selfCall))\13\nend\13\n\13\nfunction OCGF.GameObject.getPos(this)\13\n\9return this.posX, this.posY\13\nend\13\n\13\nfunction OCGF.GameObject.getLastPos(this)\13\n\9return this.lastPosX, this.lastPosY\13\nend\13\n\13\nfunction OCGF.GameObject.getSprites(this)\13\n\9local sprites = {}\13\n\9for _, s in ipairs(this.sprites) do\13\n\9\9tableInsert(sprites, s)\13\n\9end\13\n\9return sprites\13\nend\13\n\13\nfunction OCGF.GameObject.getTrigger(this)\13\n\9local trigger = {}\13\n\9for _, bt in ipairs(this.boxTrigger) do\13\n\9\9tableInsert(trigger, bt:getTrigger()[1])\13\n\9end\13\n\9return trigger\13\nend\13\n\13\nfunction OCGF.GameObject.getCollider(this)\13\n\9local trigger = {}\13\n\9for _, bc in ipairs(this.boxCollider) do\13\n\9\9tableInsert(trigger, bc:getTrigger()[1])\13\n\9end\13\n\9return trigger\13\nend\13\n\13\nfunction OCGF.GameObject.getRigidBodys(this)\13\n\9local rbs = {}\13\n\9for _, s in ipairs(this.rigidBodys) do\13\n\9\9tableInsert(rbs, s)\13\n\9end\13\n\9return rbs\13\nend\13\n\13\nfunction OCGF.GameObject.update(this, gameObjects) --gameObject can be collider table\9\13\n\9if this.attachedTo ~= nil and #this:getRigidBodys() == 0 then\13\n\9\9local x, y = this.attachedTo:getPos()\13\n\9\9local lx, ly = this.attachedTo:getLastPos()\13\n\9\9this:move(x - lx, y - ly)\13\n\9end\13\n\9\13\n\9for i, c in ipairs(gameObjects) do\13\n\9\9for i, bt in ipairs(this.boxTrigger) do\13\n\9\9\9if bt.checkTrigger then\13\n\9\9\9\9bt:update(c:getTrigger())\13\n\9\9\9end\13\n\9\9\9if bt.checkCollider then\13\n\9\9\9\9bt:update(c:getCollider())\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\nfunction OCGF.GameObject.updatePhx(this, gameObjects, dt) --gameObject can be collider table\13\n\9local colliderTable = {}\13\n\9dt = dt or 1\13\n\13\n\9for _, go in ipairs(gameObjects) do\13\n\9\9for _, c in ipairs(go:getCollider()) do\13\n\9\9\9tableInsert(colliderTable, c)\13\n\9\9end\13\n\9end\13\n\13\n\9for _, rb in ipairs(this.rigidBodys) do\13\n\9\9rb:update(colliderTable, dt)\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.move(this, x, y, SLP)\13\n\9for i, o in ipairs(this.boxTrigger) do\13\n\9\9o:move(x, y, SLP)\13\n\9end\13\n\9for i, o in ipairs(this.boxCollider) do\13\n\9\9o:move(x, y, SLP)\13\n\9end\13\n\9for i, o in ipairs(this.sprites) do\13\n\9\9o:move(x, y, SLP)\13\n\9end\13\n\9setLastPos(this, SLP)\13\n\9this.posX = this.posX +x\13\n\9this.posY = this.posY +y\13\nend\13\n\13\nfunction OCGF.GameObject.moveTo(this, x, y, SLP) --WIP: bug: ...\13\n\9for i, bt in ipairs(this.boxTrigger) do\13\n\9\9bt:moveTo(x + (bt.posX - this.posX), y + (bt.posY - this.posY), SLP)\13\n\9end\13\n\9for i, bc in ipairs(this.boxCollider) do\13\n\9\9bc:moveTo(x + (bc.posX - this.posX), y + (bc.posY - this.posY), SLP)\13\n\9end\13\n\9for i, o in ipairs(this.sprites) do\13\n\9\9o:moveTo(x + (o.posX - this.posX), y + (o.posY - this.posY), SLP)\13\n\9end\13\n\9setLastPos(this, SLP)\13\n\9this.posX = x\13\n\9this.posY = y\13\nend\13\n\13\nfunction OCGF.GameObject.draw(this, offsetX, offsetY, area, dt, background, color)\13\n\9offsetX = offsetX or 0\13\n\9offsetY = offsetY or 0\13\n\9for i, o in ipairs(this.sprites) do\13\n\9\9o:draw(dt, background, offsetX, offsetY, area)\13\n\9end\13\n\9if this.drawTrigger then\13\n\9\9for i, bt in ipairs(this.boxTrigger) do\13\n\9\9\9bt:draw(color, offsetX, offsetY, area)\13\n\9\9end\13\n\9end\13\n\9if this.drawCollider then\13\n\9\9for i, bc in ipairs(this.boxCollider) do\13\n\9\9\9bc:draw(color, offsetX, offsetY, area)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.clear(this, offsetX, offsetY, color, actual)\13\n\9offsetX = offsetX or 0\13\n\9offsetY = offsetY or 0\13\n\9if this.drawTrigger then\13\n\9\9for i, bt in ipairs(this.boxTrigger) do\13\n\9\9\9bt:clear(color, actual, offsetX, offsetY)\13\n\9\9end\13\n\9end\13\n\9if this.drawCollider then\13\n\9\9for i, bc in ipairs(this.boxCollider) do\13\n\9\9\9bc:clear(color, actual, offsetX, offsetY)\13\n\9\9end\13\n\9end\13\n\9for i, o in ipairs(this.sprites) do\13\n\9\9o:clear(color, actual, offsetX, offsetY)\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.startAnimation(this, speed, frame)\13\n\9for _, s in pairs(this.sprites) do\13\n\9\9s:start(speed, frame)\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.stopAnimation(this, frame, playTilEnd)\13\n\9for _, s in pairs(this.sprites) do\13\n\9\9s:stop(frame, playTilEnd)\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.pauseAnimation(this)\13\n\9for _, s in pairs(this.sprites) do\13\n\9\9s:pause()\13\n\9end\13\n\13\nend\13\nfunction OCGF.GameObject.playAnimation(this, speed, frame)\13\n\9for _, s in pairs(this.sprites) do\13\n\9\9s:play(speed, frame)\13\n\9end\13\nend\13\n\13\nfunction OCGF.GameObject.attach(this, gameObject)\13\n\9this.attachedTo = gameObject\13\nend\13\n\13\nfunction OCGF.GameObject.detach(this)\13\n\9if this.attachedTo == nil then return false, \"No GameObject attached to\" end\13\n\9for _, rb in pairs(this.rigidBodys) do\13\n\9\9rb:detach()\13\n\9end\13\n\9this.attachedTo = nil\13\nend\13\n\13\n--===== Sprite =====--\13\nOCGF.Sprite = {widgetType = \"Sprite\"}\13\nOCGF.Sprite.__index = OCGF.Sprite\13\n\13\nfunction OCGF.Sprite.new(gameObject, args)\13\n\9local this = setmetatable({}, OCGF.Sprite)\13\n\9args = args or {}\13\n\9this.gameObject = gameObject\13\n\9\13\n\9this.posX = args.x or args.posX or 0\13\n\9this.posY = args.y or args.posY or 0 \13\n\9this.texture = ut.parseArgs(args.t, args.texture, this.gameObject.ocgf.oclrl.generateTexture(0, 0, \"\"))\13\n\9this.background = args.background or 0x000000\13\n\9\13\n\9if this.texture.format == \"OCGLA\" or this.texture.format == \"pan\" then\13\n\9\9this.animation = gameObject.ocgf.ocal.Animation.new(gameObject.ocgf.ocal, this.texture, {clear = false})\13\n\9elseif this.texture.format == \"pic\" then\13\n\9\9if this.gameObject.ocgf.db ~= nil then\13\n\9\9\9this.useDB = true\13\n\9\9else\13\n\9\9\9this.texture = this.gameObject.ocgf.oclrl.generateTexture({\13\n\9\9\9\9{\"b\", 0xFF69B4},\13\n\9\9\9\9{0, 0, this.texture[1], this.texture[2], \" \"},\9\13\n\9\9\9})\13\n\9\9end\13\n\9end\13\n\9\13\n\9this.lastPosX = this.posX\13\n\9this.lastPosY = this.posY\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCGF.Sprite.move(this, x, y, slp)\13\n\9setLastPos(this, slp)\13\n\9this.posX = this.posX +x\13\n\9this.posY = this.posY +y\13\n\9return this.posX, this.posY\13\nend\13\n\13\nfunction OCGF.Sprite.moveTo(this, x, y, slp)\9\13\n\9setLastPos(this, slp)\13\n\9this.posX, this.posY = x, y\13\nend\13\n\13\nfunction OCGF.Sprite.draw(this, dt, background, offsetX, offsetY, area)\9\13\n\9background = background or this.background\13\n\9if this.animation ~= nil then\13\n\9\9this.animation.background = background\13\n\9\9this.animation:draw(this.posX + offsetX, this.posY + offsetY, dt, nil, background, area)\13\n\9elseif this.useDB then\13\n\9\9this.gameObject.ocgf.db.setDrawLimit(area[1], area[3], area[2], area[4])\13\n\13\n\9\9this.gameObject.ocgf.db.drawImage(mathFloor(this.posX + offsetX +.5), mathFloor(this.posY + offsetY +.5), this.texture)\13\n\9\9\13\n\9\9this.gameObject.ocgf.db.resetDrawLimit()\13\n\9else\13\n\9\9this.gameObject.ocgf.oclrl:draw(this.posX + offsetX, this.posY + offsetY, this.texture, nil, area)\13\n\9end\13\nend\13\n\13\nfunction OCGF.Sprite.clear(this, color, actual, offsetX, offsetY)\13\n\9if actual then\13\n\9\9if this.animation ~= nil then\13\n\9\9\9this.animation:clearBlack(this.posX + offsetX, this.posY + offsetY, nil, color)\13\n\9\9else\13\n\9\9\9this.gameObject.ocgf.oclrl:clearBlack(this.posX + offsetX, this.posY + offsetY, this.texture, color)\13\n\9\9end\13\n\9else\13\n\9\9if this.animation ~= nil then\13\n\9\9\9this.animation:clearBlack(this.lastPosX + offsetX, this.lastPosY + offsetY, nil, color)\13\n\9\9else\13\n\9\9\9this.gameObject.ocgf.oclrl:clearBlack(this.lastPosX + offsetX, this.lastPosY + offsetY, this.texture, color)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCGF.Sprite.start(this, speed, frame)\13\n\9if this.animation ~= nil then\13\n\9\9this.animation:start(speed, frame)\13\n\9end\13\nend\13\n\13\nfunction OCGF.Sprite.stop(this, frame, playTilEnd)\13\n\9if this.animation ~= nil then\13\n\9\9this.animation:stop(frame, playTilEnd)\13\n\9end\13\nend\13\n\13\nfunction OCGF.Sprite.pause(this)\13\n\9if this.animation ~= nil then\13\n\9\9this.animation:pause()\13\n\9end\13\nend\13\n\13\nfunction OCGF.Sprite.play(this, speed, frame)\13\n\9if this.animation ~= nil then\13\n\9\9this.animation:play(speed)\13\n\9end\13\nend\13\n\13\nfunction OCGF.Sprite.changeTexture(this, newTexture)\13\n\9this.texture = newTexture\13\n\9if this.texture.format == \"OCGLA\" then\13\n\9\9if this.animation ~= nil then\13\n\9\9\9this.animation.animation = this.texture\13\n\9\9else\13\n\9\9\9this.animation = this.gameObject.ocgf.ocal.Animation.new(this.gameObject.ocgf.ocal, this.texture)\13\n\9\9end\13\n\9else\13\n\9\9this.animation = nil\13\n\9end\13\nend\13\n\13\n--===== RigidBody =====--\13\nOCGF.RigidBody = {widgetType = \"RigidBody\"}\13\nOCGF.RigidBody.__index = OCGF.RigidBody\13\n\13\nfunction OCGF.RigidBody.new(gameObject, args)\13\n\9local this = setmetatable({}, OCGF.RigidBody)\13\n\9args = args or {}\13\n\9this.gameObject = gameObject\13\n\9\13\n\9this.calculateHalfPixel = ut.parseArgs(args.hp, args.halfPixel, args.calculateHalfPixel, true) -- if true then is speedY == speedY /2\13\n\9this.mass = ut.parseArgs(args.mass, 0)\13\n\9this.hardness = ut.parseArgs(args.hardness, 1)\13\n\9this.gravitationFactor = ut.parseArgs(args.g, args.gravity, args.gravitation, args.gravitationFactor, 1)\13\n\9this.stiffness = ut.parseArgs(args.stiffness, 0) -- 1 == 1 speed loss per update, -1 == unmovable.\13\n\9this.speedTakeover = ut.parseArgs(args.speedTakeover, 1) -- 0 == 100% speed loss per update, .1 == 90% speed loss pr update, 1 == 0% speed loss per update.\13\n\9this.stickiness = ut.parseArgs(args.stickiness, 1) --1 == enouth to stick stiff, 0 == no stickiness.\13\n\9this.speedLoss = ut.parseArgs(args.sl, args.speedLoss, 0) --Slightly dependent from the FPS so only recomended to use on graphical effects.\13\n\9\13\n\9this.speedX = 0\13\n\9this.speedY = 0\13\n\9\13\n\9return this\13\nend\13\n\13\n--function OCGF.RigidBody.update(this, gameObjects, pingTrigger, pingGameObject, callOwnFunction, slp) --ToDo: add realistic physics.\13\n\13\nfunction OCGF.RigidBody.update(this, collider, dt, slp) --ToDo: add realistic physics.\13\n\9local g = this.gravitationFactor\13\n\9if this.gameObject.attachedTo ~= nil then\13\n\9\9g = g * (1 - this.stickiness)\13\n\9end\13\n\9this.speedX = calculateStiffness(this.speedX, this.stiffness * dt)\13\n\9this.speedY = this.speedY + (g * dt)\13\n\9this.speedY = calculateStiffness(this.speedY, this.stiffness * dt)\13\n\9\13\n\9this.speedX = calculateStiffness(this.speedX, mathAbs(this.speedX * this.speedLoss * dt))\13\n\9this.speedY = calculateStiffness(this.speedY, mathAbs(this.speedY * this.speedLoss * dt))\13\n\9\13\n\9if this.gameObject.attachedTo ~= nil then\13\n\9\9local x, y = this.gameObject.attachedTo:getPos()\13\n\9\9local lx, ly = this.gameObject.attachedTo:getLastPos()\13\n\9\9\13\n\9\9this.gameObject:move(\13\n\9\9\9calculateStiffness((x - lx), this.stiffness * (1 - this.stickiness) * dt) * this.speedTakeover,\13\n\9\9\9calculateStiffness((y - ly), this.stiffness * (1 - this.stickiness) * dt) * this.speedTakeover\13\n\9\9)\13\n\9end\13\n\9\13\n\9local speedX, speedY = this.speedX, this.speedY\13\n\9if this.calculateHalfPixel then\13\n\9\9speedY = speedY /2\13\n\9end\13\n\9\13\n\9this.gameObject:move(speedX *dt, speedY *dt, slp)\13\n\13\n\9for _, c in ipairs(this.gameObject:getCollider()) do\13\n\9\9for _, collision in ipairs(c:update(collider)) do\13\n\9\9\9calculateCollision(this, c, collision)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCGF.RigidBody.detach(this)\13\n\9this.speedX = this.speedX + this.gameObject.attachedTo:getRigidBodys()[1].speedX\13\n\9this.speedY = this.speedY + this.gameObject.attachedTo:getRigidBodys()[1].speedY\13\nend\13\n\13\n--===== BoxTrigger =====--\13\nOCGF.BoxTrigger = {widgetType = \"BoxTrigger\"}\13\nOCGF.BoxTrigger.__index = OCGF.BoxTrigger\13\n\13\nfunction OCGF.BoxTrigger.new(gameObject, args)\13\n\9local this = setmetatable({}, OCGF.BoxTrigger)\13\n\9args = args or {}\13\n\9this.gameObject = gameObject\13\n\9\13\n\9this.name = ut.parseArgs(args.n, args.name, nil)\13\n\9\13\n\9this.posX = args.x or args.posX or 0\13\n\9this.posY = args.y or args.posY or 0 \13\n\9this.sizeX = args.sx or args.sizeX or 1\13\n\9this.sizeY = args.sy or args.sizeY or 1\13\n\9this.listedFunction = ut.parseArgs(args.lf, args.listedFunction, function() end)\13\n\9this.pingTrigger = ut.parseArgs(args.ping, args.pingTrigger, false)\13\n\9this.pingGameObject = ut.parseArgs(args.pingGameObject, false)\13\n\9this.callOwnFunction = ut.parseArgs(args.callFunction, args.callOwnFunction, true)\13\n\9this.callOwnGameObject = ut.parseArgs(args.callOwn, true)\13\n\9this.isCollider = ut.parseArgs(args.isCollider, false)\13\n\9this.floatCalculation = ut.parseArgs(args.fc, args.floatCalculation, false)\13\n\9this.checkTrigger = ut.parseArgs(args.checkTrigger, true)\13\n\9this.checkCollider = ut.parseArgs(args.checkCollider, true)\13\n\9\13\n\9this.lastPosX = this.posX\13\n\9this.lastPosY = this.posY\13\n\9\13\n\9return posSizeCheck(this)\13\nend\13\n\13\nfunction OCGF.BoxTrigger.update(this, collider, pingTrigger, pingGameObject, callOwnFunction, callOwnGameObject)\9\13\n\9\13\n\9--this.gameObject.log(this.listedFunction, this.callOwnFunction, this.isCollider, this.hass == \"!!\")\13\n\9\13\n\9pingTrigger = ut.parseArgs(pingTrigger, this.pingTrigger)\13\n\9pingGameObject = ut.parseArgs(pingGameObject, this.pingGameObject)\13\n\9callOwnFunction = ut.parseArgs(callOwnFunction, this.callOwnFunction)\13\n\9callOwnGameObject = ut.parseArgs(callOwnGameObject, this.callOwnGameObject)\13\n\9\13\n\9local collisions = {}\13\n\9local gameObjects = {}\13\n\9local sizeX, sizeY = this.sizeX, this.sizeY\13\n\9\13\n\9for i, c in ipairs(collider) do\13\n\9\9local x, y, x2, y2 = this.posX, this.posY, c.posX, c.posY\13\n\9\9\13\n\9\9if not this.floatCalculation then\13\n\9\9\9local f = mathFloor\13\n\9\9\9x, y, x2, y2 = f(x +.5), f(y +.5), f(x2 +.5), f(y2 +.5)\13\n\9\9end\13\n\9\9\13\n\9\9if c ~= this and \13\n\9\9\9x + sizeX > x2 and x < x2 + c.sizeX and\13\n\9\9\9y + sizeY > y2 and y < y2 + c.sizeY\13\n\9\9then\13\n\9\9\9tableInsert(collisions, c)\13\n\9\9\9tableInsert(gameObjects, c.gameObject)\13\n\9\9\9if pingTrigger then\13\n\9\9\9\9--c.listedFunction(this.gameObject, false, this.gameObject.parent) --other trigger\13\n\9\9\9\9c:listedFunction(this, false) --other trigger\13\n\9\9\9end\13\n\9\9\9if callOwnFunction then\13\n\9\9\9\9--this.gameObject.log(this.listedFunction, this.callOwnFunction, this.isCollider, this.hass == \"!!\", \"CALL\")\13\n\9\9\9\9--this.listedFunction(c.gameObject, true, this.gameObject.parent) --this trigger\13\n\9\9\9\9this:listedFunction(c, true) --this trigger\13\n\9\9\9end\13\n\9\9\9if pingGameObject then\13\n\9\9\9\9if this.isCollider then\13\n\9\9\9\9\9c.gameObject:onCollision(this.gameObject, false, this.gameObject.parent)\13\n\9\9\9\9else\13\n\9\9\9\9\9c.gameObject:onTrigger(this.gameObject, false, this.gameObject.parent)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9if callOwnGameObject then\13\n\9\9\9\9if this.isCollider then\13\n\9\9\9\9\9this.gameObject:onCollision(c.gameObject, true, this.gameObject.parent)\13\n\9\9\9\9else\13\n\9\9\9\9\9this.gameObject:onTrigger(c.gameObject, true, this.gameObject.parent)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9\13\n\9return collisions, gameObjects\13\nend\13\n\13\nfunction OCGF.BoxTrigger.move(this, x, y, slp)\13\n\9setLastPos(this, slp)\13\n\9this.posX = this.posX +x\13\n\9this.posY = this.posY +y\13\n\9\13\n\9return this.posX, this.posY\13\nend\13\n\13\nfunction OCGF.BoxTrigger.moveTo(this, x, y, slp)\9\13\n\9setLastPos(this, slp)\13\n\9this.posX, this.posY = x, y\13\nend\13\n\13\nfunction OCGF.BoxTrigger.getTrigger(this)\13\n\9return {this}\13\nend\13\n\13\nfunction OCGF.BoxTrigger.draw(this, color, offsetX, offsetY, area)\13\n\9local gpu = this.gameObject.ocgf.gpu\13\n\9local ut = this.gameObject.ocgf.ut\13\n\9offsetX, offsetY = offsetX or 0, offsetY or 0\13\n\9\13\n\9this.gameObject.ocgf.oclrl:draw(0, 0, this.gameObject.ocgf.oclrl.generateTexture({\13\n\9\9{\"b\", color or 0xFF69B4},\13\n\9\9{this.posX + offsetX, this.posY + offsetY, ut.fillString(\"\", this.sizeX, \" \")},\13\n\9\9{this.posX + offsetX, this.posY + (this.sizeY -1) + offsetY, ut.fillString(\"\", this.sizeX, \" \")},\13\n\9\9{this.posX + offsetX, this.posY + offsetY, ut.fillString(\"\", this.sizeY, \" \"), true},\13\n\9\9{this.posX + (this.sizeX -1) + offsetX, this.posY + offsetY, ut.fillString(\"\", this.sizeY, \" \"), true},\13\n\9}), nil, area)\13\nend\13\n\13\nfunction OCGF.BoxTrigger.clear(this, color, actual, offsetX, offsetY)\13\n\9local gpu = this.gameObject.ocgf.gpu\13\n\9local ut = this.gameObject.ocgf.ut\13\n\9offsetX, offsetY = offsetX or 0, offsetY or 0\13\n\9gpu.setBackground(color or 0x000000)\13\n\9\13\n\9if actual then \13\n\9\9this.gameObject.ocgf.oclrl:clearBlack(0, 0, this.gameObject.ocgf.oclrl.generateTexture({\13\n\9\9\9{\"b\", color or 0xFF69B4},\13\n\9\9\9{this.posX + offsetX, this.posY + offsetY, ut.fillString(\"\", this.sizeX, \" \")},\13\n\9\9\9{this.posX + offsetX, this.posY + (this.sizeY -1) + offsetY, ut.fillString(\"\", this.sizeX, \" \")},\13\n\9\9\9{this.posX + offsetX, this.posY + offsetY, ut.fillString(\"\", this.sizeY, \" \"), true},\13\n\9\9\9{this.posX + (this.sizeX -1) + offsetX, this.posY + offsetY, ut.fillString(\"\", this.sizeY, \" \"), true},\13\n\9\9}), nil, area)\13\n\9else\13\n\9\9this.gameObject.ocgf.oclrl:clearBlack(0, 0, this.gameObject.ocgf.oclrl.generateTexture({\13\n\9\9\9{\"b\", color or 0xFF69B4},\13\n\9\9\9{this.lastPosX + offsetX, this.lastPosY + offsetY, ut.fillString(\"\", this.sizeX, \" \")},\13\n\9\9\9{this.lastPosX + offsetX, this.lastPosY + (this.sizeY -1) + offsetY, ut.fillString(\"\", this.sizeX, \" \")},\13\n\9\9\9{this.lastPosX + offsetX, this.lastPosY + offsetY, ut.fillString(\"\", this.sizeY, \" \"), true},\13\n\9\9\9{this.lastPosX + (this.sizeX -1) + offsetX, this.lastPosY + offsetY, ut.fillString(\"\", this.sizeY, \" \"), true},\13\n\9\9}), nil, area)\13\n\9end\13\nend\13\n\13\nreturn OCGF\13\n\13\n\13\n\13\n\13\n\13\n",["./libs/ocl.lua"] = "--[[\13\n    ocl Copyright (C) 2019 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--ToDo: make it object oriented.\13\n\13\nlocal ocl = { version = \"v1.1\",\13\n\9conf = {\13\n\9\9logFile = \"logs/nosGa.log\",\13\n\9\9backups = false,\13\n\9},\13\n\9\13\n\9logFile = {},\13\n}\13\n\13\nlocal filesystem = require(\"filesystem\")\13\nlocal shell = require(\"shell\")\13\nlocal ut = require(\"libs/UT\")\13\n\13\nfunction ocl.open(path)\13\n\9if path ~= nil then\13\n\9\9ocl.conf.logFile = path\13\n\9end\13\n\9local dir, fileName, fileEnd = ut.seperatePath(ocl.conf.logFile)\13\n\9fileEnd = fileEnd or \"\"\13\n\9if string.sub(ocl.conf.logFile, 0, 1) ~= \"/\" then\13\n\9\9dir = shell.getWorkingDirectory() .. \"/\" .. dir\13\n\9end\13\n\9filesystem.makeDirectory(dir)\13\n\9\13\n\9local file = nil\13\n\9if ocl.conf.backups then\13\n\9\9file = io.open(dir .. fileName .. fileEnd, \"r\")\13\n\9end\13\n\9if file == nil or not ocl.conf.backups then\13\n\9\9ocl.logFile = io.open(dir .. fileName .. fileEnd, \"w\")\13\n\9else\13\n\9\9file:close()\13\n\9\9local count = 1\13\n\9\9while true do\13\n\9\9\9file = io.open(dir .. fileName .. \"(\" .. tostring(count) .. \")\" .. fileEnd, \"r\")\13\n\9\9\9if file == nil then\13\n\9\9\9\9ocl.logFile = io.open(dir .. fileName .. \"(\" .. tostring(count) .. \")\" .. fileEnd, \"w\")\13\n\9\9\9\9break\13\n\9\9\9end\13\n\9\9\9file:close()\13\n\9\9\9count = count +1\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction ocl.add(...)\13\n\9local text = \"\"\13\n\9for _, s in ipairs({...}) do\13\n\9\9text = text .. tostring(s)\13\n\9end\13\n\9ocl.logFile:write(tostring(text))\13\n\9ocl.logFile:write(\"\\n\")\13\n\9ocl.logFile:flush()\13\nend\13\n\13\nfunction ocl.close()\13\n\9ocl.logFile:close()\13\nend\13\n\13\nreturn ocl",["./libs/ocui.lua"] = "--[[\13\n    ocui Copyright (C) 2019 MisterNoNameLP.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\nlocal OCUI = {version = \"v2.0\"}\13\nOCUI.__index = OCUI\13\n\13\n--[[ToDo:\13\n\9add color check arg on draw calls.\13\n\9rework the initialisation routines (better args etc.).\13\n\9add dynamic ui generation (no texture).\13\n]]--\13\n\13\nlocal UT = require(\"libs/UT\")\13\nlocal xpcall = xpcall\13\n\13\nfunction OCUI.initiate(oclrl, onError)\13\n\9local this = setmetatable({}, OCUI)\13\n\9this.event = require(\"event\")\13\n\9this.oclrl = oclrl\13\n\9\13\n\9this.updateList = {} --list of managed buttons\13\n\9this.updateCount = 0\13\n\9this.drawList = {} --list of managed buttons\13\n\9this.drawCount = 0\13\n\9this.stopList = {}\13\n\9this.stopCount = 0\13\n\9\13\n\9this.globalStop = false --to avoid stopList cleaning by iterate it.\13\n\9\13\n\9this.onError = onError or function() end\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCUI.stop(this) --dont ignor\13\n\9this.globalStop = true\13\n\9for c, v in ipairs(this.stopList) do\13\n\9\9if v ~= nil then\13\n\9\9\9v:stop()\13\n\9\9end\13\n\9end\13\n\9this.globalStop = false\13\nend\13\n\13\nfunction OCUI.update(this, x, y)\13\n\9for c, v in ipairs(this.updateList) do\13\n\9\9v:update(x, y)\13\n\9end\13\nend\13\n\13\nfunction OCUI.draw(this)\13\n\9for c, v in ipairs(this.drawList) do\13\n\9\9v:draw(x, y)\13\n\9end\13\nend\13\n\13\nfunction OCUI.listAutoManage(object, args) --ToDo: needs to work with value index instead of numeretic index.\13\n\9local managed = {}\13\n\9managed[1] = args.update\13\n\9managed[2] = args.draw\13\n\9managed[3] = args.stop\13\n\9\13\n\9if managed[1] or managed[1] == nil then\13\n\9\9object.ocui.updateCount = object.ocui.updateCount +1\13\n\9\9object.ocui.updateList[object.ocui.updateCount] = object\13\n\9\9object.updateListPos = object.ocui.updateCount\13\n\9end\13\n\9if managed[2] or managed[2] == nil then\13\n\9\9object.ocui.drawCount = object.ocui.drawCount +1\13\n\9\9object.ocui.drawList[object.ocui.drawCount] = object\13\n\9\9object.drawListPos = object.ocui.drawCount\13\n\9end\13\n\9if managed[3] or managed[3] == nil then\13\n\9\9object.ocui.stopCount = object.ocui.stopCount +1\13\n\9\9object.ocui.stopList[object.ocui.stopCount] = object\13\n\9\9object.stopListPos = object.ocui.stopCount\13\n\9end\13\nend\13\n\13\nfunction OCUI.ignoreAutoManage(object)\13\n\9if object.updateListPos ~= nil then\13\n\9\9table.remove(object.ocui.updateList, object.updateListPos)\13\n\9\9object.ocui.updateCount = object.ocui.updateCount -1\13\n\9\9for c = object.updateListPos, #object.ocui.updateList, 1 do\13\n\9\9\9object.ocui.updateList[c].updateListPos = object.ocui.updateList[c].updateListPos -1\13\n\9\9end\13\n\9end\13\n\9if object.drawListPos ~= nil then\13\n\9\9table.remove(object.ocui.drawList, object.drawListPos)\13\n\9\9object.ocui.drawCount = object.ocui.drawCount -1\13\n\9\9for c = object.drawListPos, #object.ocui.drawList, 1 do\13\n\9\9\9object.ocui.drawList[c].drawListPos = object.ocui.drawList[c].drawListPos -1\13\n\9\9end\13\n\9end\13\n\9if object.stopListPos ~= nil then\13\n\9\9if object.ocui.globalStop == false then\13\n\9\9\9table.remove(object.ocui.stopList, object.stopListPos)\13\n\9\9\9object.ocui.stopCount = object.ocui.stopCount -1\13\n\9\9\9for c = object.stopListPos, #object.ocui.stopList, 1 do\13\n\9\9\9\9object.ocui.stopList[c].stopListPos = object.ocui.stopList[c].stopListPos -1\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\n--===== Bar =====--\13\nOCUI.Bar = {widgetType = \"Bar\"}\13\nOCUI.Bar.__index = OCUI.Bar\13\n\13\nfunction OCUI.Bar.new(ocui, args)\13\n\9local this = setmetatable({}, OCUI.Bar)\13\n\9\13\n\9args = args or {}\13\n\9\13\n\9this.posX = args.posX or args.x\13\n\9this.posY = args.posY or args.y\13\n\9this.sizeX = args.sizeX or args.sx\13\n\9this.sizeY = args.sizeY or args.sy\13\n\9this.status = math.min(args.status or 0, 1) --0 == empty, 1 == full.\13\n\9this.cfg_activeForegroundColor = args.activeForegroundColor or 0xaaaaaa\13\n\9this.cfg_activeBackgroundColor = args.activeBackgroundColor or 0x777777\13\n\9this.cfg_inactiveForegroundColor = args.inactiveForegroundColor or 0x888888\13\n\9this.cfg_inactiveBackgroundColor = args.inactiveBackgroundColor or 0x333333\13\n\9this.cfg_vertical = args.vertical or false\13\n\9this.cfg_foregroundChar = args.foregroundChar or \" \"\13\n\9this.cfg_backgroundChar = args.backgroundChar or \" \"\13\n\9this.clickable = args.clickable == true or args.clickable == nil\13\n\9\13\n\9this.ocui = ocui\13\n\9\13\n\9if this.clickable then\13\n\9\9this.button = ocui.Button.new(ocui, this.posX, this.posY, this.sizeX, this.sizeY, {\13\n\9\9\9managed = {update = false, draw = false},\13\n\9\9\9listedFunction = function(_, x, y)\13\n\9\9\9\9if this.cfg_vertical then\13\n\9\9\9\9\9this.status = math.min((y +1 - this.posY) / this.sizeY, 1)\13\n\9\9\9\9else\13\n\9\9\9\9\9this.status = math.min((x +1 - this.posX) / this.sizeX, 1)\13\n\9\9\9\9end\13\n\9\9\9end,\13\n\9\9})\13\n\9end\13\n\9\13\n\9if this.sizeX == nil or this.sizeY == nil then\13\n\9\9return false, \"No sizeX or sizeY given\"\13\n\9end\13\n\9if this.posX == nil or this.posY == nil then\13\n\9\9return false, \"No posX or posY given\"\13\n\9end\13\n\9\13\n\9if args.managed ~= nil then\13\n\9\9args.managed.update = false\13\n\9end\13\n\9ocui.listAutoManage(this, args.managed or {})\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCUI.Bar.update(this, x, y)\13\n\9if this.clickable then\13\n\9\9this.button:update(x, y)\13\n\9end\13\nend\13\n\13\nfunction OCUI.Bar.draw(this)\13\n\9local gpu = this.ocui.oclrl.gpu\13\n\9\13\n\9gpu.setForeground(this.cfg_inactiveForegroundColor)\13\n\9gpu.setBackground(this.cfg_inactiveBackgroundColor)\13\n\9\13\n\9gpu.fill(this.posX, this.posY, this.sizeX, this.sizeY, this.cfg_backgroundChar)\13\n\9\13\n\9gpu.setForeground(this.cfg_activeForegroundColor)\13\n\9gpu.setBackground(this.cfg_activeBackgroundColor)\13\n\9if this.cfg_vertical then\13\n\9\9gpu.fill(this.posX, this.posY, this.sizeX, math.floor(this.sizeY * this.status +.5), this.cfg_foregroundChar)\13\n\9else\13\n\9\9gpu.fill(this.posX, this.posY, math.floor(this.sizeX * this.status +.5), this.sizeY, this.cfg_foregroundChar)\13\n\9end\13\nend\13\n\13\nfunction OCUI.Bar.setStatus(this, status)\13\n\9this.status = math.min(status, 1)\13\nend\13\n\13\nfunction OCUI.Bar.getStatus(this)\13\n\9return this.status\13\nend\13\n\13\nfunction OCUI.Bar.move(this, x, y)\13\n\9this.posX, this.posY = x, y\13\nend\13\n\13\nfunction OCUI.Bar.stop(this)\9\13\n\9this.ocui.ignoreAutoManage(this)\13\nend\13\n\13\n--===== TextBox =====--\13\nOCUI.TextBox = {widgetType = \"TextBox\"}\13\nOCUI.TextBox.__index = OCUI.TextBox\13\n\13\nfunction OCUI.TextBox.new(ocui, args)\13\n\9local this = setmetatable({}, OCUI.TextBox)\13\n\9\13\n\9args = args or {}\13\n\9\13\n\9this.posX = args.posX or args.x\13\n\9this.posY = args.posY or args.y\13\n\9this.sizeX = args.sizeX or args.sx\13\n\9this.sizeY = args.sizeY or args.sy\13\n\9this.lineBreak = args.lineBreak or false\13\n\9this.cfg_foregroundColor = args.foregroundColor or 0xaaaaaa\13\n\9this.cfg_backgroundColor = args.backgroundColor or 0x555555\13\n\9this.content = {}\13\n\9OCUI.TextBox.addContent(this, OCUI.TextBox.getContent(this, args.content, args.sizeX, this.lineBreak))\13\n\9--[[ or OCUI.TextBox.getContent(\13\n\9\9{args.text or \"\"},\13\n\9\9args.sizeX,\13\n\9\9args.lineBreak or false\13\n\9)]]\13\n\9\13\n\9this.ocui = ocui\13\n\9\13\n\9if this.sizeX == nil or this.sizeY == nil then\13\n\9\9return false, \"No sizeX or sizeY given\"\13\n\9end\13\n\9if this.posX == nil or this.posY == nil then\13\n\9\9return false, \"No posX or posY given\"\13\n\9end\13\n\9\13\n\9if args.managed ~= nil then\13\n\9\9args.managed.update = false\13\n\9end\13\n\9ocui.listAutoManage(this, args.managed or {update = false})\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCUI.TextBox.getContent(this, text, length, lineBreak)\13\n\9local content = {}\13\n\9local index = 1\13\n\9if type(text) ~= \"table\" then\13\n\9\9text = {text}\13\n\9end\13\n\9for _, t in ipairs(text) do\13\n\9\9\13\n\9\9for s in string.gmatch(tostring(t), \"[^\\r\\n]+\") do\13\n\9\9\9s = string.gsub(s, \"\\t\", \"     \")\13\n\9\9\9\13\n\9\9\9if #s > length then\13\n\9\9\9\9if lineBreak then\13\n\9\9\9\9\9table.insert(text, #text +1, string.sub(s, length))\13\n\9\9\9\9end\13\n\9\9\9\9s = string.sub(s, 0, length)\13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9content[index] = UT.fillString(s, length - #s, \" \")\13\n\9\9\9index = index +1\13\n\9\9end\13\n\9end\13\n\9\13\n\9return content\13\nend\13\n\13\nfunction OCUI.TextBox.addContent(this, content)\13\n\9for _, c in ipairs(content) do\13\n\9\9\13\n\9\9for s in string.gmatch(tostring(c), \"[^\\r\\n]+\") do\13\n\9\9\9s = string.gsub(s, \"\\t\", \"     \")\13\n\9\9\9--table.insert(this.content, s)\13\n\9\9end\13\n\9\9table.insert(this.content, c)\13\n\9end\13\n\9if #this.content > this.sizeY then\13\n\9\9local tmpContent = {}\13\n\9\9for c = #this.content -this.sizeY +1, #this.content do\13\n\9\9\9table.insert(tmpContent, this.content[c])\13\n\9\9end\13\n\9\9this.content = tmpContent\13\n\9end\13\nend\13\n\13\nfunction OCUI.TextBox.add(this, ...)\13\n\9local text = \"\"\13\n\9for _, s in ipairs({...}) do\13\n\9\9text = text .. tostring(s) .. \"     \"\13\n\9end\13\n\9this:addContent(this:getContent({text}, this.sizeX, this.lineBreak))\13\nend\13\n\13\nfunction OCUI.TextBox.update(this, ...)\9\13\n\9\13\nend\13\n\13\nfunction OCUI.TextBox.draw(this)\13\n\9local gpu = this.ocui.oclrl.gpu\13\n\9\13\n\9gpu.setForeground(this.cfg_foregroundColor)\13\n\9gpu.setBackground(this.cfg_backgroundColor)\13\n\9\13\n\9if #this.content < this.sizeY then\13\n\9\9gpu.fill(this.posX, this.posY, this.sizeX, this.sizeY, \" \")\13\n\9end\13\n\9\13\n\9for c, t in ipairs(this.content) do\13\n\9\9gpu.set(this.posX, this.posY +c -1, t)\13\n\9end\13\nend\13\n\13\nfunction OCUI.TextBox.move(this, x, y)\13\n\9this.posX, this.posY = x, y\13\nend\13\n\13\nfunction OCUI.TextBox.stop(this)\9\13\n\9this.ocui.ignoreAutoManage(this)\13\nend\13\n\13\n\13\n--===== Menu =====--\13\nOCUI.Menu = {widgetType = \"menu\"}\13\nOCUI.Menu.__index = OCUI.Menu\13\n\13\nfunction OCUI.Menu.new(ocui, args)--posX == [int], posY == [int], content == [numTable], {backgroundTexture == [OCGLTexture], managed == [{update == [bool], draw == [bool], stop == [bool]}]}\13\n\9local this = setmetatable({}, OCUI.Menu)\13\n\9this.thread = require(\"thread\")\13\n\9this.event = require(\"event\")\13\n\9this.ocui = ocui\13\n\9this.posX = UT.parseArgs(args.x, args.posX)\13\n\9this.posY = UT.parseArgs(args.y, args.posY)\13\n\9this.content = {}\13\n\9this.backgroundTexture = args.backgroundTexture\13\n\9this.status = true\13\n\9this.markedPos = 0\13\n\9this.markingList = {}\13\n\9this.internOCUI = ocui.initiate(ocui.oclrl)\13\n\9this.inputThread = this.thread.create(function() end)\13\n\9\13\n\9this.cfg_inputMap = {next = {15}}\13\n\9\13\n\9this:add(UT.parseArgs(args.c, args.content))\13\n\9ocui.listAutoManage(this, args.managed or {})\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCUI.Menu.activate(this)\13\n\9for c, v in ipairs(this.markingList) do\13\n\9\9v:activate()\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.deactivate(this)\13\n\9for c, v in ipairs(this.markingList) do\13\n\9\9v:deactivate()\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.inputManager(this)\13\n\9while this.status and this.markingList[this.markedPos].status do\13\n\9\9local _, _, key, code = this.event.pull(\"key_down\")\13\n\9\9if UT.inputCheck(this.cfg_inputMap.next, code) then\13\n\9\9\9this:next()\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.add(this, content)\13\n\9for c, v in ipairs(content) do\13\n\9\9v[1]:stop()\13\n\9\9v[1]:move(this.posX +v[2], this.posY +v[3])\13\n\9\9\13\n\9\9if UT.inputCheck({\"textInput\", \"list\"}, v[1].widgetType) then --WIP\13\n\9\9\9table.insert(this.markingList, v[1])\13\n\9\9\9local mp = #this.markingList\13\n\9\9\9local oldFunction = v[1].update\13\n\9\9\9\13\n\9\9\9v[1].update = function(this2, x, y) \13\n\9\9\9\9oldFunction(this2, x, y)\13\n\9\9\9\9if this2.status then \13\n\9\9\9\9\9this.markedPos = mp\13\n\9\9\9\9end \13\n\9\9\9end\13\n\9\9\9\13\n\9\9\9if v[1].widgetType == \"textInput\" then\13\n\9\9\9\9for c2, v2 in ipairs(this.cfg_inputMap.next) do\13\n\9\9\9\9\9table.insert(v[1].cfg_inputMap.forbidden, v2)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9end\13\n\9\9\13\n\9\9v[1].ocui = this.internOCUI\13\n\9\9this.internOCUI.listAutoManage(v[1], {})\13\n\9\9table.insert(this.content, v)\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.next(this) --WIP\13\n\9if this.status and this.markingList[this.markedPos].status then\13\n\9\9if this.markedPos == #this.markingList then\13\n\9\9\9this.markedPos = 0\13\n\9\9end\13\n\9\9if this.markingList[this.markedPos +1].widgetType == \"textInput\" then\13\n\9\9\9this.internOCUI:update(this.markingList[this.markedPos +1].posX +this.markingList[this.markedPos +1].size -1, this.markingList[this.markedPos +1].posY)\13\n\9\9elseif this.markingList[this.markedPos +1].widgetType == \"list\" then\13\n\9\9\9this.markingList[this.markedPos +1].pClickTime = 0\13\n\9\9\9if this.markingList[this.markedPos +1].upButton == nil then\13\n\9\9\9\9this.internOCUI:update(this.markingList[this.markedPos +1].posX, this.markingList[this.markedPos +1].posY +this.markingList[this.markedPos +1].markedPosition -1)\13\n\9\9\9else\13\n\9\9\9\9this.internOCUI:update(this.markingList[this.markedPos +1].posX, this.markingList[this.markedPos +1].posY +this.markingList[this.markedPos +1].markedPosition)\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.move(this, x, y)\13\n\9this.posX, this.posY = x, y\13\n\9for c, v in ipairs(this.content) do\13\n\9\9v[1]:move(this.posX +v[2], this.posY +v[3])\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.update(this, x, y)\13\n\9if this.status then\13\n\9\9this.internOCUI:update(x, y)\13\n\9\9if this.inputThread:status() ~= \"running\" then\13\n\9\9\9this.inputThread = this.thread.create(this.inputManager, this)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.draw(this)\13\n\9if this.status then\13\n\9\9if this.backgroundTexture ~= nil then\13\n\9\9\9this.ocui.oclrl:draw(this.posX, this.posY, this.backgroundTexture)\13\n\9\9end\13\n\9\9this.internOCUI:draw()\13\n\9end\13\nend\13\n\13\nfunction OCUI.Menu.stop(this)\13\n\9this.ocui.ignoreAutoManage(this)\13\n\9this.internOCUI:stop()\13\n\9this.inputThread:kill()\13\nend\13\n\13\n--===== List =====--\13\nOCUI.List = {widgetType = \"list\"}\13\nOCUI.List.__index = OCUI.List\13\n\13\nfunction OCUI.List.new(ocui, args) --posX == [int], posY == [int], sizeX == [int], sizeY == [int], content == [numTable], {colors == [numTable], listedFunction == [function()], config == [table], managed == [{update == [bool], draw == [bool], stop == [bool]}]}\13\n\9local this = setmetatable({}, OCUI.List)\13\n\9this.computer = require(\"computer\")\13\n\9this.event = require(\"event\")\13\n\9this.thread = require(\"thread\") \13\n\9this.listedFunction = args.listedFunction or function() end\13\n\9this.ocui = ocui\13\n\9this.posX = UT.parseArgs(args.x, args.posX)\13\n\9this.posY = UT.parseArgs(args.y, args.posY)\13\n\9this.sizeX = UT.parseArgs(args.sx, args.sizeX)\13\n\9this.sizeY = UT.parseArgs(args.sy, args.sizeY)\13\n\9\13\n\9args.colors = args.colors or {}\13\n\9this.cfg_normalForegroundColor = args.colors[1] or 0xaaaaaa\13\n\9this.cfg_normalBackgroundColor = args.colors[2] or 0x555555\13\n\9this.cfg_clickedForegroundColor = args.colors[3] or 0xffffff\13\n\9this.cfg_clickedBackgroundColor = args.colors[4] or 0xaaaaaa\13\n\9\13\n\9this.cfg_inputMap = {up = {200}, down = {208}, enter = {28}, pos1 = {199}, endKey = {207}}\13\n\9config = args.config or {}\13\n\9this.cfg_pingByEveryClick = config[1] or false\13\n\9this.cfg_doubleClickTime = config[2] or .5\13\n\9\13\n\9this.status = false\13\n\9this.tmpStatus = false\13\n\9this.markedPosition = 1\13\n\9this.pClickPos = 1\13\n\9this.pClickTime = 0\13\n\9this.content = UT.parseArgs(args.content, {})\13\n\9this.internOCUI = ocui.initiate(ocui.oclrl, this.ocui.onError)\13\n\9this.buttons = {}\13\n\9this.inputThread = this.thread.create(function() end)\13\n\9this.backgroundTexture = ocui.oclrl.generateTexture({this.cfg_normalForegroundColor, this.cfg_normalBackgroundColor, this.sizeX, this.sizeY, \" \"})\13\n\9this.listButton = this.ocui.Button.new(this.internOCUI, \13\n\9\9{\13\n\9\9\9posX = this.posX, \13\n\9\9\9posY = this.posY, \13\n\9\9\9sizeX = this.sizeX, \13\n\9\9\9sizeY = this.sizeY, \13\n\9\9\9listedFunction = function() \13\n\9\9\9\9this.status = true \13\n\9\9\9\9this.tmpStatus = true \13\n\9\9\9\9if this.inputThread:status() ~= \"running\" then\13\n\9\9\9\9\9this.inputThread = this.thread.create(this.inputManager, this)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9})\13\n\9\13\n\9--ButtonGenerating {\13\n\9this.scrollPos = nil\13\n\9this.buttonCount = 0\13\n\9\13\n\9local buttonStartPos = 0\13\n\9\13\n\9if #this.content > this.sizeY then\13\n\9\9this.buttonCount = this.sizeY -2\13\n\9\9this.scrollPos = 0\13\n\9\9buttonStartPos = 1\13\n\9\9\13\n\9\9local function ScrollContent()\13\n\9\9\9for c, v in ipairs(this.buttons) do\13\n\9\9\9\9v.texture0 = ocui.oclrl.generateTexture({this.cfg_normalForegroundColor, this.cfg_normalBackgroundColor, UT.fillString(this.content[this.scrollPos +c], this.sizeX - #this.content[this.scrollPos +c], \" \")})\13\n\9\9\9\9v.texture1 = ocui.oclrl.generateTexture({this.cfg_clickedForegroundColor, this.cfg_clickedBackgroundColor, UT.fillString(this.content[this.scrollPos +c], this.sizeX - #this.content[this.scrollPos +c], \" \")})\13\n\9\9\9end\13\n\9\9end\13\n\9\9this.upButton = this.internOCUI.Button.new(this.internOCUI, this.posX, this.posY, this.sizeX, 1, {texture0 = this.ocui.oclrl.generateTexture({this.cfg_normalForegroundColor, this.cfg_normalBackgroundColor, \"^\"}), texture1 = this.ocui.oclrl.generateTexture({this.cfg_clickedForegroundColor, this.cfg_clickedBackgroundColor, UT.fillString(\"^\", this.sizeX -1, \" \")}), listedFunction = function(_)\13\n\9\9\9if this.scrollPos > 0 then\13\n\9\9\9\9this.scrollPos = this.scrollPos -1\13\n\9\9\9\9ScrollContent()\13\n\9\9\9end\13\n\9\9end})\13\n\9\9this.downButton = this.internOCUI.Button.new(this.internOCUI, this.posX, this.posY +this.sizeY -1, this.sizeX, 1, {texture0 = this.ocui.oclrl.generateTexture({this.cfg_normalForegroundColor, this.cfg_normalBackgroundColor, \"v\"}), texture1 = this.ocui.oclrl.generateTexture({this.cfg_clickedForegroundColor, this.cfg_clickedBackgroundColor, UT.fillString(\"v\", this.sizeX -1, \" \")}), listedFunction = function(_)\13\n\9\9\9if this.scrollPos < this.sizeY -2 then\13\n\9\9\9\9this.scrollPos = this.scrollPos +1\13\n\9\9\9\9ScrollContent()\13\n\9\9\9end\13\n\9\9end})\13\n\9else\13\n\9\9this.buttonCount = #this.content\13\n\9end\13\n\9\13\n\9for c = 1, this.buttonCount, 1 do\13\n\9\9this.buttons[c] = this.internOCUI.Button.new(this.internOCUI, this.posX, this.posY +c -1 +buttonStartPos, this.sizeX, 1, {texture0 = this.ocui.oclrl.generateTexture({this.cfg_normalForegroundColor, this.cfg_normalBackgroundColor, UT.fillString(this.content[c], this.sizeX - #this.content[c], \" \")}), texture1 = this.ocui.oclrl.generateTexture({this.cfg_clickedForegroundColor, this.cfg_clickedBackgroundColor, UT.fillString(this.content[c], this.sizeX - #this.content[c], \" \")}), listedFunction = function(_) \13\n\9\9\9if this.computer.uptime() - this.pClickTime < this.cfg_doubleClickTime and this.pClickPos == c or this.cfg_doubleClickTime == -1 then\13\n\9\9\9\9this:buttonPress(c, true)\13\n\9\9\9else\13\n\9\9\9\9this.buttons[this.pClickPos].status = false\13\n\9\9\9\9this.buttons[c].status = true\13\n\9\9\9\9if this.cfg_pingByEveryClick then\13\n\9\9\9\9\9this:buttonPress(c, false)\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9\9this.pClickTime = this.computer.uptime()\13\n\9\9\9this.pClickPos = c\13\n\9\9\9this.markedPosition = c\13\n\9\9end})\13\n\9\9if this.cfg_doubleClickTime ~= -1 then\13\n\9\9\9this.buttons[c].cfg_clickTime = -1\13\n\9\9end\13\n\9end\13\n\9--}\13\n\9\13\n\9ocui.listAutoManage(this, managed or {})\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCUI.List.activate(this)\13\n\9this.pClickTime = 0\13\n\9if this.upButton ~= nil then\13\n\9\9this:update(this.posX, this.posY +this.markedPosition)\13\n\9else\13\n\9\9this:update(this.posX, this.posY)\13\n\9end\13\nend\13\n\13\nfunction OCUI.List.deactivate(this)\13\n\9this:update(-1, this.posY -1)\13\nend\13\n\13\nfunction OCUI.List.inputManager(this)\13\n\9local m = this.cfg_inputMap\13\n\9while this.cfg_doubleClickTime ~= -1 and this.status do\13\n\9\9local eventType, _, key, code, direction = this.event.pull()\13\n\9\9if eventType == \"key_down\" then\13\n\9\9\9if UT.inputCheck(m.enter, code) then\13\n\9\9\9\9this.pClickTime = this.computer.uptime()\13\n\9\9\9\9this.buttons[this.markedPosition]:listedFunction()\13\n\9\9\9elseif UT.inputCheck(m.pos1, code) then\13\n\9\9\9\9if this.scrollPos ~= nil then\13\n\9\9\9\9\9this.scrollPos = 1\13\n\9\9\9\9\9this.upButton:listedFunction()\13\n\9\9\9\9end\13\n\9\9\9\9this.buttons[1]:listedFunction()\13\n\9\9\9elseif UT.inputCheck(m.endKey, code) then\13\n\9\9\9\9if this.scrollPos ~= nil then\13\n\9\9\9\9\9this.scrollPos = #this.content - this.buttonCount -1\13\n\9\9\9\9\9this.downButton:listedFunction()\13\n\9\9\9\9end\13\n\9\9\9\9this.buttons[this.buttonCount]:listedFunction()\13\n\9\9\9elseif UT.inputCheck(m.up, code) then\13\n\9\9\9\9if this.markedPosition > 1 then\13\n\9\9\9\9\9this.buttons[this.markedPosition -1]:listedFunction()\13\n\9\9\9\9elseif this.scrollPos ~= nil then\13\n\9\9\9\9\9this.upButton:listedFunction()\13\n\9\9\9\9end\13\n\9\9\9elseif UT.inputCheck(m.down, code) then\13\n\9\9\9\9if this.markedPosition < this.buttonCount then\13\n\9\9\9\9\9this.buttons[this.markedPosition +1]:listedFunction()\13\n\9\9\9\9elseif this.scrollPos ~= nil then\13\n\9\9\9\9\9this.downButton:listedFunction()\13\n\9\9\9\9end\13\n\9\9\9end\13\n\9\9elseif eventType == \"scroll\" then\13\n\9\9\9if this.scrollPos ~= nil and direction == 1 then\13\n\9\9\9\9this.upButton:listedFunction()\13\n\9\9\9elseif this.scrollPos ~= nil and direction == -1 then\13\n\9\9\9\9this.downButton:listedFunction()\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCUI.List.buttonPress(this, pos, isDoubleClicked)\13\n\9if this.scrollPos == nil then\13\n\9\9this:listedFunction(this.content[pos], pos, isDoubleClicked, pos)\13\n\9else\13\n\9\9this:listedFunction(this.content[pos +this.scrollPos], pos +this.scrollPos, isDoubleClicked, pos)\13\n\9end\13\nend\13\n\13\nfunction OCUI.List.update(this, x, y)\9\13\n\9this.internOCUI:update(x, y)\13\n\9if this.tmpStatus == false and #this.buttons > 0 then\13\n\9\9this.status = false\13\n\9\9this.buttons[this.markedPosition].status = false\13\n\9\9if this.inputThread.status ~= nil then\13\n\9\9\9this.inputThread:kill()\13\n\9\9end\13\n\9elseif #this.buttons > 0 then\13\n\9\9this.buttons[this.markedPosition].status = true\13\n\9end\13\n\9this.tmpStatus = false\13\nend\13\n\13\nfunction OCUI.List.draw(this)\13\n\9this.ocui.oclrl:draw(this.posX, this.posY, this.backgroundTexture)\13\n\9this.internOCUI:draw()\13\nend\13\n\13\nfunction OCUI.List.move(this, x, y)\13\n\9this.posX, this.posY = x, y\13\n\9this.listButton:move(x, y)\13\n\9if this.upButton ~= nil then\13\n\9\9this.upButton:move(x, y)\13\n\9\9this.downButton:move(x, y +this.sizeY -1)\13\n\9\9for c, v in ipairs(this.buttons) do\13\n\9\9\9v:move(x, y +c)\13\n\9\9end\13\n\9else\13\n\9\9for c, v in ipairs(this.buttons) do\13\n\9\9\9v:move(x, y +c -1)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCUI.List.stop(this)\13\n\9this.inputThread:kill()\13\n\9\13\n\9this.ocui.ignoreAutoManage(this)\13\nend\13\n\13\n\13\n\13\n--===== TextInput =====--\13\nOCUI.TextInput = {widgetType = \"textInput\"}\13\nOCUI.TextInput.__index = OCUI.TextInput\13\n\13\nfunction OCUI.TextInput.new(ocui, args) --posX == [int], posY == [int], size == [int], args == {colors == [numTable], listedFunction == [function()], managed == [{update == [bool], draw == [bool], stop == [bool]}]}\13\n\13\n\9local this = setmetatable({}, OCUI.TextInput)\13\n\9this.computer = require(\"computer\")\13\n\9this.event = require(\"event\")\13\n\9this.thread = require(\"thread\") \13\n\9this.ocui = ocui\13\n\9this.posX = UT.parseArgs(args.x, args.posX)\13\n\9this.posY = UT.parseArgs(args.y, args.posY)\13\n\9this.size = UT.parseArgs(args.s, args.size)\13\n\9this.listedFunction = args.listedFunction or function() end\13\n\9this.autoCompFunction = args.autoCompFunction or function() end\13\n\9\13\n\9args.colors = args.colors or {}\13\n\9this.cfg_normalForegroundColor = args.colors[1] or 0xaaaaaa\13\n\9this.cfg_normalBackgroundColor = args.colors[2] or 0x555555\13\n\9this.cfg_clickedForegroundColor = args.colors[3] or 0xffffff\13\n\9this.cfg_clickedBackgroundColor = args.colors[4] or 0xaaaaaa\13\n\9this.cfg_cursorForegroundColor = args.colors[5] or 0x444444\13\n\9this.cfg_cursorBackgroundColor = args.colors[6] or 0xffffff\13\n\9\13\n\9this.cfg_showCursor = true\13\n\9this.cfg_cursorBlinkTime = .5\13\n\9this.cfg_keepText = false\13\n\9this.cfg_maxHistoryLength = -1\13\n\9this.cfg_hiddenText = args.hiddenText or false\13\n\9\13\n\9this.cfg_inputMap = {back = {14}, left = {203}, right = {205}, up = {200}, down = {208}, enter = {28}, pos1 = {199}, endKey = {207}, del = {211}, autoComplete = {15}, forbidden = {}, allowed = {}}\13\n\9\13\n\9this.autoComplete = args.autoComplete or {}\13\n\9\13\n\9this.status = false\13\n\9this.text = \"\"\13\n\9this.stringPosition = 0\13\n\9this.cursorPosition = 1\13\n\9this.cursorPTime = 0\13\n\9this.history = {}\13\n\9this.historyPosition = -1\13\n\9this.userInput = \"\"\13\n\9this.autoCompBase = \"\" --for auto complete\13\n\9this.autoCompPos = 1\13\n\9\13\n\9this.inputThread = this.thread.create(function() end)\13\n\9\13\n\9ocui.listAutoManage(this, args.managed or {})\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCUI.TextInput.activate(this) \13\n\9this:update(this.posX +this.size -1, this.posY)\13\nend\13\n\13\nfunction OCUI.TextInput.deactivate(this)\13\n\9this:update(-1, this.posY -1)\13\nend\13\n\13\nfunction OCUI.TextInput.inputManager(this)\13\n\9local inputCheck = UT.inputCheck\13\n\9local function MoveCursor(c)\13\n\9\9if 0 +c > 0 then\13\n\9\9\9if this.cursorPosition +c > this.size and #this.text -this.stringPosition >= this.size then\13\n\9\9\9\9this.stringPosition = this.stringPosition +(c - (this.size - this.cursorPosition))\13\n\9\9\9\9this.cursorPosition = this.size\13\n\9\9\9elseif this.cursorPosition < this.size and this.cursorPosition <= #this.text then\13\n\9\9\9\9this.cursorPosition = this.cursorPosition +c\13\n\9\9\9end\13\n\9\9else\13\n\9\9\9if this.cursorPosition +c < 1 and this.stringPosition > 0 then\13\n\9\9\9\9this.stringPosition = this.stringPosition +c\13\n\9\9\9\9this.cursorPosition = 1\13\n\9\9\9elseif this.cursorPosition > 1 then\13\n\9\9\9\9this.cursorPosition = this.cursorPosition +c\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\n\9local function RSC() --reset cursor\13\n\9\9this.cursorPosition = 1\13\n\9\9this.stringPosition = 0\13\n\9end\13\n\9local m = this.cfg_inputMap\13\n\9\13\n\9while this.status do\13\n\9\9local _, _, key, code = this.event.pull(\"key_down\")\13\n\9\9this.cursorPTime = this.computer.uptime()\13\n\9\9if key ~= nil then\9\9\9\13\n\9\9\9if inputCheck(m.enter, code) then\13\n\9\9\9\9if #this.history >= this.cfg_maxHistoryLength and this.cfg_maxHistoryLength ~= -1 and this.cfg_maxHistoryLength ~= 0 then\13\n\9\9\9\9\9for c = 1, this.cfg_maxHistoryLength, 1 do\13\n\9\9\9\9\9\9this.history[c] = this.history[c +1]\13\n\9\9\9\9\9end\13\n\9\9\9\9\9this.history[this.cfg_maxHistoryLength] = this.text\13\n\9\9\9\9elseif this.cfg_maxHistoryLength ~= 0 then\13\n\9\9\9\9\9table.insert(this.history, this.text)\13\n\9\9\9\9end\13\n\9\9\9\9this.historyPosition = -1\13\n\9\9\9\9local success, errorMsg = xpcall(this.listedFunction, debug.traceback, this)\13\n\9\9\9\9if success == false then\13\n\9\9\9\9\9this.ocui.onError(this, errorMsg)\13\n\9\9\9\9end\13\n\9\9\9\9if this.cfg_keepText == false then\13\n\9\9\9\9\9this.text = \"\"\13\n\9\9\9\9\9this.autoCompBase = this.text\13\n\9\9\9\9\9RSC()\13\n\9\9\9\9end\13\n\9\9\9elseif inputCheck(m.left, code) then\13\n\9\9\9\9MoveCursor(-1)\13\n\9\9\9elseif inputCheck(m.right, code) then\13\n\9\9\9\9MoveCursor(1)\13\n\9\9\9elseif inputCheck(m.pos1, code) then\13\n\9\9\9\9RSC()\13\n\9\9\9elseif inputCheck(m.endKey, code) then\13\n\9\9\9\9RSC()\13\n\9\9\9\9MoveCursor(#this.text)\13\n\9\9\9elseif inputCheck(m.back, code) then\13\n\9\9\9\9if #this.text > 0 and this.cursorPosition > 1 then\13\n\9\9\9\9\9local ct = UT.getChars(this.text)\13\n\9\9\9\9\9table.remove(ct, this.cursorPosition + this.stringPosition -1)\13\n\9\9\9\9\9this.text = UT.makeString(ct)\13\n\9\9\9\9\9if #this.text >= this.size -1 then\13\n\9\9\9\9\9\9this.stringPosition = this.stringPosition -1\13\n\9\9\9\9\9else\13\n\9\9\9\9\9\9MoveCursor(-1)\13\n\9\9\9\9\9end\13\n\9\9\9\9\9this.autoCompBase = this.text\13\n\9\9\9\9end\13\n\9\9\9elseif inputCheck(m.del, code) then\13\n\9\9\9\9if #this.text - (this.cursorPosition + this.stringPosition) >= 0 then\13\n\9\9\9\9\9local ct = UT.getChars(this.text)\13\n\9\9\9\9\9table.remove(ct, this.cursorPosition + this.stringPosition)\13\n\9\9\9\9\9this.text = UT.makeString(ct)\13\n\9\9\9\9\9this.autoCompBase = this.text\13\n\9\9\9\9end\13\n\9\9\9elseif inputCheck(m.up, code) then\13\n\9\9\9\9if this.historyPosition == -1 and this.cfg_maxHistoryLength ~= 0 and #this.history > 0 then\13\n\9\9\9\9\9this.userInput = this.text\13\n\9\9\9\9\9this.historyPosition = #this.history\13\n\9\9\9\9\9this.text = this.history[this.historyPosition]\13\n\9\9\9\9elseif this.historyPosition > 1 then\13\n\9\9\9\9\9this.historyPosition = this.historyPosition -1\13\n\9\9\9\9\9this.text = this.history[this.historyPosition]\13\n\9\9\9\9end\13\n\9\9\9\9RSC()\13\n\9\9\9\9MoveCursor(#this.text)\13\n\9\9\9\9this.autoCompBase = this.text\13\n\9\9\9elseif inputCheck(m.down, code) then\13\n\9\9\9\9if this.historyPosition < #this.history and this.historyPosition ~= -1 then\13\n\9\9\9\9\9this.historyPosition = this.historyPosition +1\13\n\9\9\9\9\9this.text = this.history[this.historyPosition]\13\n\9\9\9\9elseif #this.history > 0 then\13\n\9\9\9\9\9this.historyPosition = -1\13\n\9\9\9\9\9this.text = this.userInput\13\n\9\9\9\9end\13\n\9\9\9\9RSC()\13\n\9\9\9\9MoveCursor(#this.text)\13\n\9\9\9\9this.autoCompBase = this.text\13\n\9\9\9elseif inputCheck(m.autoComplete, code) then\13\n\9\9\9\9local clear = true\13\n\9\9\9\9\13\n\9\9\9\9local success, errorMsg = xpcall(this.autoCompFunction, debug.traceback, this)\13\n\9\9\9\9if success == false then\13\n\9\9\9\9\9this.ocui.onError(this, errorMsg)\13\n\9\9\9\9end\13\n\9\9\9\9\13\n\9\9\9\9if this.autoCompBase ~= string.sub(this.text, 0, #this.autoCompBase) or this.autoCompBase == \"\" then\13\n\9\9\9\9\9this.autoCompBase = this.text\13\n\9\9\9\9end\13\n\9\9\9\9for i = this.autoCompPos, #this.autoComplete do\13\n\9\9\9\9\9this.autoCompPos = i +1\13\n\9\9\9\9\9--print(string.sub(this.autoComplete[i], 0, #this.autoCompBase))\13\n\9\9\9\9\9if this.autoCompBase == string.sub(this.autoComplete[i], 0, #this.autoCompBase) then\13\n\9\9\9\9\9\9this.text = this.autoComplete[i]\13\n\9\9\9\9\9\9clear = false\13\n\9\9\9\9\9\9break\13\n\9\9\9\9\9end\13\n\9\9\9\9end\13\n\9\9\9\9if this.autoCompPos > #this.autoComplete and clear and #this.autoComplete > 0 then\13\n\9\9\9\9\9this.autoCompPos = 1\13\n\9\9\9\9\9this.text = this.autoCompBase\13\n\9\9\9\9end\13\n\9\9\9\9RSC()\13\n\9\9\9\9MoveCursor(#this.text)\13\n\9\9\9elseif key ~= 0 and inputCheck(m.forbidden, code) == false and #m.allowed == 0 or inputCheck(m.allowed, code) then\13\n\9\9\9\9--this.text = this.text .. string.char(key)\13\n\9\9\9\9local ct = UT.getChars(this.text)\13\n\9\9\9\9table.insert(ct, this.cursorPosition +this.stringPosition, string.char(key))\13\n\9\9\9\9this.text = UT.makeString(ct)\13\n\9\9\9\9this.cursorPTime = this.computer.uptime()\13\n\9\9\9\9MoveCursor(1)\13\n\9\9\9\9this.autoCompBase = this.text\13\n\9\9\9end\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCUI.TextInput.update(this, x, y)\9\13\n\9if x > this.posX -1 and x < this.posX + this.size and\13\n\9\9y > this.posY -1 and y < this.posY + 1\13\n\9then\13\n\9\9this.status = true\13\n\9\9if this.inputThread:status() ~= \"running\" then\13\n\9\9\9this.inputThread = this.thread.create(this.inputManager, this)\13\n\9\9\9this.inputThread:detach()\13\n\9\9\9this.ocui.stopList[this.stopListPos] = this\13\n\9\9end\13\n\9\9if x - this.posX > #this.text - this.stringPosition then\13\n\9\9\9this.cursorPosition = #this.text - this.stringPosition +1\13\n\9\9else\13\n\9\9\9this.cursorPosition = x - this.posX +1\13\n\9\9end\13\n\9else \13\n\9\9this.status = false\13\n\9\9this.inputThread:kill()\13\n\9end\13\nend\13\n\13\nfunction OCUI.TextInput.draw(this)\13\n\9local function generateTexture(t)\13\n\9\9return {textureFormat = \"OCGLT\", version = \"v0.1\", drawCalls = {{\"f\", t[1]}, {\"b\", t[2]}, {0, 0, t[3]}}}\13\n\9end\13\n\9local text = this.text\13\n\9if this.cfg_hiddenText then\13\n\9\9text = UT.fillString(\"\", #this.text, \"*\")\13\n\9end\13\n\9\13\n\9for c = #this.text, this.size -1, 1 do\13\n\9\9text = text .. \" \"\13\n\9end\13\n\9if #this.text > this.size -1 then\13\n\9\9local tm = #this.text - (this.size -1)\13\n\9\9tm = tm - this.stringPosition \13\n\9\9if tm > 0 then\13\n\9\9\9text = string.sub(this.text, this.stringPosition +1, -tm)\13\n\9\9else\13\n\9\9\9text = string.sub(this.text, this.stringPosition +1)\13\n\9\9\9text = text .. \" \"\13\n\9\9end\13\n\9end\13\n\9\13\n\9if this.status then\13\n\9\9this.ocui.oclrl:draw(this.posX, this.posY, generateTexture({this.cfg_clickedForegroundColor, this.cfg_clickedBackgroundColor, text}))\13\n\9\9local dt = this.computer.uptime() - this.cursorPTime\13\n\9\9if this.cfg_showCursor and dt < this.cfg_cursorBlinkTime then\13\n\9\9\9this.ocui.oclrl:draw(this.posX +this.cursorPosition -1, this.posY, generateTexture({this.cfg_cursorForegroundColor, this.cfg_cursorBackgroundColor, string.sub(text, this.cursorPosition, this.cursorPosition)}))\13\n\9\9elseif dt > this.cfg_cursorBlinkTime *2 then\13\n\9\9\9this.cursorPTime = this.computer.uptime()\13\n\9\9end\13\n\9else\13\n\9\9this.ocui.oclrl:draw(this.posX, this.posY, generateTexture({this.cfg_normalForegroundColor, this.cfg_normalBackgroundColor, text}))\13\n\9end\13\nend\13\n\13\nfunction OCUI.TextInput.move(this, x, y)\13\n\9this.posX, this.posY = x, y\13\nend\13\n\13\nfunction OCUI.TextInput.stop(this)\13\n\9this.inputThread:kill()\13\n\9\13\n\9this.ocui.ignoreAutoManage(this)\13\nend\13\n\13\n\13\n\13\n--===== Button/Switch =====--\13\nOCUI.Button = {widgetType = \"button\"}\13\nOCUI.Button.__index = OCUI.Button\13\n\13\nfunction OCUI.Button.new(ocui, args) --posX == [int], posY == [int], sizeX == [int], sizeY == [int], args == {listedFunction == [function()], managed == [{update == [bool], draw == [bool]}]}\13\n\13\n\9local this = setmetatable({}, OCUI.Button)\13\n\9this.computer = require(\"computer\")\13\n\9this.ocui = ocui\13\n\9this.posX = UT.parseArgs(args.x, args.posX)\13\n\9this.posY = UT.parseArgs(args.y, args.posY)\13\n\9this.sizeX = UT.parseArgs(args.sx, args.sizeX)\13\n\9this.sizeY = UT.parseArgs(args.sy, args.sizeY)\13\n\9this.listedFunction = UT.parseArgs(args.lf, args.listedFunction, function() end)\13\n\9\13\n\9args.textures = args.textures or {}\13\n\9this.texture0 = UT.parseArgs(args.texture0, args.textures[1], ocui.oclrl.generateTexture({}))\13\n\9this.texture1 = UT.parseArgs(args.texture1, args.textures[2], ocui.oclrl.generateTexture({}))\13\n\9\13\n\9this.cfg_clickTime = UT.parseArgs(args.ct, args.clickTime, .3) --Time the button have to be the clicked texture. If this -1 the button is a switch.\13\n\9this.clickTime = 0 --Time the button was clicked.\13\n\9this.status = false\13\n\9\13\n\9ocui.listAutoManage(this, args.managed or {})\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction OCUI.Button.update(this, x, y)\9\13\n\9if x > this.posX -1 and x < this.posX + this.sizeX and\13\n\9\9y > this.posY -1 and y < this.posY + this.sizeY\13\n\9then\13\n\9\9if this.cfg_clickTime ~= -1 then\13\n\9\9\9this.clickTime = this.computer.uptime()\13\n\9\9\9this.status = true\13\n\9\9else\13\n\9\9\9if this.status then\13\n\9\9\9\9this.status = false\13\n\9\9\9else\13\n\9\9\9\9this.status = true\13\n\9\9\9end\13\n\9\9end\13\n\9\9local success, errorMsg = xpcall(this.listedFunction, debug.traceback, this, x, y)\13\n\9\9if success == false then\13\n\9\9\9this.ocui.onError(this, errorMsg)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction OCUI.Button.draw(this)\13\n\9local dt = -2\13\n\9if this.cfg_clickTime ~= -1 then\13\n\9\9dt = this.computer.uptime() - this.clickTime\13\n\9end\13\n\9\13\n\9if this.status and dt < this.cfg_clickTime then\13\n\9\9this.ocui.oclrl:draw(this.posX, this.posY, this.texture1)\13\n\9else\13\n\9\9this.ocui.oclrl:draw(this.posX, this.posY, this.texture0)\13\n\9\9this.status = false\13\n\9end\13\nend\13\n\13\nfunction OCUI.Button.move(this, x, y)\13\n\9this.posX, this.posY = x, y\13\nend\13\n\13\nfunction OCUI.Button.stop(this)\9\13\n\9this.ocui.ignoreAutoManage(this)\13\nend\13\n\13\nreturn OCUI\13\n",["./libs/ocal.lua"] = "--[[\13\n\9OCAL (OpenComputersAnimationLibarry) is a small libarry for playing animations.\13\n\9It was originaly a part of OCLRL wich is licensed under the GPLv3.\13\n\9\13\n\9oclrl Copyright (C) 2019 MisterNoNameLP.\13\n    ocal Copyright (C) 2020 NosPo Studio.\13\n\9\13\n    This library is free software: you can redistribute it and/or modify\13\n    it under the terms of the GNU General Public License as published by\13\n    the Free Software Foundation, either version 3 of the License, or\13\n    (at your option) any later version.\13\n\13\n    This library is distributed in the hope that it will be useful,\13\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\13\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\n    GNU General Public License for more details.\13\n\13\n    You should have received a copy of the GNU General Public License\13\n    along with this library.  If not, see <https://www.gnu.org/licenses/>.\13\n]]\13\n\13\n--[[ToDo:\13\n\9\13\n\9Bugs:\13\n\9\9Animation clear not working.\13\n\13\n]]\13\nlocal ocal = {version = \"v0.1.2d\"} --OpenComputersGraphicLibary\13\nocal.__index = ocal\13\n\13\n\13\n--===== local vars =====--\13\nlocal computer = require(\"computer\")\13\nlocal shell = require(\"shell\")\13\nlocal fs = require(\"filesystem\")\13\nlocal ut = require(\"libs/UT\")\13\nlocal image = nil\13\n\13\n--===== local functions =====--\13\nlocal function addFrameTime(this, dt, backwards)\13\n\9this.lastFrame = this.currentFrame\13\n\9this.currentFrame = (this.currentFrame + (dt * this.speed))\13\nend\13\n\13\nlocal function clearDBBlack(this, x, y, frame, color, area)\13\n\9local resX, resY = this.ocal.gpu.getResolution()\13\n\9area = area or {0, resX, 0, resY}\13\n\9\13\n\9this.ocal.db.setDrawLimit(area[1], area[3], area[2], area[4])\13\n\9this.ocal.db.drawRectangle(math.floor(x +.5), math.floor(y +.5), frame[1], frame[2], color or 0x000000, 0x000000, \" \")\13\n\9this.ocal.db.resetDrawLimit()\13\nend\13\n\13\n--===== global functions =====--\13\nfunction ocal.initiate(args)\13\n\9local this = setmetatable({}, ocal)\13\n\9args = args or {}\13\n\9\13\n\9this.oclrl = args.oclrl\13\n\9this.db = ut.parseArgs(args.db, args.doubleBuffering, args.DoubleBuffering)\13\n\9this.image = args.image\13\n\9\13\n\9if this.oclrl ~= nil and this.oclrl.gpu ~= nil then\13\n\9\9this.gpu = this.oclrl.gpu\13\n\9else\13\n\9\9this.gpu = component.gpu\13\n\9end\13\n\9\13\n\9if type(this.db) == \"string\" then\13\n\9\9this.db = require(this.db)\13\n\9elseif this.db == nil then\13\n\9\9this.db = require(ut.parseArgs(args.libs, args.libPath, \"\") .. \"/DoubleBuffering\")\13\n\9end\13\n\9if type(this.image) == \"string\" then\13\n\9\9this.image = require(this.dimage)\13\n\9elseif this.image == nil then\13\n\9\9this.image = require(ut.parseArgs(args.libs, args.libPath, \"\") .. \"/image\")\13\n\9end\13\n\9\13\n\9image = this.image\13\n\13\n\9return this\13\nend\13\n\13\nfunction ocal.load(path, args)\13\n\9if string.sub(path, 0, 1) ~= \"/\" then\13\n\9\9path =shell.getWorkingDirectory() .. \"/\" .. path .. \"/\"\13\n\9end\13\n\9\13\n\9local info = dofile(path .. \"info.lua\")\13\n\9local animation = {\13\n\9\9frames = {},\13\n\9}\13\n\9\13\n\9for i, c in pairs(info) do\13\n\9\9animation[i] = c\13\n\9end\13\n\9\13\n\9for file in fs.list(path .. \"frames\") do\13\n\9\9local p, name, ending = ut.seperatePath(file)\13\n\9\9local loadedImage = image.load(path .. \"frames/\" .. file)\13\n\13\n\9\9if args.transparencyFunction ~= nil and args.transparencyColor ~= nil and args.transparencyColor ~= false then\13\n\9\9\9loadedImage = args.transparencyFunction(loadedImage, args.transparencyColor)\13\n\9\9end\13\n\9\9\13\n\9\9animation.frames[tonumber(name)] = loadedImage\13\n\9end\13\n\9\13\n\9return animation\13\nend\13\n\13\n--===== Animation =====--\13\nocal.Animation = {version = \"v0.0d\"} --OpenComputersGraphicLibary\13\nocal.Animation.__index = ocal.Animation\13\n\13\nfunction ocal.Animation.new(ocal, animation, args)\13\n\9local this = setmetatable({}, ocal.Animation)\13\n\9\13\n\9args = args or {}\13\n\9this.ocal = ocal\13\n\9\13\n\9this.speed = args.speed or 1\13\n\9this.useDt = ut.parseArgs(args.dt, true)\13\n\9this.clearTexture = ut.parseArgs(args.clear, true)\13\n\9this.background = args.background\13\n\9this.halt = ut.parseArgs(args.halt, false)\13\n\9this.tmpHalt = false\13\n\9\13\n\9this.currentFrame = args.frame or 1\13\n\9this.lastFrame = this.currentFrame\13\n\9this.lastCall = 0 --time in sec.\13\n\9\13\n\9this.animation, this.useDB = nil, nil\13\n\9\13\n\9if type(animation) == \"string\" then\13\n\9\9this.animation = this.ocal:load(animation)\13\n\9elseif animation.format == \"pan\" then\13\n\9\9this.animation = animation\13\n\9\9this.useDB = true\13\n\9elseif animation.format == \"OCGLA\" then\13\n\9\9this.animation = animation\13\n\9end\13\n\9\13\n\9\13\n\9return this\13\nend\13\n\13\nfunction ocal.Animation.draw(this, posX, posY, dt, clear, background, area)\13\n\9if ut.parseArgs(clear, this.clearTexture) then\13\n\9\9background = ut.parseArgs(background, this.background)\13\n\9\9if background == nil or type(background) == \"number\" then\13\n\9\9\9this:clearBlack(posX, posY, false, background, area)\13\n\9\9else\13\n\9\9\9this:clearBlack(posX, posY, false, background, area)\13\n\9\9\9--this:clear(posX, posY, background, true, false)\13\n\9\9end\13\n\9end\13\n\9\13\n\9if this.useDB then\13\n\9\9local resX, resY = this.ocal.gpu.getResolution()\13\n\9\9area = area or {0, resX, 0, resY}\13\n\9\9\13\n\9\9this.ocal.db.setDrawLimit(area[1], area[3], area[2], area[4])\13\n\9\9this.ocal.db.drawImage(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.currentFrame)])\13\n\9\9this.ocal.db.resetDrawLimit()\13\n\9else\13\n\9\9if this.animation.frames[math.floor(this.currentFrame)] ~= nil then\13\n\9\9\9this.ocal.oclrl:draw(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.currentFrame)], nil, area)\13\n\9\9end\13\n\9end\13\n\9\13\n\9if ut.parseArgs(dt, this.dt) == false then\13\n\9\9addFrameTime(this, 1, backwards)\13\n\9\9return\13\n\9end\13\n\9\13\n\9if dt == nil or dt == true then\13\n\9\9dt = computer.uptime() - this.lastCall\13\n\9\9this.lastCall = computer.uptime()\13\n\9end\13\n\9\13\n\9addFrameTime(this, (dt / this.animation.frameTime), backwards)\13\n\9\13\n\9if math.floor(this.currentFrame) > #this.animation.frames then\13\n\9\9this.currentFrame = 1\13\n\9\9if this.halt or this.tmpHalt then\13\n\9\9\9this.speed = 0\13\n\9\9\9this.tmpHalt = false\13\n\9\9end\13\n\9elseif math.floor(this.currentFrame) < 1 then\13\n\9\9this.currentFrame = #this.animation.frames +.9\13\n\9\9if this.halt or this.tmpHalt then\13\n\9\9\9this.speed = 0\13\n\9\9\9this.currentFrame = 1\13\n\9\9\9this.tmpHalt = false\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction ocal.Animation.clearBlack(this, posX, posY, current, color, area)\13\n\9if current == true then\13\n\9\9if this.useDB then\13\n\9\9\9clearDBBlack(this, math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.currentFrame)], color, area)\13\n\9\9else\13\n\9\9\9this.ocal.oclrl:clearBlack(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.currentFrame)], color, area)\13\n\9\9end\13\n\9elseif current == false then\13\n\9\9if this.useDB then\13\n\9\9\9clearDBBlack(this, math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.lastFrame)], color, area)\13\n\9\9else\13\n\9\9\9this.ocal.oclrl:clearBlack(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.lastFrame)], color, area)\13\n\9\9end\13\n\9else\13\n\9\9if this.useDB then\13\n\9\9\9clearDBBlack(this, math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.currentFrame)], color, area)\13\n\9\9\9clearDBBlack(this, math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.lastFrame)], color, area)\13\n\9\9else\13\n\9\9\9this.ocal.oclrl:clearBlack(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.currentFrame)], color, area)\13\n\9\9\9this.ocal.oclrl:clearBlack(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.lastFrame)], color, area)\13\n\9\9end\13\n\9end\13\nend\13\n\13\nfunction ocal.Animation.clear(this, posX, posY, textures, checkOverlap, current) --useless yet (not supporting \"OCGLT_v0.2\"/\"OCGLA_v0.1\".)\13\n\9if current then\13\n\9\9this.ocal.oclrl:clear(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.currentFrame)], textures, checkOverlap)\13\n\9else\13\n\9\9this.ocal.oclrl:clear(math.floor(posX +.5), math.floor(posY +.5), this.animation.frames[math.floor(this.lastFrame)], textures, checkOverlap)\13\n\9end\13\nend\13\n\13\nfunction ocal.Animation.start(this, speed, frame)\13\n\9this.speed = speed or 1\13\n\9this.currentFrame = frame or 1\13\n\9this.tmpHalt = false\13\nend\13\n\13\nfunction ocal.Animation.stop(this, frame, playTilEnd)\13\n\9if playTilEnd then\13\n\9\9this.tmpHalt = true\13\n\9else\13\n\9\9this.speed = 0\13\n\9\9this.currentFrame = frame or this.currentFrame\13\n\9end\13\nend\13\n\13\nfunction ocal.Animation.pause(this)\13\n\9this.speed = 0\13\nend\13\n\13\nfunction ocal.Animation.play(this, speed)\13\n\9this.speed = speed or 1\13\n\9this.tmpHalt = false\13\nend\13\n\13\n\13\nreturn ocal\13\n\13\n--print(string.sub(\"1234567890\", 0, #\"1234567890\" -3))\13\n--print(string.sub(\"1234567890\", #\"1234567890\" -3 +1))\13\n\13\n\13\n\13\n\13\n\13\n",["./libs/"] = 0,["./conf.lua"] = "--Setting in here are overwriting the nosGaConf settings.\n\nlocal conf = {\n\9texturePack = \"default\",\n\9\n\9particles = 1,\n\9\n\9colors = {\n\9\9button = {\n\9\9\0090x333333, 0x888888, 0x777777, 0xaaaaaa,\n\9\9},\n\9\9background = {0x777777, 0xaaaaaa,},\n\9}\n}\n\nreturn conf\n",["./controls.ini"] = "#The mouse key.\n[mouse]\n\n#Just the chars for control.\n[string]\nplayer1_left=a\nplayer1_right=d\nplayer1_punch=s\n\nplayer2_left=j\nplayer2_right=l\nplayer2_punch=k\n\n#should not be changed\nreset=r\n\ntest=t\ntest2=z\n\n#Char code from key signal, usefull to set e.g.: ctrl+w (23).\n[code]\nplayer1_punch=32\nplayer2_punch=48\n\n#Key code from key signal, usefull to set e.g.: left ctrl (29) or right ctrl (157).\n[key]\n",["./nosGa.lua"] = "local licenseNotice = [[\13\n--===== NosGa Engine (GPLv3) =====--\13\nThe NosGa Engine is a engine fork of ocCtaft (v0.1.2) <https://github.com/MisterNoNameLP/ocCraft>\13\nwhich is licensed under the GPLv3.\13\n\13\nocCtaft Copyright (c) 2019 MisterNoNameLP\13\nNosGa Engine Copyright (C) 2019-2020 NosPo Studio.\13\n\13\nThis program is free software: you can redistribute it and/or modify\13\nit under the terms of the GNU General Public License as published by\13\nthe Free Software Foundation, either version 3 of the License, or\13\n(at your option) any later version.\13\n\13\nThis program is distributed in the hope that it will be useful,\13\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\13\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\13\nGNU General Public License for more details.\13\n\13\nYou should have received a copy of the GNU General Public License\13\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\13\n\13\n--===== Third party (MIT) =====--\13\nThe NosGa Engine is using third party libaries for some functionalities.\13\nMore informations in the source files (\"./libs/thirdParty/\").\13\n\13\nDoubleBuffering Copyright (c) 2018 Igor Timofeev\13\nImage Copyright (c) 2018 Igor Timofeev\13\nOCIF Copyright (c) 2018 Igor Timofeev\13\nColor Copyright (c) 2018 \13\nAdvancedLua Copyright (c) 2018 Igor Timofeev\13\nDoubleBuffering (raw copy feature) Copyright (c) 2019 NosPo Studio\13\n\13\nOpenComputers (OpenOS LUA shell) Copyright (c) 2013-2015 Florian \"Sangar\" Ncke\13\nLUA shell (NosGa version) (c) 2019 NosPo Studio\13\n\13\nLIP (ini file parser) Copyright (c) 2012 Carreras Nicolas\13\n\13\nMIT License\13\n\13\nPermission is hereby granted, free of charge, to any person obtaining a copy\13\nof this software and associated documentation files (the \"Software\"), to deal\13\nin the Software without restriction, including without limitation the rights\13\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\13\ncopies of the Software, and to permit persons to whom the Software is\13\nfurnished to do so, subject to the following conditions:\13\n\13\nThe above copyright notice and this permission notice shall be included in all\13\ncopies or substantial portions of the Software.\13\n\13\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\13\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\13\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\13\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\13\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\13\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\13\nSOFTWARE.\9\13\n]]\13\n\13\n--[[NosGa:\13\n\9Bugs:\13\n\9\9Animations:\13\n\9\9\9Not working. Created animations are the GameObject.\13\n\13\n\9\9\9Structured animation loading is not working.\13\n\9\9\9\13\n\9\9EH:\13\n\9\9\9Worse performance/freeze on signal overflow.\13\n\9\9\13\n\9\9*? Memory leak on game restart/stop.\13\n\9\9\13\n\9\9gameObjects:\13\n\9\9\9*Speed shouldn't be more as the texturePack size (ocgf.RigidBody).\13\n\9\9\13\n\9\9Console:\13\n\9\9\9Text input is buggy sometimes (ocui?).\13\n\9\9\13\n\9\9RE:\13\n\9\9\9Graphic isures on RenderArea leaving GameObjects.\13\n\9\13\n\9ToDo:\9\13\n\9\9GameObject:\13\n\9\9\9Add automatic \"global.extentFunction\" functuinality to parents (pUpdate...).\13\n\9\9\13\n\9\9oclrl:\13\n\9\9\9Add calculateSize(texture) function.\13\n\9\9\13\n\9\9Add dynamic texture color system (oclrl/ocgf).\13\n\9\9\9\13\n\9\9GameObject/RE:\13\n\9\9\9Replayce CopyArea with ClearArea .\13\n\9\9\9\13\n\9*left over from ocCraft but still relevant somehow.\13\n]]\13\nlocal version = \"v0.6.2d\"\13\n\13\n--===== prog start =====--\13\ndo\13\n\9print(licenseNotice)\13\n\9print(\"Starting NosGa Engine \" .. version)\13\n\9local conf = dofile(\"nosGaConf.lua\")\13\n\9\13\n\9local func, err = loadfile(\"data/core/global.lua\")\13\n\9if conf.debug.isDev then\13\n\9\9print(\"Load global: \", func, err)\13\n\9end\13\n\9local global = func(conf)\13\n\9global.version = version\13\n\9global.licenseNotice = licenseNotice\13\n\9\13\n\9local func, err = loadfile(\"data/core/init.lua\")\13\n\9if conf.debug.isDev then\13\n\9\9print(\"Initialize: \", func, err)\13\n\9end\13\n\9local initSuccsess, err = func(global, ...)\13\n\9\13\n\9print(global.isRunning)\13\n\9\13\n\9if initSuccsess then\13\n\9\9local core, err = loadfile(\"data/core/nosGaCore.lua\")\13\n\9\9if global.isDev then\13\n\9\9\9print(\"Init done, starting program: \", core, err)\13\n\9\9end\13\n\9\9\13\n\9\9local success, returnValues = core(global)\13\n\9\9core = nil\13\n\9\9\13\n\9\9global = nil\13\n\9\9return success, returnValues\13\n\9else\13\n\9\9global = nil\13\n\9\9return false, \"init failed\", err\13\n\9end\13\nend\13\n\13\n--===== prog end =====--",} 
--===== local functions =====--
function seperatePath(path) --Ripped from UT_v0.6.1
--seperates a data path ["./DIR/FILE.ENDING"] into the dir path ["./DIR/"], the file name ["FILE"], and the file ending [".ENDING" or nil]
  if string.sub(path, #path) == "/" then
    return path
  end
  
  local dir, fileName, fileEnd = "", "", nil
  local tmpLatest = ""
  for s in string.gmatch(tostring(path), "[^/]+") do
    tmpLatest = s
  end
  dir = string.sub(path, 0, #path -#tmpLatest)
  for s in string.gmatch(tostring(tmpLatest), "[^.]+") do
    fileName = fileName .. s
    tmpLatest = s
  end
  if fileName == tmpLatest then
    fileName = tmpLatest
  else
    fileEnd = "." .. tmpLatest
    fileName = string.sub(fileName, 0, #fileName - #fileEnd +1)
  end
  
  return dir, fileName, fileEnd
end

--===== prog start =====--
local fs = require("filesystem")
local shell = require("shell")
local serialization = require("serialization")

local args, opts = shell.parse(...)
local emptyBufferSpace = 10

if opts.h or #args == 0 then
  
  print("Usage: SETUP [OPTIONS]... [TARGET_DIR]...")
  print("  -h     Shows this text.")
  print("  -o       Overwrite the EXPORT_DIR.")
  
  return true
end

print(licenseNotice)

if not opts.o then
  if string.sub(args[1], 0, 1) == "/" and fs.exists(args[1]) then
    return false, "Folder exists already."
  elseif fs.exists(shell.getWorkingDirectory() .. args[1]) then
    return false, "Folder exists already."
  end
end

for i, s in pairs(data) do
  local path, file, ending = seperatePath(i)
  file = (file or "") .. (ending or "")
  if string.sub(args[1], 0, 1) == "/" then
    path = "/" .. args[1] .. "/" .. (path or "")
  else
    path = shell.getWorkingDirectory() .. "/" .. args[1] .. "/" .. (path or "")
  end
  
  print("Create file: " .. path .. file)
  
  fs.makeDirectory(path)
  if s ~= 0 then
    local f = io.open(path .. file, "w")
    for c = 1, #s, (f.bufferSize - emptyBufferSpace) +1 do
      f:write(string.sub(s, c, c + f.bufferSize - emptyBufferSpace))
      f:flush()
    end
    f:close()
  end
end
